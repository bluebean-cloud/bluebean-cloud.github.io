<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rails server 调研</title>
      <link href="/2023/10/24/ruby-rails-run-server/"/>
      <url>/2023/10/24/ruby-rails-run-server/</url>
      
        <content type="html"><![CDATA[<h1 id="rails-server-调研"><a href="#rails-server-调研" class="headerlink" title="rails server 调研"></a>rails server 调研</h1><h2 id="访问流程"><a href="#访问流程" class="headerlink" title="访问流程"></a>访问流程</h2><p>在浏览器发起请求后，URL 由路由（<code>route.rb</code>）解析，确定交由哪个控制器控制并解析得到参数。之后调用 erb 模板，生成 HTML，将此 HTML 返回到浏览器进行渲染呈现。</p><p>以 cookbook3 项目作为示例，当我们访问 <code>http://127.0.0.1:3000/</code> 时，我们得到的日志如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Started GET &quot;/&quot; for 127.0.0.1 at 2023-10-24 19:24:03 +0800</span><br><span class="line">  ActiveRecord::SchemaMigration Load (0.2ms)  SELECT &quot;schema_migrations&quot;.&quot;version&quot; FROM &quot;schema_migrations&quot; ORDER BY &quot;schema_migrations&quot;.&quot;version&quot; ASC</span><br><span class="line">Processing by RecipesController#index as HTML</span><br><span class="line">  Rendering layout layouts/application.html.erb</span><br><span class="line">  Rendering recipes/index.html.erb within layouts/application</span><br><span class="line">  Recipe Load (0.1ms)  SELECT &quot;recipes&quot;.* FROM &quot;recipes&quot;</span><br><span class="line">  ↳ app/views/recipes/index.html.erb:6</span><br><span class="line">  Category Load (0.1ms)  SELECT &quot;categories&quot;.* FROM &quot;categories&quot; WHERE &quot;categories&quot;.&quot;id&quot; = ? LIMIT ?  [[&quot;id&quot;, 1], [&quot;LIMIT&quot;, 1]]</span><br><span class="line">  ↳ app/views/recipes/_recipe.html.erb:9</span><br><span class="line">  Rendered recipes/_recipe.html.erb (Duration: 86.3ms | Allocations: 11430)</span><br><span class="line">  Category Load (0.0ms)  SELECT &quot;categories&quot;.* FROM &quot;categories&quot; WHERE &quot;categories&quot;.&quot;id&quot; = ? LIMIT ?  [[&quot;id&quot;, 2], [&quot;LIMIT&quot;, 1]]</span><br><span class="line">  ↳ app/views/recipes/_recipe.html.erb:9</span><br><span class="line">  Rendered recipes/_recipe.html.erb (Duration: 1.0ms | Allocations: 492)</span><br><span class="line">  CACHE Category Load (0.0ms)  SELECT &quot;categories&quot;.* FROM &quot;categories&quot; WHERE &quot;categories&quot;.&quot;id&quot; = ? LIMIT ?  [[&quot;id&quot;, 2], [&quot;LIMIT&quot;, 1]]</span><br><span class="line">  ↳ app/views/recipes/_recipe.html.erb:9</span><br><span class="line">  Rendered recipes/_recipe.html.erb (Duration: 0.7ms | Allocations: 448)</span><br><span class="line">  Rendered recipes/index.html.erb within layouts/application (Duration: 131.1ms | Allocations: 24227)</span><br><span class="line">  Rendered layout layouts/application.html.erb (Duration: 362.1ms | Allocations: 50060)</span><br><span class="line">Completed 200 OK in 498ms (Views: 380.8ms | ActiveRecord: 0.9ms | Allocations: 67023)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在日志头记录了请求的类型、日期和来源。随后 <code>ActiveRecord::SchemaMigration Load</code> 进行数据库查询，检查数据库中的迁移版本。这是在检查数据库结构是否与应用程序期望的相匹配。</p><p><code>Processing by RecipesController#index as HTML</code> 这句话意为该请求由 <code>RecipeController</code> 控制器进行处理，转发为 <code>#index</code> 操作，并且期待 <code>HTML</code> 响应。</p><p><code>Rendering layout layouts/application.html.erb</code> 指出了正在呈现应用程序的主布局文件 <code>application.html.erb</code></p><p><code>Rendering recipes/index.html.erb within layouts/application</code> 意为 <code>recipes/index.html.erb</code> 视图嵌套于主布局中。</p><p><code>Recipe Load (0.1ms)  SELECT &quot;recipes&quot;.* FROM &quot;recipes&quot;</code> 表示 SQL 查询，从数据库中查询 recipes 的数据。之后的几句日志都意为从数据库中查询、获取数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rendered recipes/_recipe.html.erb (Duration: 0.7ms | Allocations: 448)</span><br><span class="line">Rendered recipes/index.html.erb within layouts/application (Duration: 131.1ms | Allocations: 24227)</span><br><span class="line">Rendered layout layouts/application.html.erb (Duration: 362.1ms | Allocations: 50060)</span><br></pre></td></tr></table></figure><p>表明已成功返回 Render，网页成功呈现。</p><p><code>Completed 200 OK in 498ms (Views: 380.8ms | ActiveRecord: 0.9ms | Allocations: 67023)</code> 这是日志的结束部分，指明整个请求处理的耗费时间、状态码、以及资源分配信息。</p><h2 id="Rails-启动流程"><a href="#Rails-启动流程" class="headerlink" title="Rails 启动流程"></a>Rails 启动流程</h2><h3 id="config-boot-rb-文件"><a href="#config-boot-rb-文件" class="headerlink" title="config/boot.rb 文件"></a><code>config/boot.rb</code> 文件</h3><p>此文件包含如下内容：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">ENV</span>[<span class="string">&quot;BUNDLE_GEMFILE&quot;</span>] |<span class="params"></span>|= <span class="title class_">File</span>.expand_path(<span class="string">&quot;../Gemfile&quot;</span>, __dir__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">&quot;bundler/setup&quot;</span> <span class="comment"># Set up gems listed in the Gemfile.</span></span><br><span class="line"><span class="comment"># require &quot;bootsnap/setup&quot; # Speed up boot time by caching expensive operations.</span></span><br></pre></td></tr></table></figure><p>环境变量 <code>BUNDLE_GEMFILE</code> 的作用是制定 bundle 文件路径。</p><p><code>require &quot;bundle/setup&quot;</code> 的目的是加载 Bundler 库并设置应用程序的环境。Bundler 是 Ruby 的依赖管理器，用于管理应用程序所需的 Gem 依赖项。</p><p>其具体会做以下事情：</p><ol><li>加载 Bundle 库。</li><li>设置 Gem 加载路径。</li><li>检查 Gem 依赖项。</li></ol><p><code># require &quot;bootsnap/setup&quot; # Speed up boot time by caching expensive operations.</code> 这句话会用于加速 rails 的启动速度。但是在我的本机上由于某些兼容问题，导致包含此选项会报错，无法启动 rails server，故而将其注掉。</p><h3 id="bin-rails-rb-文件"><a href="#bin-rails-rb-文件" class="headerlink" title="bin/rails.rb 文件"></a><code>bin/rails.rb</code> 文件</h3><p>内容如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env ruby.exe</span></span><br><span class="line"><span class="variable constant_">APP_PATH</span> = <span class="title class_">File</span>.expand_path(<span class="string">&quot;../config/application&quot;</span>, __dir__)</span><br><span class="line">require_relative <span class="string">&quot;../config/boot&quot;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&quot;rails/commands&quot;</span></span><br></pre></td></tr></table></figure><p>其中 <code>rails/commands.rb</code> 内容如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">&quot;rails/command&quot;</span></span><br><span class="line"></span><br><span class="line">aliases = &#123;</span><br><span class="line">  <span class="string">&quot;g&quot;</span>  =&gt; <span class="string">&quot;generate&quot;</span>,</span><br><span class="line">  <span class="string">&quot;d&quot;</span>  =&gt; <span class="string">&quot;destroy&quot;</span>,</span><br><span class="line">  <span class="string">&quot;c&quot;</span>  =&gt; <span class="string">&quot;console&quot;</span>,</span><br><span class="line">  <span class="string">&quot;s&quot;</span>  =&gt; <span class="string">&quot;server&quot;</span>,</span><br><span class="line">  <span class="string">&quot;db&quot;</span> =&gt; <span class="string">&quot;dbconsole&quot;</span>,</span><br><span class="line">  <span class="string">&quot;r&quot;</span>  =&gt; <span class="string">&quot;runner&quot;</span>,</span><br><span class="line">  <span class="string">&quot;t&quot;</span>  =&gt; <span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">command = <span class="variable constant_">ARGV</span>.shift</span><br><span class="line">command = aliases[command] |<span class="params"></span>| command</span><br><span class="line"></span><br><span class="line"><span class="title class_">Rails</span><span class="symbol">:</span><span class="symbol">:Command</span>.invoke command, <span class="variable constant_">ARGV</span></span><br></pre></td></tr></table></figure><p>这部分内容主要在于对控制台指令的转发。例如，如果我们输入 <code>rails s</code>，则会被解释成 <code>rails server</code>。</p><h3 id="Gem-包的加载顺序"><a href="#Gem-包的加载顺序" class="headerlink" title="Gem 包的加载顺序"></a>Gem 包的加载顺序</h3><p>列在 <code>Gemfile</code> 中的包通常是按照声明顺序加载的。有些 Gem 包之间可能存在依赖关系，Bundler 会确保存在依赖的 Gem 在加载时正确处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> Ruby on Railss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ruby 学习：绪论与基础语法</title>
      <link href="/2023/10/11/ruby-study-0/"/>
      <url>/2023/10/11/ruby-study-0/</url>
      
        <content type="html"><![CDATA[<h1 id="Ruby-学习：绪论与基础语法"><a href="#Ruby-学习：绪论与基础语法" class="headerlink" title="Ruby 学习：绪论与基础语法"></a>Ruby 学习：绪论与基础语法</h1><h2 id="什么是-Ruby"><a href="#什么是-Ruby" class="headerlink" title="什么是 Ruby"></a>什么是 Ruby</h2><p>Ruby 是一种高级的、面向对象的、动态类型的脚本类型语言。是一种逐渐没落（悲）的 Web 应用开发语言和框架。</p><p>Ruby 的开发者是日本人松本行弘。官方文档：<a href="https://www.ruby-lang.org/zh_cn/documentation/">Ruby 文档</a></p><p>Ruby 是一门完全面向对象的语言。其语法十分灵活（冗余）。举个例子，你知道循环十次有四种不同的写法吗？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span></span><br><span class="line">  puts <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>.times <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.upto(<span class="number">10</span>) <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>..<span class="number">10</span>).each <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 ruby 中，万物皆对象（我认为比 Java 还要彻底）。连一个简单的整数 <code>10</code> 都是一个对象（<code>10.times</code> 就是调用了对象上的方法）。</p><p>ruby 的设计理念是”以人为本”。所以个体使用 ruby 的开发效率会很快。我们可以使用几行代码完成其他语言几十行完成的工作。</p><h2 id="Ruby-on-rails-是什么"><a href="#Ruby-on-rails-是什么" class="headerlink" title="Ruby on rails 是什么"></a>Ruby on rails 是什么</h2><p>Ruby on Rails 是一种流行的，开源的，面向对象的Web开发框架，许多程序员和应用程序提供商都在使用该框架。 它基于模型视图控制器（MVC）方法。</p><p>模型映射到数据库，功能映射到应用程序中的对象，例如用户。 Rails为命名和文件目录结构提供了一个标准约定，该约定简化了编程，还提供了自动构建功能的解决方案，称为脚手架。 它还确保了开发人员可以共同工作并从彼此的努力中受益的共同环境。</p><p>Rails 哲学包含两大指导思想：</p><ul><li>不要自我重复（DRY）： DRY 是软件开发中的一个原则，“系统中的每个功能都要具有单一、准确、可信的实现。”。不重复表述同一件事，写出的代码才能更易维护，更具扩展性，也更不容易出问题。</li><li>多约定，少配置： Rails 为网页程序的大多数需求都提供了最好的解决方法，而且默认使用这些约定，不用在长长的配置文件中设置每个细节。</li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是单行注释</span></span><br></pre></td></tr></table></figure><p>多行注释</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">这是多行注释</span></span><br><span class="line"><span class="comment">以=begin开始，=end结束，=要顶格写</span></span><br><span class="line"><span class="comment">=end</span> </span><br></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>ruby 中赋值无需声明类型（动态类型），解释器将自行解释变量的类型。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">say = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">puts say</span><br><span class="line"></span><br><span class="line">x = y = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在 ruby 中，任何语句都具有返回值。因此在函数中我们有时可以不写 return，默认返回最后一句话的返回值。</p><p>在赋值时，可以同时给多个变量赋值。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> <span class="comment"># =&gt;[10, 20, 30]</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span> <span class="comment"># a=1, b=2, c=nil</span></span><br></pre></td></tr></table></figure><p>事实上是转换成为了列表然后进行赋值。</p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">  puts <span class="string">&quot;x&gt;5&quot;</span></span><br><span class="line"><span class="keyword">elsif</span> x &gt; <span class="number">0</span></span><br><span class="line">  puts <span class="string">&quot;0&lt;x&lt;=5&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  puts <span class="string">&quot;x&lt;=0&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 ruby 的真值判断中，只有 nil 类型和 false 代表假。其余都代表真。</p><p>条件判断语句可以后置。如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="number">1</span></span><br><span class="line">puts <span class="string">&quot;hello world&quot;</span> <span class="keyword">if</span> flag == <span class="number">1</span></span><br><span class="line">puts <span class="string">&quot;hello world&quot;</span> <span class="keyword">unless</span> flag != <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这很符合通常的语言习惯，写起来尊嘟很舒适。</p><h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><p>在 ruby 中，选择语句的写法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通常的选择</span></span><br><span class="line">car = <span class="string">&quot;Patriot&quot;</span></span><br><span class="line">manufacturer = <span class="keyword">case</span> car</span><br><span class="line">    <span class="keyword">when</span> <span class="string">&quot;Focus&quot;</span> <span class="keyword">then</span> <span class="string">&quot;Ford&quot;</span></span><br><span class="line">    <span class="keyword">when</span> <span class="string">&quot;Navigator&quot;</span> <span class="keyword">then</span> <span class="string">&quot;Lincoln&quot;</span></span><br><span class="line">    <span class="keyword">when</span> <span class="string">&quot;Camry&quot;</span> <span class="keyword">then</span> <span class="string">&quot;Toyota&quot;</span></span><br><span class="line">    <span class="keyword">when</span> <span class="string">&quot;Civic&quot;</span> <span class="keyword">then</span> <span class="string">&quot;Honda&quot;</span></span><br><span class="line">    <span class="keyword">when</span> <span class="string">&quot;Patriot&quot;</span> <span class="keyword">then</span> <span class="string">&quot;Jeep&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">               <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区间选择</span></span><br><span class="line">score = <span class="number">70</span></span><br><span class="line">result = <span class="keyword">case</span> score</span><br><span class="line">    <span class="keyword">when</span> <span class="number">0</span>..<span class="number">40</span> <span class="keyword">then</span> <span class="string">&quot;Fail&quot;</span></span><br><span class="line">    <span class="keyword">when</span> <span class="number">41</span>..<span class="number">60</span> <span class="keyword">then</span> <span class="string">&quot;Pass&quot;</span></span><br><span class="line">    <span class="keyword">when</span> <span class="number">61</span>..<span class="number">70</span> <span class="keyword">then</span> <span class="string">&quot;Pass with Merit&quot;</span></span><br><span class="line">    <span class="keyword">when</span> <span class="number">71</span>..<span class="number">100</span> <span class="keyword">then</span> <span class="string">&quot;Pass with Distinction&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="string">&quot;Invalid Score&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>事实上 case 语句是通过比较操作符 ‘case equality’（即 ‘===’）进行判断的。 </p><p>此操作符不测试通常的相等关系，而是判断二者之间是否拥有 _Is-a_ 关系。即不测试相等性，而测试包容性。一般而言，应当避免显式使用三等号，因为这容易造成混淆。</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>合法的循环方式们：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> <span class="comment"># do 可以省略</span></span><br><span class="line">  puts <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> <span class="keyword">do</span> puts <span class="string">&quot;hello world&quot;</span> <span class="keyword">end</span> <span class="comment"># 可以一行写完</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span> <span class="keyword">do</span> <span class="comment"># puts i += 1 until i == 5</span></span><br><span class="line">  puts i</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">10</span></span><br><span class="line"><span class="keyword">until</span> i &lt; <span class="number">5</span> <span class="keyword">do</span> <span class="comment"># puts i -= 1 while i &gt; 5</span></span><br><span class="line">  puts i</span><br><span class="line">  i -= <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>.times &#123; puts <span class="string">&quot;hello world&quot;</span> &#125; <span class="comment"># 对于固定次数的循环我十分喜欢这种写法</span></span><br><span class="line"><span class="number">1</span>.upto(<span class="number">10</span>) &#123; puts <span class="string">&quot;hello world&quot;</span> &#125;</span><br><span class="line"><span class="number">10</span>.downto(<span class="number">1</span>) &#123; puts <span class="string">&quot;hello world&quot;</span> &#125;</span><br><span class="line">(<span class="number">1</span>..<span class="number">10</span>).each &#123; puts <span class="string">&quot;hello world&quot;</span> &#125; <span class="comment"># 我喜欢使用这个代替 for 循环</span></span><br></pre></td></tr></table></figure><p>引用循环变量：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>.times &#123; |<span class="params">x</span>| puts x &#125;</span><br><span class="line">(<span class="number">1</span>..<span class="number">10</span>).each &#123; |<span class="params">x</span>| puts x &#125;</span><br><span class="line"><span class="number">1</span>.upto(<span class="number">10</span>) &#123; |<span class="params">x</span>| puts x &#125;</span><br><span class="line"><span class="number">10</span>.downto(<span class="number">1</span>) &#123; |<span class="params">x</span>| puts x &#125;</span><br><span class="line"><span class="number">1</span>.step(<span class="number">10</span>, <span class="number">2</span>) &#123; |<span class="params">x</span>| puts x &#125;</span><br><span class="line">(<span class="number">1</span>..<span class="number">10</span>).step(<span class="number">2</span>) &#123; |<span class="params">x</span>| puts x &#125;</span><br></pre></td></tr></table></figure><p>真是十分便捷的写法。</p><h2 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h2><p>全局变量：以 $ 开头。<br>对象实例属性：以 @ 开头。<br>类属性：以 @@ 开头。<br>本地变量：以小写字母开头。<br>常量：以大写字母开头</p><h2 id="单引号与双引号"><a href="#单引号与双引号" class="headerlink" title="单引号与双引号"></a>单引号与双引号</h2><p>单引号括起来的字符串不会解释转义字符，而双引号会。一般在支持单双引号的语言中都是这么约定的。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>有多种办法进行字符串的变量替换。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line">str = <span class="string">&quot;num is <span class="subst">#&#123;num&#125;</span>&quot;</span>   <span class="comment"># num is 100</span></span><br><span class="line">str = <span class="string">%Q(num is <span class="subst">#&#123;num&#125;</span>)</span> <span class="comment"># num is 100</span></span><br><span class="line">str = <span class="string">%(num is <span class="subst">#&#123;num&#125;</span>)</span>  <span class="comment"># num is 100</span></span><br><span class="line">str = <span class="string">%q(num is <span class="subst">#&#123;num&#125;</span>)</span> <span class="comment"># num is #&#123;num&#125;</span></span><br><span class="line"><span class="comment"># %q 内被视作单引号，故不会进行变量替换</span></span><br></pre></td></tr></table></figure><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>才写到符号家人们，后面的语法以后再来探索吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW7</title>
      <link href="/2023/08/17/OO-hw7/"/>
      <url>/2023/08/17/OO-hw7/</url>
      
        <content type="html"><![CDATA[<p>本次作业新增了以下两个约束：</p><ol><li>新增的电梯有可达性要求，即只能在特定的楼层停靠。</li><li>限制了在同一层开门的电梯数量。</li></ol><p>本次作业主要的难点在于当停掉所有的全能电梯（即初始的六部电梯）后需要对乘客规划路径。本次作业中动态规划路径 + 加权最短路取得了非常优秀的成绩（我的大佬同学）。</p><p>本次作业中我重新考虑了以下电梯的移动逻辑、添加了搜索路径算法与电梯开门数量控制。</p><h2 id="运行策略"><a href="#运行策略" class="headerlink" title="运行策略"></a>运行策略</h2><p><strong>hw5</strong> 与 <strong>hw6</strong> 的策略相似，但是策略不是很能适应 <strong>hw7</strong> 的需求。</p><p>本次作业中，电梯采取了类似 <strong>look</strong> 策略的掉头逻辑。当前方没有任务请求且电梯乘客队列为空时则掉头。这样设计带来的好处是电梯可以接受不同方向的乘客请求。</p><h2 id="分配乘客策略"><a href="#分配乘客策略" class="headerlink" title="分配乘客策略"></a>分配乘客策略</h2><p>首先尝试直接分配乘客。接下来若乘客已被规划过路径且路径中的电梯没有维护则乘客按照既定的路径。否则给乘客规划新的路径。</p><p>存储路径的方式：使用一个二位数组 <strong>path[][2]</strong>。<strong>path[i][0]</strong> 的含义是要乘坐第 <strong>i</strong> 部电梯的 <strong>id</strong>。<strong>path[i][1]</strong> 的含义是要乘坐该部电梯所到达的楼层。</p><h2 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h2><p>采取类似最小生成树的方式寻找路径。每次尝试添加一部电梯，若尝试添加的电梯的可达楼层与当前可达楼层没有交集或是当前可达楼层的子集，则不添加这个电梯；否则加入这个电梯，直到当前可达楼层包含乘客目的地时，代表我们找到了一个路径。之后就是把路径提取出来。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>AllRequest.AllRequest(ArrayList\<Request\>)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.getRequest()</td><td>4.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>AllRequest.getRequests()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.isEmpty()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.isEnd()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.run()</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Building.addPassenger(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Building.addService(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Building.Building(AllRequest, ArrayList\<Request\>)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Building.delService(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Building.directlyAlloc(Passenger)</td><td>13.0</td><td>4.0</td><td>6.0</td><td>10.0</td></tr><tr><td>Building.elevatorEnd()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.findPath(Passenger)</td><td>25.0</td><td>7.0</td><td>9.0</td><td>13.0</td></tr><tr><td>Building.handleFindPath(Information, Passenger, ArrayList\<int\[]\[]\>)</td><td>27.0</td><td>1.0</td><td>13.0</td><td>15.0</td></tr><tr><td>Building.handleRequest()</td><td>12.0</td><td>7.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Building.isEnd()</td><td>1.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Building.openAble(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Building.pasAlloc(Passenger)</td><td>12.0</td><td>7.0</td><td>8.0</td><td>9.0</td></tr><tr><td>Building.run()</td><td>3.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.step()</td><td>13.0</td><td>1.0</td><td>8.0</td><td>8.0</td></tr><tr><td>Elevator.capacityAlloc()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.carry(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.Elevator(int, int, double, int, int, int, Building)</td><td>6.0</td><td>1.0</td><td>1.0</td><td>4.0</td></tr><tr><td>Elevator.findBottom()</td><td>4.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Elevator.findTop()</td><td>4.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Elevator.getAccess()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getId()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getState()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.goDie()</td><td>13.0</td><td>4.0</td><td>11.0</td><td>11.0</td></tr><tr><td>Elevator.hasPassenger()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Elevator.ifDirectly(Passenger)</td><td>2.0</td><td>3.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Elevator.ifOff()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Elevator.ifOff(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.ifTake()</td><td>4.0</td><td>4.0</td><td>2.0</td><td>4.0</td></tr><tr><td>Elevator.ifTake(Passenger)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isDie()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEmpty()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEnd()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isFree()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.move()</td><td>15.0</td><td>3.0</td><td>6.0</td><td>12.0</td></tr><tr><td>Elevator.setDie(boolean)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.step()</td><td>22.0</td><td>8.0</td><td>16.0</td><td>19.0</td></tr><tr><td>Elevator.takeOff()</td><td>7.0</td><td>2.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Elevator.takeOff(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.takeOn()</td><td>5.0</td><td>2.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Elevator.takeOn(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.tryClose()</td><td>1.0</td><td>2.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Elevator.tryOpen()</td><td>5.0</td><td>2.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Information.add(int, int, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.getAccess(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.getAccessById(int)</td><td>3.0</td><td>3.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Information.getId(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.getNow(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.getPathLen(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.growPathLen(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.setNow(int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.size()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>MainClass.main(String[])</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.addPath(int[])</td><td>3.0</td><td>1.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Passenger.clearPath()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getDirection()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getFinish()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getFistPath()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getId()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getPath()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getStart()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.Passenger(int, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.removePathHead()</td><td>3.0</td><td>1.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Passenger.setPath(int[][])</td><td>4.0</td><td>3.0</td><td>2.0</td><td>4.0</td></tr><tr><td>Passenger.takeOff(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.getValue()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isClosing()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isDie()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isOpen()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isOpening()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isRunning()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isWait()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setClosing()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setDie()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setOpen()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setOpening()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setRunning()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setWait()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.State(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>225.0</td><td>141.0</td><td>193.0</td><td>235.0</td></tr><tr><td>Average</td><td>2.616279069767442</td><td>1.6395348837209303</td><td>2.244186046511628</td><td>2.7325581395348837</td></tr></tbody></table></div><p>本次作业复杂度中搜索路径的两个方法复杂度较高。这部分我写的这部分太面向过程了。</p><h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><p>本次作业由于把分配乘客的间隔设置为 <strong>1s</strong> 而寄了五个点…要不本来只会寄一个点，只能说是弄巧成拙了。后来检查的时候发现是乘客分配的锅，但是我也没有找到到底是哪里有问题…于是最后在电梯步进的时候对任务队列做了一个强检查，要是不能达到乘客需求的楼层就把他弹回楼里。</p><h2 id="协作关系"><a href="#协作关系" class="headerlink" title="协作关系"></a>协作关系</h2><p>由于本单元均为状态机逻辑，故没有线程之间的协作关系</p><h2 id="Dbug技巧"><a href="#Dbug技巧" class="headerlink" title="Dbug技巧"></a>Dbug技巧</h2><p>单线程的状态机 <strong>dbug</strong> 还是比较简单的，出了问题之后感觉哪里有问题在哪里添加 <strong>println</strong> 打印状态就可以了。而且所有 <strong>bug</strong> 都能够稳定复现，我在本单元基本没有为 <strong>dbug</strong> 苦恼过。</p><h2 id="本单元收获"><a href="#本单元收获" class="headerlink" title="本单元收获"></a>本单元收获</h2><p>遗憾的是，本单元并没有怎么学习到多线程的精髓…收获最大的大概是和同学一起搭的评测机。本单元由于测试一个点的时间过长，于是评测机需要是多进程的，于是乎在这个过程中学习了一些多进程的写法，也算是学到了一些新东西。此外前两次的数据生成也是由我负责的，从自己生成的数据与课程组强测的数据对比我也学习到了一些数据生成的要领。事实上，单纯由程序随机生成的数据总是有缺陷的。最优解是通过随机跑出来一些数据之后通过手动微调数据，或者直接手搓一些特殊的测试点。第六次作业我自己生成的数据强度还是比较认可的，就是因为太强了而不满足互测标准从而没法在互测里直接用…不过那个评测机 <strong>d</strong> 出来的 <strong>bug</strong> 是真不少。</p><p>在学习的过程中也感受到了不同科目之间的交叉性。比如 <strong>OO</strong> 课内讲到的概念在 <strong>OS</strong> 上也会有提及。另外 <strong>CO</strong> 的状态机设计也助我通过了本次作业。事实上貌似只要设计的好，电梯这单元无论如何使用状态机都是有出路的。来年或许可以想一个办法 <strong>ban</strong> 掉状态机（如果当上了助教的话）。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 电梯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW6</title>
      <link href="/2023/08/17/OO-hw6/"/>
      <url>/2023/08/17/OO-hw6/</url>
      
        <content type="html"><![CDATA[<p>本次作业在第五次作业的基础上新增了两个功能：</p><ol><li>允许新增自定义电梯。</li><li>允许电梯进入维护状态（即从系统中移除此电梯）</li></ol><p>自定义电梯里可自定义的参数：运行速度、载客数量、起始楼层</p><h2 id="新增电梯与维护电梯"><a href="#新增电梯与维护电梯" class="headerlink" title="新增电梯与维护电梯"></a>新增电梯与维护电梯</h2><p>新增电梯没什么特别好说的，获取电梯的各个参数然后直接 <strong>add</strong> 进 <strong>building</strong> 的电梯数组里就可以。</p><p>维护电梯事实上就是给电梯发出一个死亡信号，让这个电梯立刻停下手中的工作，然后让其去世，最后将其从 <strong>building</strong> 的电梯数组中删除。</p><p>在死亡过程中，首先释放电梯尚未接到的任务。然后让电梯立刻转到开门状态（如果已经处于开门状态则不开门），释放内部乘客后将其置为死亡状态。</p><h2 id="重构部分"><a href="#重构部分" class="headerlink" title="重构部分"></a>重构部分</h2><p>在 <strong>Hw6</strong> 的过程中小小的重构了一下自己的代码。</p><p>主要内容包括：将时钟周期置为 <strong>0.1s</strong>。为新的请求类型添加了解析方法。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>AllRequest.AllRequest(ArrayList\<Request>)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.getRequest()</td><td>4.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>AllRequest.getRequests()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.isEmpty()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.isEnd()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.run()</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Building.Building(AllRequest, ArrayList\<Request>)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Building.elevatorDie(Elevator)</td><td>15.0</td><td>6.0</td><td>14.0</td><td>14.0</td></tr><tr><td>Building.elevatorEnd()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.findNearEmpty(int)</td><td>6.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Building.handleRequest()</td><td>12.0</td><td>7.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Building.isEnd()</td><td>1.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Building.pasAlloc(Passenger)</td><td>9.0</td><td>6.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Building.run()</td><td>3.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.step()</td><td>11.0</td><td>1.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Elevator.capacityAllow(Passenger)</td><td>12.0</td><td>6.0</td><td>1.0</td><td>6.0</td></tr><tr><td>Elevator.carry(Passenger)</td><td>6.0</td><td>1.0</td><td>1.0</td><td>4.0</td></tr><tr><td>Elevator.checkBegin()</td><td>5.0</td><td>2.0</td><td>4.0</td><td>6.0</td></tr><tr><td>Elevator.Elevator(int, int, double, int, int, int, int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Elevator.findBottom()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.findTop()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.getFloor()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getId()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getPassengers()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getState()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getTasks()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.ifOff()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Elevator.ifOff(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.ifPassingly(Passenger)</td><td>11.0</td><td>7.0</td><td>4.0</td><td>7.0</td></tr><tr><td>Elevator.ifTake()</td><td>6.0</td><td>3.0</td><td>2.0</td><td>4.0</td></tr><tr><td>Elevator.ifTake(Passenger)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isDie()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEmpty()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEnd()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isFree()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.move()</td><td>20.0</td><td>2.0</td><td>6.0</td><td>9.0</td></tr><tr><td>Elevator.setDie(boolean)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.step()</td><td>21.0</td><td>3.0</td><td>14.0</td><td>16.0</td></tr><tr><td>Elevator.takeOff()</td><td>4.0</td><td>2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Elevator.takeOff(Passenger)</td><td>6.0</td><td>1.0</td><td>1.0</td><td>4.0</td></tr><tr><td>Elevator.takeOffAll()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.takeOn()</td><td>4.0</td><td>2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Elevator.takeOn(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.tryClose()</td><td>4.0</td><td>3.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Elevator.tryOpen()</td><td>7.0</td><td>4.0</td><td>6.0</td><td>7.0</td></tr><tr><td>MainClass.main(String[])</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getDirection()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getFinish()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getId()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getStart()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.Passenger(int, int, int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Passenger.takeOff(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.getValue()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isClosing()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isOpen()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isOpening()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isRunning()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isWait()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setClosing()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setOpen()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setOpening()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setRunning()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setWait()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.State(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>187.0</td><td>113.0</td><td>152.0</td><td>185.0</td></tr><tr><td>Average</td><td>2.8333333333333335</td><td>1.7121212121212122</td><td>2.303030303030303</td><td>2.803030303030303</td></tr></tbody></table></div><p>本次作业的复杂度依然控制在一个可以接受的程度。事后发现了一些架构上的优化方法，可以进一步优化复杂度。</p><h2 id="bug-分析"><a href="#bug-分析" class="headerlink" title="bug 分析"></a>bug 分析</h2><p>本次作业没有出现 <strong>bug</strong>，并在强测中拿到了 <strong>96.5</strong> 的成绩。由于状态机本质上是单线程逻辑，所以所有 <strong>bug</strong> 都可以稳定复现，在 <strong>dbug</strong> 的时候也相对方便（在需要观察的地方添加 <strong>println</strong>）。</p><p>在本次作业中由于将时钟周期设置为 <strong>0.1s</strong>，导致整体刷新速度过于频繁，反而导致了更久的 <strong>CPU</strong> 时长。经过综合考虑，我决定在下次作业里将时钟周期重设为更合理的 <strong>0.2s</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 电梯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客~</title>
      <link href="/2023/08/17/hello-world/"/>
      <url>/2023/08/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是 <strong>bluebean</strong> 的第一篇博客，记录一下搭建过程顺便测试测试各种功能~</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>搭建过程中真是参考了很多大佬的博客呀。</p><p>搭建过程中遇到了一些坑。本来想采用 <strong>Matery</strong> 主题的，但是实在是调不来配置了……接触 <strong>Butterfly</strong> 主题后我发现这个主题更加完善，<strong>bug</strong> 更少，风格也十分简洁，故最后选择了配置<strong>Butterfly</strong> 主题。</p><p>以下是对我帮助十分大的几篇博客：</p><p>从零开始，使用 <strong>butterfly</strong> 主题搭建博客：<a href="https://www.fomal.cn/posts/e593433d.html#8-%E5%88%9D%E5%A7%8B%E5%8C%96-Hexo-%E9%A1%B9%E7%9B%AE">Hexo博客搭建基础教程</a></p><p>另一篇从零开始的教程：<a href="https://www.cnblogs.com/huanhao/p/hexobase.html#%E5%9F%BA%E7%A1%80%E7%AF%87%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E4%B8%80">hexo博客搭建教程</a></p><p>这篇博客有对 <strong>butterfly</strong> 主题各项配置的详细说明：<a href="https://www.fomal.cn/posts/3451f874.html">Butterfly配置</a></p><p>这篇博客也作为参考：<a href="https://moonshuo.cn/posts/37568.html">Butterfly主题配置美化</a></p><h2 id="公式测试"><a href="#公式测试" class="headerlink" title="公式测试"></a>公式测试</h2><p>随便输点公式，测试一下对数学公式的支持。</p><p>整行公式：</p><script type="math/tex; mode=display">f(x)=\begin{cases} \frac{\beta^\alpha}{\Gamma(\alpha)},\quad x>0\\ 0,\quad x\leq0\end{cases}</script><script type="math/tex; mode=display">g(x,y)=x+y*2</script><p>行内公式：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.902ex;" xmlns="http://www.w3.org/2000/svg" width="17.725ex" height="3.058ex" role="img" focusable="false" viewBox="0 -952.7 7834.6 1351.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mo" transform="translate(0 0.5)"><path data-c="222B" d="M113 -244Q113 -246 119 -251T139 -263T167 -269Q186 -269 199 -260Q220 -247 232 -218T251 -133T262 -15T276 155T297 367Q300 390 305 438T314 512T325 580T340 647T361 703T390 751T428 784T479 804Q481 804 488 804T501 805Q552 802 581 769T610 695Q610 669 594 657T561 645Q542 645 527 658T512 694Q512 705 516 714T526 729T538 737T548 742L552 743Q552 745 545 751T525 762T498 768Q475 768 460 756T434 716T418 652T407 559T398 444T387 300T369 133Q349 -38 337 -102T303 -207Q256 -306 169 -306Q119 -306 87 -272T55 -196Q55 -170 71 -158T104 -146Q123 -146 138 -159T153 -195Q153 -206 149 -215T139 -230T127 -238T117 -242L113 -244Z"></path></g><g data-mml-node="TeXAtom" transform="translate(699.9,532.6) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(505,-340.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g></g><g data-mml-node="msup" transform="translate(2173.8,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(778,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g><g data-mml-node="mi" transform="translate(3986.1,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(4506.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(5355.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msqrt" transform="translate(6411.6,0)"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g><g data-mml-node="mo" transform="translate(0,-22.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="570" height="60" x="853" y="717.5"></rect></g></g></g></svg></mjx-container></p><h2 id="代码块测试"><a href="#代码块测试" class="headerlink" title="代码块测试"></a>代码块测试</h2><p>代码块测试：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>行内代码测试：<code>printf("hello world!\n");</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django 学习笔记_1</title>
      <link href="/2023/07/14/Django-1/"/>
      <url>/2023/07/14/Django-1/</url>
      
        <content type="html"><![CDATA[<p>内容太多了断个章接着记笔记…</p><h2 id="编辑更多视图"><a href="#编辑更多视图" class="headerlink" title="编辑更多视图"></a>编辑更多视图</h2><p>让我们向 <code>polls/views.py</code> 中添加更多视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detail</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;You&#x27;re looking at question %s.&quot;</span> % question_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">results</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    response = <span class="string">&quot;You&#x27;re looking at the results of question %s.&quot;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(response % question_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vote</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;You&#x27;re voting on question %s.&quot;</span> % question_id)</span><br></pre></td></tr></table></figure><p>将这些视图添加进 <code>polls.urls</code> 模块里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># ex: /polls/</span></span><br><span class="line">    path(<span class="string">&quot;&quot;</span>, views.index, name=<span class="string">&quot;index&quot;</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/</span></span><br><span class="line">    path(<span class="string">&quot;&lt;int:question_id&gt;/&quot;</span>, views.detail, name=<span class="string">&quot;detail&quot;</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/results/</span></span><br><span class="line">    path(<span class="string">&quot;&lt;int:question_id&gt;/results/&quot;</span>, views.results, name=<span class="string">&quot;results&quot;</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/vote/</span></span><br><span class="line">    path(<span class="string">&quot;&lt;int:question_id&gt;/vote/&quot;</span>, views.vote, name=<span class="string">&quot;vote&quot;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>之后我们若转到 <code>/polls/34/</code>，<strong>Django</strong> 将会运行 <code>detail()</code> 方法并且展示你在 <strong>URL</strong> 里提供的问题 <strong>ID</strong>。</p><h2 id="更好的视图"><a href="#更好的视图" class="headerlink" title="更好的视图"></a>更好的视图</h2><p>每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 <strong>HttpResponse</strong> 对象，或者抛出一个异常，比如 <strong>Http404</strong> 。</p><p>你的视图可以从数据库里读取记录，可以使用一个模板引擎（比如 <strong>Django</strong> 自带的，或者其他第三方的），可以生成一个 <strong>PDF</strong> 文件，可以输出一个 <strong>XML</strong>，创建一个 <strong>ZIP</strong> 文件，你可以做任何你想做的事，使用任何你想用的 <strong>Python</strong> 库。</p><p>让我们在在 <code>index()</code> 函数里插入一些新内容，让它能展示数据库里以发布日期排序的最近 5 个投票问题，以空格分割：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">&quot;-pub_date&quot;</span>)[:<span class="number">5</span>]</span><br><span class="line">    output = <span class="string">&quot;, &quot;</span>.join([q.question_text <span class="keyword">for</span> q <span class="keyword">in</span> latest_question_list])</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Leave the rest of the views (detail, results, vote) unchanged</span></span><br></pre></td></tr></table></figure><p>这里有个问题：页面的设计写死在视图函数的代码里的。如果你想改变页面的样子，就需要编辑 <strong>Python</strong> 代码。所以让我们使用 <strong>Django</strong> 的模板系统，只要创建一个视图，就可以将页面的设计从代码中分离出来。</p><p>首先，在你的 <strong>polls</strong> 目录里创建一个 <strong>templates</strong> 目录。<strong>Django</strong> 将会在这个目录里查找模板文件。项目的 <strong>TEMPLATES</strong> 配置项描述了 <strong>Django</strong> 如何载入和渲染模板。默认的设置文件设置了 <strong>DjangoTemplates</strong> 后端，并将 <code>APP_DIRS</code> 设置成了 <code>True</code>。这一选项将会让 <strong>DjangoTemplates</strong> 在每个 <code>INSTALLED_APPS</code> 文件夹中寻找 “<strong>templates</strong>“ 子目录。这就是为什么尽管我们没有像在第二部分中那样修改 <strong>DIRS</strong> 设置，<strong>Django</strong> 也能正确找到 <strong>polls</strong> 的模板位置的原因。</p><p>在刚刚创建的 <strong>templates</strong> 目录里，再创建一个目录 <strong>polls</strong>，然后在其中新建一个文件 <code>index.html</code>。</p><p>将以下代码输入到模版文件中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for question in latest_question_list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/polls/&#123;&#123; question.id &#125;&#125;/&quot;</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>No polls are available.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>然后，让我们更新一下 <code>polls/views.py</code> 里的 <strong>index</strong> 视图来使用模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">&quot;-pub_date&quot;</span>)[:<span class="number">5</span>]</span><br><span class="line">    template = loader.get_template(<span class="string">&quot;polls/index.html&quot;</span>)</span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&quot;latest_question_list&quot;</span>: latest_question_list,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(template.render(context, request))</span><br></pre></td></tr></table></figure><p>上述代码的作用是，载入 <code>polls/index.html</code> 模板文件，并且向它传递一个上下文(<strong>context</strong>)。这个上下文是一个字典，它将模板内的变量映射为 <strong>Python</strong> 对象。</p><h3 id="render-函数"><a href="#render-函数" class="headerlink" title="render() 函数"></a>render() 函数</h3><p>「载入模板，填充上下文，再返回由它生成的 <strong>HttpResponse</strong> 对象」是一个非常常用的操作流程。于是 <strong>Django</strong> 提供了一个快捷函数，我们用它来重写 <code>index()</code> 视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">&quot;-pub_date&quot;</span>)[:<span class="number">5</span>]</span><br><span class="line">    context = &#123;<span class="string">&quot;latest_question_list&quot;</span>: latest_question_list&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;polls/index.html&quot;</span>, context)</span><br></pre></td></tr></table></figure><h3 id="抛出-404-错误"><a href="#抛出-404-错误" class="headerlink" title="抛出 404 错误"></a>抛出 404 错误</h3><p>现在，来处理投票详情视图——它会显示指定投票的问题标题。下面是这个视图的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detail</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        question = Question.objects.get(pk=question_id)</span><br><span class="line">    <span class="keyword">except</span> Question.DoesNotExist:</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">&quot;Question does not exist&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;polls/detail.html&quot;</span>, &#123;<span class="string">&quot;question&quot;</span>: question&#125;)</span><br></pre></td></tr></table></figure><p>现在，如果指定问题 <strong>ID</strong> 所对应的问题不存在，这个视图就会抛出一个 <strong>Http404</strong> 异常。</p><h3 id="get-object-or-404-函数"><a href="#get-object-or-404-函数" class="headerlink" title="get_object_or_404() 函数"></a>get_object_or_404() 函数</h3><p>尝试用 <code>get()</code> 函数获取一个对象，如果不存在就抛出 <strong>Http404</strong> 错误也是一个普遍的流程。<strong>Django</strong> 也提供了一个快捷函数，下面是修改后的详情 <code>detail()</code> 视图代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detail</span>(<span class="params">request, question_id</span>):</span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;polls/detail.html&quot;</span>, &#123;<span class="string">&quot;question&quot;</span>: question&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Django </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django 学习笔记_0</title>
      <link href="/2023/07/13/Django-0/"/>
      <url>/2023/07/13/Django-0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Django</strong> 是一个开源的 <strong>Python Web</strong> 应用程序框架，它遵循了模型-视图-控制器（<strong>MVC</strong>）架构模式。它使得开发人员可以更快速、更高效地构建复杂的 <strong>Web</strong> 应用程序，并提供了许多内置的功能和工具来简化开发过程。</p><h2 id="搭建框架"><a href="#搭建框架" class="headerlink" title="搭建框架"></a>搭建框架</h2><p>首先是 <code>pip install django</code> 把 <strong>Django</strong> 安装下来。安装之后使用指令 <code>python -m django --version</code> 查看版本。</p><p>使用指令 <code>django-admin startproject mysite</code> 来初始化 <strong>Django</strong> 配置。<strong>mysite</strong> 可为任意名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysite/</span><br><span class="line">    manage.py</span><br><span class="line">    mysite/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        asgi.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure><p>这些文件的作用：</p><ul><li>最外层的 <code>mysite/</code> 根目录只是你项目的容器， 根目录名称对 <strong>Django</strong> 没有影响，你可以将它重命名为任何你喜欢的名称。</li><li><code>manage.py</code>: 一个让你用各种方式管理 <strong>Django</strong> 项目的命令行工具。你可以阅读 <code>django-admin</code> 和 <code>manage.py</code> 获取所有 <code>manage.py</code> 的细节。</li><li>里面一层的 <code>mysite/</code> 目录包含你的项目，它是一个纯 <strong>Python</strong> 包。它的名字就是当你引用它内部任何东西时需要用到的 <strong>Python</strong> 包名。 (比如 <code>mysite.urls</code>).</li><li><code>mysite/__init__.py</code>：一个空文件，告诉 <strong>Python</strong> 这个目录应该被认为是一个 <strong>Python</strong> 包。</li><li><code>mysite/settings.py</code>：<strong>Django</strong> 项目的配置文件。</li><li><code>mysite/urls.py</code>：<strong>Django</strong> 项目的 <strong>URL</strong> 声明，就像你网站的“目录”。</li><li><code>mysite/asgi.py</code>：作为你的项目的运行在 <strong>ASGI</strong> 兼容的 <strong>Web</strong> 服务器上的入口。</li><li><code>mysite/wsgi.py</code>：作为你的项目的运行在 <strong>WSGI</strong> 兼容的 <strong>Web</strong> 服务器上的入口。</li></ul><p>切换到 <code>mysite/</code> 目录下，运行指令 <code>python manage.py runserver</code>，应当可以看到如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Performing system checks...</span><br><span class="line"></span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line"></span><br><span class="line">You have unapplied migrations; your app may not work properly until they are applied.</span><br><span class="line">Run &#x27;python manage.py migrate&#x27; to apply them.</span><br><span class="line"></span><br><span class="line">七月 13, 2023 - 15:50:53</span><br><span class="line">Django version 4.2, using settings &#x27;mysite.settings&#x27;</span><br><span class="line">Starting development server at http://127.0.0.1:8000/</span><br><span class="line">Quit the server with CONTROL-C.</span><br></pre></td></tr></table></figure><p>通过浏览器访问 <code>http://127.0.0.1:8000/</code> 。应当看到一个“祝贺”页面，有一只火箭正在发射。那么我们已经成功搭建起框架了！</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在 <strong>Django</strong> 中，每一个应用都是一个 <strong>python</strong> 包。<strong>Django</strong> 可以帮助我们生成应用的基础目录。在项目的根目录下运行指令 <code>python manage.py startapp polls</code>，应当会创建一个目录 <code>polls</code>，文件结构应当如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">polls/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations/</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure><p>打开 <code>polls/views.py</code>，输入以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;Hello, world.&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是 <strong>Django</strong> 中最简单的视图。我们需要让一个 <strong>URL</strong> 映射到它。</p><p>在 <code>polls/urls.py</code> 中输入以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;&quot;</span>, views.index, name=<span class="string">&quot;index&quot;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后在根 <code>URLconf</code> 文件中指定我们创建的模块。在 <code>mysite/urls.py</code> 文件中的 <code>urlpatterns</code> 列表里插入一个 <code>include()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;polls/&quot;</span>, include(<span class="string">&quot;polls.urls&quot;</span>)),</span><br><span class="line">    path(<span class="string">&quot;admin/&quot;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过以下命令验证是否工作：<code>python manage.py runserver</code>。通过浏览器访问 <code>http://localhost:8000/polls/</code>，应当能看到 <em>Hello, world.</em></p><h2 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h2><p><code>mysite/settings.py</code> 中包含了 <strong>Django</strong> 的设置的 <strong>python</strong> 模块。这个配置文件使用 <strong>SQLite</strong> 作为默认数据库。</p><p>在此文件的 <code>INSTALLED_APPS</code> 中包含了以下默认应用：</p><ul><li><code>django.contrib.admin</code>：管理员站点。</li><li><code>django.contrib.auth</code>：认证授权系统。</li><li><code>django.contrib.contenttypes</code>：内容类型框架。</li><li><code>django.contrib.sessions</code>：会话框架。</li><li><code>django.contrib.messages</code>：消息框架。</li><li><code>django.contrib.staticfiles</code>：管理静态文件的框架。</li></ul><p>这些应用被默认启用是为了给常规项目提供方便。</p><p>默认开启的某些应用需要至少一个数据表，所以，在使用他们之前需要在数据库中创建一些表。请执行以下命令：<code>python manage.py migrate</code></p><p>这个命令查看 <code>INSTALLED_APPS</code> 配置，并根据 <code>mysite/settings.py</code> 文件中的数据库配置和随应用提供的数据库迁移文件，创建任何必要的数据库表。</p><h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><p>在 <strong>Django</strong> 里写一个数据库驱动的 <strong>Web</strong> 应用的第一步是定义模型 —— 也就是数据库结构设计和附加的其它元数据。</p><p>一个模型就是单个定义你的数据的信息源。模型中包含了不可缺少的数据区域和你存储数据的行为。<strong>Django</strong> 的迁移代码是由你的模型文件自动生成的，它本质上是个历史记录，<strong>Django</strong> 可以用它来进行数据库的滚动更新，通过这种方式使其能够和当前的模型匹配。</p><p>我们尝试做一个投票 <strong>app</strong>。那么我们需要在应用中创建两个模型：问题 <strong>Question</strong> 和选项 <strong>Choice</strong>。<strong>Question</strong> 模型包括问题描述和发布时间。<strong>Choice</strong> 模型有两个字段，选项描述和当前得票数。每个选项属于一个问题。</p><p>按下面的例子编辑 <code>polls/models.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line">    question_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    pub_date = models.DateTimeField(<span class="string">&quot;date published&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Choice</span>(models.Model):</span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    votes = models.IntegerField(default=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>每个模型被表示为 <code>django.db.models.Model</code> 类的子类。每个模型有许多类变量，它们都表示模型里的一个数据库字段。</p><p>每个字段都是 <code>Field</code> 类的实例 - 比如，字符字段被表示为 <code>CharField</code> ，日期时间字段被表示为 <code>DateTimeField</code> 。这将告诉 <strong>Django</strong> 每个字段要处理的数据类型。</p><p>定义某些 <code>Field</code> 类实例需要参数。例如 <code>CharField</code> 需要一个 <code>max_length</code> 参数。</p><p>在最后，使用 <code>ForeignKey</code> 定义了一个关系。这将告诉 <strong>Django</strong>，每个 <code>Choice</code> 对象都关联到一个 <code>Question</code> 对象。<strong>Django</strong> 支持所有常用的数据库关系：多对一、多对多和一对一。</p><h2 id="激活模型"><a href="#激活模型" class="headerlink" title="激活模型"></a>激活模型</h2><p>为了在工程中包含这个应用，我们应当修改 <code>INSTALLED_APPS</code> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&quot;polls.apps.PollsConfig&quot;</span>,</span><br><span class="line">    <span class="string">&quot;django.contrib.admin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;django.contrib.auth&quot;</span>,</span><br><span class="line">    <span class="string">&quot;django.contrib.contenttypes&quot;</span>,</span><br><span class="line">    <span class="string">&quot;django.contrib.sessions&quot;</span>,</span><br><span class="line">    <span class="string">&quot;django.contrib.messages&quot;</span>,</span><br><span class="line">    <span class="string">&quot;django.contrib.staticfiles&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接着运行以下命令：<code>python manage.py makemigrations polls</code>。通过 <code>makemigrations</code>，<strong>Django</strong> 会检测你对模型文件的修改，并且把修改的部分储存为一次迁移。</p><p><code>sqlmigrate</code> 命令接受一个迁移的名称，并且返回对应的 <strong>SQL</strong>：<code>python manage.py sqlmigrate polls 0001</code>。该命令没有真正在你的数据库中的执行迁移。相反，它只是把命令输出到屏幕上，让你看看 <strong>Django</strong> 认为需要执行哪些 <strong>SQL</strong> 语句。</p><p>现在，再次运行 <code>migrate</code> 命令，在数据库里创建新定义的模型的数据表：<code>python manage.py migrate</code>。</p><p>这个 <code>migrate</code> 命令选中所有还没有执行过的迁移并应用在数据库上。也就是将你对模型的更改同步到数据库结构上。</p><p>由此，改变模型只需要三步：</p><ul><li>编辑 <code>models.py</code> 文件，改变模型。</li><li>运行 <code>python manage.py makemigrations</code> 为模型的改变生成迁移文件。</li><li>运行 <code>python manage.py migrate</code> 来应用数据库迁移。</li></ul><h2 id="初识-API"><a href="#初识-API" class="headerlink" title="初识 API"></a>初识 API</h2><p>让我们进入交互式 <strong>python</strong> 命令行。通过以下命令打开 <strong>python</strong> 命令行：<code>python manage.py shell</code>。不直接使用 <strong>python</strong> 打开命令行是因为 <code>manage.py</code> 会设置环境变量 <strong>DJANGO_SETTINGS_MODULE</strong>，从而让 <strong>Django</strong> 根据 <code>mysite/settings.py</code> 文件来设置 <strong>python</strong> 包的导入路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from polls.models import Choice, Question  <span class="comment"># Import the model classes we just wrote.</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">No questions are <span class="keyword">in</span> the system yet.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Question.objects.all()</span></span><br><span class="line">&lt;QuerySet []&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Create a new Question.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Support <span class="keyword">for</span> time zones is enabled <span class="keyword">in</span> the default settings file, so</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Django expects a datetime with tzinfo <span class="keyword">for</span> pub_date. Use timezone.now()</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">instead of datetime.datetime.now() and it will <span class="keyword">do</span> the right thing.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from django.utils import timezone</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q = Question(question_text=<span class="string">&quot;What&#x27;s new?&quot;</span>, pub_date=timezone.now())</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Save the object into the database. You have to call save() explicitly.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.save()</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Now it has an ID.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.id</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Access model field values via Python attributes.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.question_text</span></span><br><span class="line">&quot;What&#x27;s new?&quot;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.pub_date</span></span><br><span class="line">datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=datetime.timezone.utc)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Change values by changing the attributes, <span class="keyword">then</span> calling save().</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.question_text = <span class="string">&quot;What&#x27;s up?&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.save()</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">objects.all() displays all the questions <span class="keyword">in</span> the database.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Question.objects.all()</span></span><br><span class="line">&lt;QuerySet [&lt;Question: Question object (1)&gt;]&gt;</span><br></pre></td></tr></table></figure><p>让我们为 <strong>Question</strong> 和 <strong>Choice</strong> 添加 <code>__str__()</code> 方法，为 <strong>Question</strong> 添加一个自定义方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.question_text</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">was_published_recently</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.pub_date &gt;= timezone.now() - datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Choice</span>(models.Model):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.choice_text</span><br></pre></td></tr></table></figure><p>添加 <code>__str__()</code> 方法是很重要的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from polls.models import Choice, Question</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Make sure our __str__() addition worked.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Question.objects.all()</span></span><br><span class="line">&lt;QuerySet [&lt;Question: What&#x27;s up?&gt;]&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Django provides a rich database lookup API that<span class="string">&#x27;s entirely driven by</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">keyword arguments.</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; Question.objects.filter(id=1)</span></span></span><br><span class="line">&lt;QuerySet [&lt;Question: What&#x27;s up?&gt;]&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; Question.objects.filter(question_text__startswith=&quot;What&quot;)</span></span></span><br><span class="line">&lt;QuerySet [&lt;Question: What&#x27;s up?&gt;]&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Get the question that was published this year.</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; from django.utils import timezone</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; current_year = timezone.now().year</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; Question.objects.get(pub_date__year=current_year)</span></span></span><br><span class="line">&lt;Question: What&#x27;s up?&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Request an ID that doesn&#x27;</span>t exist, this will raise an exception.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Question.objects.get(<span class="built_in">id</span>=2)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">DoesNotExist: Question matching query does not exist.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Lookup by a primary key is the most common <span class="keyword">case</span>, so Django provides a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">shortcut <span class="keyword">for</span> primary-key exact lookups.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The following is identical to Question.objects.get(<span class="built_in">id</span>=1).</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Question.objects.get(pk=1)</span></span><br><span class="line">&lt;Question: What&#x27;s up?&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Make sure our custom method worked.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q = Question.objects.get(pk=1)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.was_published_recently()</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Give the Question a couple of Choices. The create call constructs a new</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Choice object, does the INSERT statement, adds the choice to the <span class="built_in">set</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">of available choices and returns the new Choice object. Django creates</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a <span class="built_in">set</span> to hold the <span class="string">&quot;other side&quot;</span> of a ForeignKey relation</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(e.g. a question<span class="string">&#x27;s choice) which can be accessed via the API.</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; q = Question.objects.get(pk=1)</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Display any choices from the related object set -- none so far.</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; q.choice_set.all()</span></span></span><br><span class="line">&lt;QuerySet []&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Create three choices.</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; q.choice_set.create(choice_text=&quot;Not much&quot;, votes=0)</span></span></span><br><span class="line">&lt;Choice: Not much&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; q.choice_set.create(choice_text=&quot;The sky&quot;, votes=0)</span></span></span><br><span class="line">&lt;Choice: The sky&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; c = q.choice_set.create(choice_text=&quot;Just hacking again&quot;, votes=0)</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Choice objects have API access to their related Question objects.</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; c.question</span></span></span><br><span class="line">&lt;Question: What&#x27;s up?&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">And vice versa: Question objects get access to Choice objects.</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; q.choice_set.all()</span></span></span><br><span class="line">&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; q.choice_set.count()</span></span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The API automatically follows relationships as far as you need.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Use double underscores to separate relationships.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This works as many levels deep as you want; there&#x27;</span>s no <span class="built_in">limit</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all Choices <span class="keyword">for</span> any question whose pub_date is <span class="keyword">in</span> this year</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(reusing the <span class="string">&#x27;current_year&#x27;</span> variable we created above).</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Choice.objects.filter(question__pub_date__year=current_year)</span></span><br><span class="line">&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Let<span class="string">&#x27;s delete one of the choices. Use delete() for that.</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; c = q.choice_set.filter(choice_text__startswith=&quot;Just hacking&quot;)</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="string">&gt;&gt; c.delete()</span></span></span><br></pre></td></tr></table></figure><h2 id="Django-管理页面"><a href="#Django-管理页面" class="headerlink" title="Django 管理页面"></a>Django 管理页面</h2><h3 id="创建管理员账号"><a href="#创建管理员账号" class="headerlink" title="创建管理员账号"></a>创建管理员账号</h3><p>首先，我们得创建一个能登录管理页面的用户。请运行下面的命令：<code>python manage.py createsuperuser</code></p><p>键入用户名，然后回车。</p><p><code>Username: admin</code></p><p>按照提示键入邮箱地址和密码。</p><h3 id="启动开发服务器"><a href="#启动开发服务器" class="headerlink" title="启动开发服务器"></a>启动开发服务器</h3><p><strong>Django</strong> 的管理界面默认就是启用的。让我们启动开发服务器，看看它到底是什么样的。</p><p>如果开发服务器未启动，用以下命令启动它：<code>python manage.py runserver</code></p><p>打开地址 <code>http://127.0.0.1:8000/admin/</code>。输入账户和密码，登入管理员站点页面。</p><h3 id="向管理员站点中添加投票应用"><a href="#向管理员站点中添加投票应用" class="headerlink" title="向管理员站点中添加投票应用"></a>向管理员站点中添加投票应用</h3><p>在 <code>polls/admin.py</code> 中编辑如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line">admin.site.register(Question)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Django </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shader 学习笔记</title>
      <link href="/2023/07/12/shader/"/>
      <url>/2023/07/12/shader/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Shader"><a href="#什么是-Shader" class="headerlink" title="什么是 Shader"></a>什么是 Shader</h2><p><strong>Shader</strong> 是一种在计算机图形学中使用的，运行在显卡上的程序，用于控制图形渲染的过程，负责计算画布上每个像素的颜色。通过接受输入进行工作，使用 <strong>GLSL</strong> 等进行着色。</p><p>它们可以被用于创建各种视觉效果，包括光照、纹理映射、阴影和其他图形效果。</p><p>编程人员可以只使用代码进行 2D 和 3D 渲染。<strong>Shader</strong> 艺术编码使用数学函数和算法来操纵函数，创造出瞠目的视觉效果。创造力是唯一的桎梏。</p><p>网站导航：<a href="https://www.shadertoy.com/">shadertoy</a></p><h2 id="基础的-shader-编程"><a href="#基础的-shader-编程" class="headerlink" title="基础的 shader 编程"></a>基础的 shader 编程</h2><p>每个 <strong>shader</strong> 都在 <strong>mainImage</strong> 函数中定义（主函数）。<strong>mainImage</strong> 有两个参数：<code>out vec4 fragColor</code> 和 <code>in vec2 fragCoord</code>，分别代表颜色和位置。</p><p><code>fragColor</code> 是一个拥有四个向量的输出参数，四个参数分别代表三个颜色维度上的值，以及一个不透明度。</p><p><code>fragCoord</code> 是一个拥有两个向量的输入参数，两个参数分别代表横纵坐标。</p><p><code>fragCoord</code> 参数的范围取决于分辨率大小。比如，若在 <code>1600 x 900</code> 的画布上进行编程，则其横纵坐标的取值范围分别是 1600 和 900。可以通过等比缩放操作来免除这一点，使他们不依赖于当前画布分辨率。</p><p>对向量的运算，比如一个 <code>vec2</code> 类型的 <code>uv</code> 变量，可以使用 <code>uv / 2.0</code> 这样的操作来对 <code>uv</code> 的两个向量都执行除 2 操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void mainImage( out vec4 fragColor, in vec2 fragCoord )</span><br><span class="line">&#123;   // iResolution 是一个全局常量，由三个分量组成的矢量，分别代表宽度、高度和深度（深度仅在渲染 3D 纹理时使用）</span><br><span class="line">    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;   // 使坐标原点位于画布中心</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;              // 避免图像拉伸</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些实用函数：</p><ul><li><strong>length</strong>：计算向量的长度。</li><li><strong>step</strong>：阶跃函数。接受两个参数，一个阈值和一个值。当值小于阈值时，返回 0，否则返回 1。</li><li><strong>smoothstep</strong>：平滑阶跃函数。和 <strong>step</strong> 不同的是它接受两个阈值。当值小于第一个阈值时，返回 0，当值大于第二个阈值时，返回 1。当值处于两个阈值之间时，平滑的返回 0 到 1 之间的值。</li></ul><p>小孩子不懂事，随便学着玩的…</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab3总结</title>
      <link href="/2023/06/15/OS-lab3/"/>
      <url>/2023/06/15/OS-lab3/</url>
      
        <content type="html"><![CDATA[<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>进程控制块 <strong>PCB</strong> 是一个很重要的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/trap.h 文件内容 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span> <span class="comment">// 陷阱帧，用于在陷入内核时保存进程上下文。</span></span><br><span class="line"><span class="comment">/* 保存32个寄存器 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> regs[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存特殊寄存器 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cp0_status;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> hi;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> lo;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cp0_badvaddr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cp0_cause;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cp0_epc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* include/env.h 文件内容 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// env_status 的三种取值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_FREE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_RUNNABLE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_NOT_RUNNABLE 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>  <span class="comment">// 用于保存上下文</span></span><br><span class="line">LIST_ENTRY(Env) env_link; <span class="comment">// 构建空闲进程链表</span></span><br><span class="line">u_int env_id;  <span class="comment">// 独特的进程id</span></span><br><span class="line">u_int env_asid;  <span class="comment">// 进程的asid，填入TLB表项中</span></span><br><span class="line">u_int env_parent_id;  <span class="comment">// 进程的父进程id</span></span><br><span class="line">u_int env_status;  <span class="comment">// 进程的运行状态</span></span><br><span class="line">Pde *env_pgdir;  <span class="comment">// 进程的页目录内核虚拟地址</span></span><br><span class="line">TAILQ_ENTRY(Env) env_sched_link; <span class="comment">// 进程的调度队列</span></span><br><span class="line">u_int env_pri;  <span class="comment">// 进程的优先级</span></span><br><span class="line"></span><br><span class="line">u_int env_ipc_value;   <span class="comment">// data value sent to us</span></span><br><span class="line">u_int env_ipc_from;    <span class="comment">// envid of the sender</span></span><br><span class="line">u_int env_ipc_recving; <span class="comment">// env is blocked receiving</span></span><br><span class="line">u_int env_ipc_dstva;   <span class="comment">// va at which to map received page</span></span><br><span class="line">u_int env_ipc_perm;    <span class="comment">// perm of page mapping received</span></span><br><span class="line"></span><br><span class="line">u_int env_user_tlb_mod_entry; <span class="comment">// user tlb mod handler</span></span><br><span class="line"></span><br><span class="line">u_int env_runs; <span class="comment">// number of times been env_run&#x27;ed</span></span><br><span class="line"><span class="type">char</span> env_path[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>asid</strong> 之所以要单独拎出来而不能直接使用 <strong>envid</strong>（明明他们都是独特的），是因为我们要将 <strong>asid</strong> 塞入 <strong>TLB</strong> 表项中，这对 <strong>asid</strong> 的位长提出了限制。我们对于 <strong>asid</strong> 位长的限制是 <strong>6</strong> 位，也就是说我们最多有 <strong>64</strong> 个可供分配的 <strong>asid</strong>。我们需要为 <strong>asid</strong> 建立分配回收机制。</p><p>在实验中，存放进程控制块的物理内存在系统启动后就已经分配好，就是 <strong>envs</strong> 数组。为快速分配进程控制块，我们同样需要使用链表来管理进程块。</p><ul><li><code>env_init</code>：初始化进程块链表，并进行了段地址映射。</li><li><code>env_setup_vm</code>：初始化进程地址空间。</li><li><code>env_alloc</code>：分配一个进程块。</li><li><code>load_icode</code>：将进程二进制映像装入内存。</li><li><code>load_icode_mapper</code>：作为 <code>elf_load_seg</code> 的回调函数，为进程内容分配物理页面并建立映射。</li><li><code>env_create</code>：创建一个进程。</li><li><code>env_free</code>：释放一个进程。</li><li><code>env_destroy</code>：摧毁一个进程。</li><li><code>env_run</code>：让一个进程运行起来。</li></ul><p>真正创建进程的过程：分配一个 <strong>Env</strong> 结构体，设置进程控制块，将程序载入到该进程的地址空间。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在产生异常时，我们会进入到 <code>kern/entry.S</code> 内进行异常分发处理。</p><p>异常处理函数向量表在 <code>kern/trap.c</code> 中设置。在 <code>kern/genex.S</code> 中设置了一些异常处理函数。</p><p>推荐阅读 <code>include/asm/asm.h</code> 中的宏，有助于理解汇编代码。</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>进程调度的函数位于 <code>kern/sched.c</code> 中。课程组进行调度的逻辑比较简单，在课上上机时出的题可能是需要实现更加复杂的调度逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> 进程控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab2总结</title>
      <link href="/2023/06/14/OS-lab2/"/>
      <url>/2023/06/14/OS-lab2/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟地址到物理地址的映射"><a href="#虚拟地址到物理地址的映射" class="headerlink" title="虚拟地址到物理地址的映射"></a>虚拟地址到物理地址的映射</h2><p>软件访问的虚拟地址会先被 <strong>MMU</strong> 映射到物理地址，然后通过物理地址来访问内存或其他外设。我们在编程过程中使用到的地址均为<strong>虚拟地址</strong>。</p><ul><li>若虚拟地址位于 <strong>kseg0</strong> 段，则将虚拟地址的最高位置零得到物理地址，通过 <strong>cache</strong> 访存。</li><li>若虚拟地址位于 <strong>kseg1</strong> 段，则将虚拟地址的高三位置零得到物理地址，不通过 <strong>cache</strong> 访存。</li><li>若虚拟地址位于 <strong>kuseg</strong> 段，则需要通过 <strong>TLB</strong> 获取物理地址，通过 <strong>cache</strong> 访存。</li></ul><p>在 <strong>MMU</strong> 中通过硬件 <strong>TLB</strong> 来完成地址映射。但是我们需要通过软件来完成 <strong>TLB</strong> 重填。</p><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><p>我们使用链表管理空闲页表。<strong>C</strong> 语言中没有泛型，因此我们需要巧妙地使用宏来实现链表。链表宏的代码位于 <code>include/queue.h</code> 中。实现非常巧妙，建议仔细阅读理解。（其中对链表进行遍历的宏 <code>LIST_FOREACH, TAILQ_FOREACH</code> 在课下不会用到，但是在上机时很有可能会用到，建议理解含义）</p><h2 id="pmap-h"><a href="#pmap-h" class="headerlink" title="pmap.h"></a>pmap.h</h2><p>这个头文件中定义了许多我们可能会用到的函数。是必读的头文件。这些用于转换的函数都应该记住。阅读这些头文件也会有助于我们理解程序进行地址转换的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> Pde *cur_pgdir; <span class="comment">// 当前的页目录基地址</span></span><br><span class="line"></span><br><span class="line">LIST_HEAD(Page_list, Page); <span class="comment">// 定义一个存储 Page 的链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LIST_ENTRY</span><span class="params">(Page)</span> Page_LIST_entry_t;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">Page_LIST_entry_t pp_link; <span class="comment">/* free list link */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ref is the count of pointers (usually in page table entries)</span></span><br><span class="line"><span class="comment">// to this page.  This only holds for pages allocated using</span></span><br><span class="line"><span class="comment">// page_alloc.  Pages allocated at boot time using pmap.c&#x27;s &quot;alloc&quot;</span></span><br><span class="line"><span class="comment">// do not have valid reference count fields.</span></span><br><span class="line"></span><br><span class="line">u_short pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pages</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span> <span class="title">page_free_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2ppn</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> pp - pages;  <span class="comment">// 由页获取物理页框号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> page2ppn(pp) &lt;&lt; PGSHIFT; <span class="comment">// 由页获取物理地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> Page *<span class="title function_">pa2page</span><span class="params">(u_long pa)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (PPN(pa) &gt;= npage) &#123;</span><br><span class="line">panic(<span class="string">&quot;pa2page called with invalid pa: %x&quot;</span>, pa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;pages[PPN(pa)]; <span class="comment">// 由物理地址获取页</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2kva</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> KADDR(page2pa(pp));  <span class="comment">// 由页获取虚拟地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">va2pa</span><span class="params">(Pde *pgdir, u_long va)</span> &#123;</span><br><span class="line">Pte *p;</span><br><span class="line"></span><br><span class="line">pgdir = &amp;pgdir[PDX(va)];</span><br><span class="line"><span class="keyword">if</span> (!(*pgdir &amp; PTE_V)) &#123;</span><br><span class="line"><span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = (Pte *)KADDR(PTE_ADDR(*pgdir));</span><br><span class="line"><span class="keyword">if</span> (!(p[PTX(va)] &amp; PTE_V)) &#123;</span><br><span class="line"><span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> PTE_ADDR(p[PTX(va)]);</span><br><span class="line">&#125;   <span class="comment">// 由虚拟地址和页目录基地址获取对应的物理地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mips_detect_memory</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mips_vm_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mips_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">alloc</span><span class="params">(u_int n, u_int align, <span class="type">int</span> clear)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">page_alloc</span><span class="params">(<span class="keyword">struct</span> Page **pp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">page_decref</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">page_insert</span><span class="params">(Pde *pgdir, u_int asid, <span class="keyword">struct</span> Page *pp, u_long va, u_int perm)</span>;</span><br><span class="line"><span class="keyword">struct</span> Page *<span class="title function_">page_lookup</span><span class="params">(Pde *pgdir, u_long va, Pte **ppte)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">page_remove</span><span class="params">(Pde *pgdir, u_int asid, u_long va)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tlb_invalidate</span><span class="params">(u_int asid, u_long va)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pages</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">physical_memory_manage_check</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">page_check</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="pmap-c"><a href="#pmap-c" class="headerlink" title="pmap.c"></a>pmap.c</h2><p>本文件中的函数涉及的都是很底层的部分。</p><ul><li>void *alloc：分配一定的物理内存。仅在建立虚拟内存系统时会被使用。</li><li>void mips_vm_init：只干了一件事：为二级页表结构分配空间。</li><li>void page_init：初始化页表管理结构，将空闲页表都插入到 <code>page_free_list</code> 中。</li><li>int page_alloc：从空闲页表中取出一页并分配。</li><li>int page_free：释放一页，</li><li>int pgdir_walk：通过给出的页目录基地址，找到虚拟地址 <strong>va</strong> 对应的页表项并将其地址赋给 <strong>ppte</strong>。若不存在页表项且 <strong>create</strong> 为 <strong>1</strong> 则为其分配一个页表。</li><li>int page_insert：将虚拟地址 <strong>va</strong> 映射到 <strong>pp</strong> 对应的物理页面。</li><li>struct Page *page_lookup：寻找虚拟地址 <strong>va</strong> 映射到的页面。将二级页表项地址赋值给 <strong>ppte</strong>。返回对应的页控制块。</li><li>void page_decref：减少页面的引用。若减少后引用数为 <strong>0</strong>，则释放这一页。</li><li>void page_remove：取消 <strong>va</strong> 映射的页面。</li><li>void tlb_invalidate：使 <strong>TLB</strong> 中带有 <strong>asid</strong> 的 <strong>va</strong> 地址的表项无效。</li></ul><p>这些函数还是要自己都读一遍才能理解好。</p><h2 id="TLB无效化与重填"><a href="#TLB无效化与重填" class="headerlink" title="TLB无效化与重填"></a>TLB无效化与重填</h2><p>在本次实验中可能用到的相关指令：</p><ul><li><strong>tlbr</strong>：以 <strong>Index</strong> 寄存器中的值为索引，读出 <strong>TLB</strong> 中对应的表项到 <strong>EntryHi</strong> 与 <strong>EntryLo</strong>。</li><li><strong>tlbwi</strong>：以 <strong>Index</strong> 寄存器中的值为索引，将此时 <strong>EntryHi</strong> 与 <strong>EntryLo</strong> 的值写到索引指定的 <strong>TLB</strong> 表项中。</li><li><strong>tlbwr</strong>：将 <strong>EntryHi</strong> 与 <strong>EntryLo</strong> 的数据随机写到一个 <strong>TLB</strong> 表项中。</li><li><strong>tlbp</strong>：根据 <strong>EntryHi</strong> 中的 <strong>Key</strong>（包含 <strong>VPN</strong> 与 <strong>ASID</strong>），查找 <strong>TLB</strong> 中与之对应的表项，并将表项的索引存入 <strong>Index</strong> 寄存器（若未找到匹配项，则 <strong>Index</strong> 最高位被置 1）。</li></ul><p><strong>TLB</strong> 的无效化是通过 <code>kern/tlb_asm.S</code> 中的 <strong>tlb_out</strong> 实现的。首先通过 <strong>tlbq</strong> 指令拿出索引，然后将 <strong>CP0_ENTRYHI</strong> 和 <strong>CP0_ENTRYLO0</strong> 赋值为零，再通过 <strong>tlbwi</strong> 写回到指定的 <strong>TLB</strong> 表项中。</p><p>这个函数在 <code>kern/pmap.c</code> 中的 <code>void tlb_invalidate()</code> 被调用。</p><p><strong>TLB</strong> 的无效化由 <code>kern/tlb_asm.S</code> 中的 <strong>do_tlb_refill</strong> 完成。这个函数首先取出引发错误的虚拟地址，然后取出进程对应的 <strong>asid</strong>，然后调用  <strong>_do_tlb_refill</strong> 函数（该函数位于 <code>kern/tlbex.c</code> 中）。最后将物理地址存入 <strong>EntryLo</strong>, 并执行 <strong>tlbwr</strong> 将此时的 <strong>EntryHi</strong> 与 <strong>EntryLo</strong> 写入到 <strong>TLB</strong> 中。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程总结</title>
      <link href="/2023/06/14/OO-Summary/"/>
      <url>/2023/06/14/OO-Summary/</url>
      
        <content type="html"><![CDATA[<p>本学期的 <strong>OO</strong> 课程终于来到了尾声。在此简单地回顾一下本学期的 <strong>OO</strong> 课程，谈一谈我个人都学到了什么东西。</p><h2 id="第一单元"><a href="#第一单元" class="headerlink" title="第一单元"></a>第一单元</h2><p>表达式的解析。第一次作业上来的时候很头疼，因为既不懂递归下降又不懂 <strong>Java</strong>，体验奇差无比。但是第一次作业最后还是靠着学长和同学的帮助下熬了过去。</p><p>在理解了递归下降后，第二次作业起情况就有了明显的好转。</p><p>在第一单元的学习过程中获得了算法能力上的提升。同时第一单元也是我刀的很爽的一次。</p><h2 id="第二单元"><a href="#第二单元" class="headerlink" title="第二单元"></a>第二单元</h2><p>第二单元的难度很大。虽然本意是多线程程序设计，但是我却造了个状态机出来…一言难尽啊一言难尽。</p><p>第二单元寄的也比较惨。因为两个小 <strong>bug</strong> 而痛寄，想想真是太不值得了。</p><p>第二单元写的评测机很不错，又学到了一些 <strong>C++</strong> 小知识呢（笑。这单元我自己学习了不少 <strong>Java</strong> 的特性，也算是有所收获。</p><h2 id="第三单元"><a href="#第三单元" class="headerlink" title="第三单元"></a>第三单元</h2><p>第三单元的时候前两次作业体验尚可，第三次作业的最短环属实是有一点考验算法能力了。不过和同学讨论过之后也都顺利的通过了。体感上其实比一二单元都要好一些？</p><p>此外这单元搓数据搓的很爽，虽然到现在还有一点点没有搞懂 <strong>OKTest</strong> 的意义何在…这单元想锻炼我们的测试能力，我觉得我的测试能力应该算是及格了吧…</p><p>当初第三单元正好赶上五一放假，所以整体上时间还算比较充裕。这单元狠狠训练了一下阅读 <strong>JML</strong> 的能力和图算法的能力。<strong>Java</strong> 是世界上最好的语言。</p><h2 id="第四单元"><a href="#第四单元" class="headerlink" title="第四单元"></a>第四单元</h2><p>第四单元突出的是一个麻烦、任务量大。可能很大的原因还是指导书表述得不够清晰吧…第十三次作业还挺顺利的，第十四次作业最大的问题就是指导书表述不清。不过我开工的时候指导书都已经修过了，所以我个人的体感其实也还行。第十四次作业基本上一晚上加一上午就写完了。第十三次作业到第十四次作业的迭代也很顺滑。第十五次作业很简单，改动几行就可以了。</p><p>第四单元强调的是架构设计。我对我自己的架构设计基本还是挺满意的。到第十五次作业的时候突然有一种 “啊，<strong>OO</strong> 课要结束了啊” 的感觉。一学期的努力终究是迎来了尽头。</p><h2 id="学习感悟"><a href="#学习感悟" class="headerlink" title="学习感悟"></a>学习感悟</h2><p>以下一些没有什么逻辑的想到哪写到哪的学习感悟（逃</p><p>感觉确实学习到了很多面向对象的知识。</p><p>在面向对象课程中我体悟最大的，是面向对象的<strong>封装性</strong>。常言道“要以最大的恶意揣度用户”，我们作为开发者，在代码的编写中一定要注意面向对象的<strong>封装性</strong>，只暴露必要的接口，具体的实现细节都应该是对用户透明的。不过在课程内容中好像并没有十分的强调这一点？我个人感觉可以在这方面多多训练。训练封装性其实也是对架构设计能力的训练。我发现很多同学在编写代码时都有一个很不好的习惯，就是将所有方法都设置为 <strong>public</strong>，我认为这是违背了面向对象的封装性的。</p><p>此外学习到了一些设计模式，如工厂模式、生产者消费者模式等等。我认为在三四单元中其实也可以去介绍更多的设计模式。设计模式的学习带来的是思维的提升，比单纯码代码搓大模拟，可能更加贴合面向对象的初衷。（吐槽一下，大模拟什么的也太奇怪了，感觉就像在大一写程序设计一样，大模拟用 <strong>Java</strong> 写也是写，用 <strong>C</strong> 写也是写，感觉没有体现出面向对象的优势，只是在强调架构的设计倒不如通过学习设计模式锻炼架构）</p><p>第三单元的 <strong>JML</strong> 感觉其实是一个比较好的尝试，优缺点都有。我认为本单元比较考验助教的能力，<strong>JML</strong> 的编写实在是太不容易了。但是如果编写的好，一个优秀的架构 + 优秀的 <strong>JML</strong>，绝对是能够让同学们受益匪浅的。一个不太成熟的想法是在第三单元中设计出相对复杂的架构，通过 <strong>JML</strong> 向同学们传达代码的信息，从而让同学们在编写代码的过程中体会到架构的好处。本学期的第三单元感觉在架构上还是稍微有一些欠缺的？（好吧写到这里突然有一点当第三单元助教的心思了，可惜写到这里的时候已经截止报名了）</p><p>第四单元…今年的改革可以说是一次大胆的尝试，不过可能助教们稍微低估了大模拟的难度。</p><p>哦，除了封装性，我本学期还学到的很好的一个思想是“不要过早优化”。过早的优化是万恶之源。我很赞同的一句话是“让很快的代码正确，比让正确的代码更快困难得多”。写代码，第一要务是正确性，追求性能和速度要在正确性之后。第一次作业的时候就有一点因为想过早优化导致写的很痛苦。</p><p>这学期也训练了一下代码风格。虽然我自认为自己的代码风格已经不错了，不过在课程组的训练下还是又获得了一些长进。</p><p>此外，学习到的一个思想是“少写注释”。这句话的意思是应当让自己的代码变得像注释一样通俗易懂（通过合理的命名和组织结构等）。</p><p>在本学期的课程中训练了编写具有一定规模代码的能力。一周憋一千行什么的以前是不敢想，现在感觉也就轻轻松吧。</p><p>其实感觉这学期的面向对象是基于 <strong>Java</strong> 学习的，但是却对 <strong>Java</strong> 没有什么专门的学习。我觉得 <strong>Java</strong> 作为典型的面向对象语言，其实可以多学习一些 <strong>Java</strong> 的特性。虽然这可能与面向对象的关系不太大，但是我认为学习语言的特性也是学习编程过程中很重要的一环。根据我的观察，同学们编写代码中遇到的很多困难、写的很多代码有问题都是因为不了解 <strong>Java</strong> 的特性导致的。</p><p>然后我觉得第四单元的输出实在是太多太繁杂了…麻烦到我感觉没有什么意义。如果以后能改进一下就好了。（直接 <strong>push</strong> 身边当助教的同学（雾</p><p>很可惜由于个人学业安排没有冲 <strong>OO</strong> 助教。现在想想又有点后悔了呜呜…</p><p>从一开始的不知道该怎么测试，到后来能够和同学一起写评测机，自己能够思考如何搓数据、写数据生成，感觉自己的测试能力有了很大的长进。</p><p>再看看自己架构设计的能力，感觉从一开始是无所适从，到现在能设计出让自己满意的架构，我认为我的收获是蛮大的。要将设计模式融入自己的架构设计，通过学习、理解前人的思想，让自己的代码更加优美好看。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 Unit4</title>
      <link href="/2023/06/13/OO-unit4/"/>
      <url>/2023/06/13/OO-unit4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>终于来到了 <strong>OO</strong> 的最后一单元，让我看看我们今年的最后一单元都要做什么？喔，我们要进行一个图书馆的大模拟！</p><p>本单元主要希望训练的是我们的抽象建模技巧。</p><p>第十三次作业时建立起扩展性良好的架构会让我们在完成第十四次作业时更加轻松。</p><p>虽然在中途出现了各种各样的意外……不过由于我第十四次作业开工的比较晚、并且十三次作业的架构也比较好，所以并没有感到十分的痛苦（x</p><h2 id="两次作业类图"><a href="#两次作业类图" class="headerlink" title="两次作业类图"></a>两次作业类图</h2><p><strong>hw13</strong> 类图：</p><p><img src="https://pic.imgdb.cn/item/648883e71ddac507cce1b347.jpg" alt=""></p><p><strong>hw14</strong> 类图：</p><p><img src="https://pic.imgdb.cn/item/6488837f1ddac507cce04eaf.jpg" alt=""></p><p>可以看到在两次作业中没有大幅度重构。</p><p>第十五次作业中基本没有改变什么内容，类图基本和第十四次作业一致。</p><h2 id="本单元架构设计"><a href="#本单元架构设计" class="headerlink" title="本单元架构设计"></a>本单元架构设计</h2><p>在本单元的架构设计时，我将每一个管理员都抽象为一个单独的类，让他们都继承自 <strong>BookContainer</strong> 类。<strong>BookContainer</strong> 类承载了管理书籍的功能，可以添加、删除、获取书籍。将每一个管理员都作为一个类的考虑在于这样便于以后为特定的管理员添加新的功能。不过到最后貌似是都没有添加新的功能…</p><p>在本单元作业中课程组鼓励我们使用先建模，后工程的方法，我认为这一思想是正确的，不过在实操层面是有很大困难。一大原因在于对于 <strong>starUML</strong> 图的评测比较严苛，需要让代码和图内容完全一致还是比较困难的（指先画图）。我个人在本单元中的做法是在草纸上画出大致的图，然后再进行代码编写，最后根据代码手绘 <strong>UML</strong> 图。</p><p>第十四次作业整体架构：</p><h3 id="BookContainer"><a href="#BookContainer" class="headerlink" title="BookContainer"></a>BookContainer</h3><p>承载了管理图书的功能。各个图书管理员都继承自此类从而拥有了管理图书的功能。</p><h3 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h3><p>承载了图书馆的功能，是处理读者借还书籍的地方。</p><h3 id="City"><a href="#City" class="headerlink" title="City"></a>City</h3><p>承载了解析指令、让多个图书馆之间进行通信的功能。</p><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>将每次的输入解析为对应的消息。在类之间通过传递消息传递信息。</p><h3 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h3><p>手写的二元组。</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>承载了日期的解析功能，可以将日期转换为日期码。</p><h3 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h3><p>承载了书籍的功能，维护了书籍的类别、编号、状态、借阅日期等信息。</p><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>承载了借阅者的功能，可以维护借阅者的借阅书籍。现在想想发现他也可以继承自 <strong>BookContainer</strong> 类。</p><h3 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h3><p>内部有一个输出方法，所有的输出都调用了这个类的方法。</p><h2 id="本单元总结"><a href="#本单元总结" class="headerlink" title="本单元总结"></a>本单元总结</h2><p>本单元作业锻炼了我的代码设计能力和大规模模拟的编写能力，同时也让我真正掌握了 <strong>UML</strong> 的使用方法。让我明白了代码设计和代码编写是不可分割的。（不过感觉其实更重要的或许是代码文档？）</p><p>本单元有一件有趣的事是我在写一个函数时写了一百行，但是上限是六十行。于是通过邪法压行把一百行生生压到了六十行…</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab0总结</title>
      <link href="/2023/06/12/OS-lab0/"/>
      <url>/2023/06/12/OS-lab0/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-存活指南"><a href="#Linux-存活指南" class="headerlink" title="Linux 存活指南"></a>Linux 存活指南</h2><p>若想使用课程组的 <strong>web</strong> 终端进行工作，则必须学会一些基础的 <strong>linux</strong> 命令行指令。</p><p>很多同学（包括我）在此之前都没怎么接触过命令行。稍稍总结了一下能帮助我们在命令行中活下去的指令：</p><ul><li><strong>cd</strong>：进入工作目录。</li><li><strong>grep</strong>：在文件中查找字符串。我通常的使用方法是 <code>grep -r &quot;要寻找的内容&quot; .</code>，会递归地查找当前目录下所有文件。</li><li><strong>find</strong>：在指定目录下查找文件和目录。我通常的使用方法是 <code>find -name 要寻找的名字</code>。</li><li><strong>mkdir</strong>：创建文件夹。</li><li><strong>touch</strong>：更新文件时间戳。不过一般地用法是使用此指令来创建文件。</li><li><strong>rm</strong>：删除文件。删除目录时要加上 <code>-r</code> 参数。</li><li><strong>ls</strong>：列出当前目录下所有文件。</li><li><strong>cp</strong>：复制文件。</li><li><strong>mv</strong>：移动文件。</li></ul><p>以上应当是最常用的几条指令了。记住这几条指令可以初步拥有在命令行中工作的能力。</p><p>每条指令都可以附带额外的参数来实现相应的功能。若想查看一条指令的详细使用方法，可以输入 <code>man 指令</code> 或 <code>指令 --help</code>。</p><p>此外使用 <strong>TAB</strong> 键可以快速补全指令（文件名），当可以补全的选项不唯一时，快速双击 <strong>TAB</strong> 可以查看候补的补全项。</p><p>使用上下键可以快速切换历史指令。</p><p>注意，在命令行中使用鼠标拖动选择文本时会自动复制文本。</p><p>在命令行中一些 <code>ctrl + ...</code> 的行为有特殊的含义：</p><ul><li><code>ctrl + C</code>：终止当前程序。跑出很恐怖的循环时直接毙掉就行了。</li><li><code>ctrl + Z</code>：挂起当前程序。一开始会习惯性按撤回按出 <code>ctrl + Z</code> 挂起当前程序。在挂起时会提供挂起编号。在误挂时使用 <code>fg n</code> 即可恢复程序（<code>n</code> 即为挂起编号）。</li><li><code>ctrl + D</code>：终止输入。可以简单地理解为 <code>EOF</code>。</li><li><code>ctrl + L</code>：清屏。这个真的很好用！</li></ul><h2 id="vim-存活指南"><a href="#vim-存活指南" class="headerlink" title="vim 存活指南"></a>vim 存活指南</h2><p>常用的编辑器是 <strong>vim</strong>。一开始用着很不习惯，但是在逐渐适应了之后编辑效率直线上升。</p><p>使用 <strong>vim</strong> 打开文件： <code>vim 文件名</code> 或 <code>vi 文件名</code>。</p><p>在刚进入文件时，处于 <code>Normal</code> 模式。在 <code>Normal</code> 模式下各个按键都有其独特的涵义。</p><p>常用的控制指令：</p><ul><li><code>i</code>：进入插入模式。在插入模式下按 <code>ESC</code> 回到 <code>Normal</code> 模式。</li><li><code>a</code>：进入插入模式，不过是在光标之后进行插入。</li><li><code>x</code>：删除当前光标处的字符。</li><li><code>:wq</code>：保存并退出。（<code>:w</code> 是保存，<code>:q</code> 是退出）</li><li><code>dd</code>：删除当前行，并将删除的行保存到剪切板。</li><li><code>yy</code>：复制一行内容到剪切板。</li><li><code>p</code>：粘贴剪切板（在当前位置之后）。</li><li><code>P</code>：粘贴剪切板（在当前位置之前）。</li><li><code>G</code>：移动至最后一行。</li><li><code>gg</code>：移动至第一行。</li><li><code>hjkl</code>：移动光标，和 <code>←↓↑→</code> 一样。</li></ul><p>以上这些足够让你在 <code>vim</code> 中挣扎着活下去了。但是这远远没有发挥出 <code>vim</code> 的威力。</p><p>以下是一些进阶命令：</p><ul><li><code>o</code>：在当前行后插入一个新行。</li><li><code>O</code>：在当前行前插入一个新行。</li><li><code>0</code>：移动光标到行首。</li><li><code>^</code>：移动光标到本行第一个非空白字符的位置。</li><li><code>$</code>：移动光标到本行行尾。</li><li><code>g_</code>：移动光标到本行最后一个非空白字符的位置。</li><li><code>/匹配内容</code>：在文件内部搜索匹配的内容，高亮显示匹配到的内容并将光标移动到匹配的地方。若有多个匹配，则可以按 <code>n</code> 来切换到下一个匹配到内容的地方。。</li><li><code>u</code>：撤销一次操作。</li><li><code>ctrl + r</code>：撤销一次撤销操作。</li></ul><p>一些简单的进阶操作：</p><p>使用数字键来快速编辑文本：</p><p>可以在命令前添加数字键代表执行该命令多少次。</p><p>例如：</p><p>输入 <code>5yy</code> 代表粘贴 <strong>5</strong> 行到剪切板。</p><p>输入 <code>10dd</code> 代表删除十行内容。等等。</p><p>如果你希望学习更多、更详细有关 <code>vim</code> 的知识，我推荐以下网站：<a href="https://coolshell.cn/articles/5426.html/comment-page-11#comments">简明 VIM 练级攻略</a></p><h2 id="使用GCC"><a href="#使用GCC" class="headerlink" title="使用GCC"></a>使用GCC</h2><p><strong>gcc</strong> 是编译 <strong>C</strong> 语言文件的不二之选。</p><p><strong>C</strong> 语言的编译过程包括四步：预处理、编译、汇编、链接。</p><p>预处理自不多说。编译是将代码转换为汇编代码的过程。汇编是将汇编代码转换为机器码的过程。链接是将多个汇编文件以及所需的库文件链接成最终的可执行文件。</p><p><strong>gcc</strong> 的用法：<code>gcc [options] file...</code>。</p><p>常用的参数如下所示：</p><ul><li><code>-E</code>：只进行预处理，不进行编译、汇编、链接。</li><li><code>-S</code>：只编译，而不汇编和链接。这将产生一个可阅读的汇编代码。</li><li><code>-c</code>；只编译、汇编，而不链接。</li><li><code>-o &lt;name&gt;</code>：指定输出文件的名字。</li><li><code>-I&lt;path&gt;</code>：将路径添加到头文件搜索路径中。</li><li><code>-Wall</code>：意思是 <code>warn all</code>，产生尽可能多的警告信息。</li><li><code>-Werror</code>：将所有警告当做错误处理。这有助于你不得不消除所有警告。</li></ul><p>比如说，我们想编译 <code>hello.c</code> 文件和 <code>world.c</code> 文件，将输出文件命名为 <code>hello_world</code>，需要用的指令可能是：<code>gcc -Wall -o hello_world hello.c world.c</code></p><h2 id="MAKEFILE-生存指南"><a href="#MAKEFILE-生存指南" class="headerlink" title="MAKEFILE 生存指南"></a>MAKEFILE 生存指南</h2><p>简易生存指南：</p><p><code>Makefile</code> 的格式如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: dependencies</span></span><br><span class="line">    command 1</span><br><span class="line">    command 2</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在运行 <code>target</code> 的指令前会先构建依赖（先执行 <code>dependencies</code> 中的 <code>target</code>）。之后依次运行 <code>command1, command2, ...</code>。</p><p>在命令行中输入 <code>make target</code> 即可运行对应的命令。</p><p>当在命令行中输入 <code>make</code> 不附带参数时，会默认构建第一个 <code>target</code>。</p><h2 id="git-生存指南"><a href="#git-生存指南" class="headerlink" title="git 生存指南"></a>git 生存指南</h2><p><strong>git</strong> 是神！我将为你介绍我们的道标和救助：<strong>git</strong> 先生：</p><p><strong>git</strong> 是我们进行版本控制的利器。</p><p>存活的三条最低限度指令：<code>git add .</code>，<code>git commit -m &quot;comment&quot;</code>，<code>git push</code></p><p>在 <strong>git</strong> 中，分为工作区、暂存区和 <strong>Git</strong> 目录。</p><p>基本的 <strong>git</strong> 工作流程如下：</p><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将修改永久性存储到 <strong>Git</strong> 目录。</li></ol><p><code>git add .</code> 的意思是将当前目录的所有修改添加到暂存区。这通常不是个好习惯，不过对于新手而言是很容易上手的。</p><p><code>git commit</code> 的含义是将暂存区内容添加到本地仓库。</p><p><code>git push</code> 的意思是将本地分支推送至远程仓库。</p><p>学习更详细的 <code>git</code> 操作：<a href="https://git-scm.com/book/zh/v2">Git Book</a></p><p>赞美 <strong>git</strong>！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab1总结</title>
      <link href="/2023/06/12/OS-lab1/"/>
      <url>/2023/06/12/OS-lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h2><p><strong>ELF</strong> 是一种用于于可执行文件、目标文件和库的文件格式。其包含三种文件类型：可重定位文件，可执行文件和共享对象文件。</p><p>结构可视化：</p><p><img src="https://pic.imgdb.cn/item/64872afc1ddac507cc792738.jpg" alt=""></p><p><strong>ELF</strong> 文件由以下三部分组成：</p><ul><li><strong>ELF</strong> 头 (ELF header) - 描述文件的主要特性，如文件类型、入口地址、段表偏移、节表偏移等。</li><li>程序头表 (Program header table) - 描述程序的段信息，如段的类型、大小、权限、位置等。</li><li>节头表 (Section header table) - 描述程序的节信息，如节的名称、类型、大小、位置等。</li></ul><p><strong>ELF</strong> 文件提供了两种视图，分别是链接视图和执行视图：</p><ul><li>链接视图是以节（section）为单位，用于静态链接器（如ld）处理目标文件或共享目标文件。</li><li>执行视图是以段（segment）为单位，用于动态链接器（如/lib64/ld-linux-x86-64.so.2）加载和执行可执行文件或共享目标文件。</li></ul><h2 id="MIPS-内存布局"><a href="#MIPS-内存布局" class="headerlink" title="MIPS 内存布局"></a>MIPS 内存布局</h2><p>我们需要了解 <strong>MIPS</strong> 的内核布局，理解地址空间。这对于以后的实验大有裨益。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// /include/mmu.h 文件内容。这个图很重要，需要经常看，最好记下来。</span><br><span class="line">/*</span><br><span class="line"> o     4G -----------&gt;  +----------------------------+------------0x100000000</span><br><span class="line"> o                      |       ...                  |  kseg2</span><br><span class="line"> o      KSEG2    -----&gt; +----------------------------+------------0xc000 0000</span><br><span class="line"> o                      |          Devices           |  kseg1</span><br><span class="line"> o      KSEG1    -----&gt; +----------------------------+------------0xa000 0000</span><br><span class="line"> o                      |      Invalid Memory        |   /|\</span><br><span class="line"> o                      +----------------------------+----|-------Physical Memory Max</span><br><span class="line"> o                      |       ...                  |  kseg0</span><br><span class="line"> o      KSTACKTOP-----&gt; +----------------------------+----|-------0x8040 0000-------end</span><br><span class="line"> o                      |       Kernel Stack         |    | KSTKSIZE            /|\</span><br><span class="line"> o                      +----------------------------+----|------                |</span><br><span class="line"> o                      |       Kernel Text          |    |                    PDMAP</span><br><span class="line"> o      KERNBASE -----&gt; +----------------------------+----|-------0x8001 0000    |</span><br><span class="line"> o                      |      Exception Entry       |   \|/                    \|/</span><br><span class="line"> o      ULIM     -----&gt; +----------------------------+------------0x8000 0000-------</span><br><span class="line"> o                      |         User VPT           |     PDMAP                /|\</span><br><span class="line"> o      UVPT     -----&gt; +----------------------------+------------0x7fc0 0000    |</span><br><span class="line"> o                      |           pages            |     PDMAP                 |</span><br><span class="line"> o      UPAGES   -----&gt; +----------------------------+------------0x7f80 0000    |</span><br><span class="line"> o                      |           envs             |     PDMAP                 |</span><br><span class="line"> o  UTOP,UENVS   -----&gt; +----------------------------+------------0x7f40 0000    |</span><br><span class="line"> o  UXSTACKTOP -/       |     user exception stack   |     BY2PG                 |</span><br><span class="line"> o                      +----------------------------+------------0x7f3f f000    |</span><br><span class="line"> o                      |                            |     BY2PG                 |</span><br><span class="line"> o      USTACKTOP ----&gt; +----------------------------+------------0x7f3f e000    |</span><br><span class="line"> o                      |     normal user stack      |     BY2PG                 |</span><br><span class="line"> o                      +----------------------------+------------0x7f3f d000    |</span><br><span class="line"> a                      |                            |                           |</span><br><span class="line"> a                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           |</span><br><span class="line"> a                      .                            .                           |</span><br><span class="line"> a                      .                            .                         kuseg</span><br><span class="line"> a                      .                            .                           |</span><br><span class="line"> a                      |~~~~~~~~~~~~~~~~~~~~~~~~~~~~|                           |</span><br><span class="line"> a                      |                            |                           |</span><br><span class="line"> o       UTEXT   -----&gt; +----------------------------+------------0x0040 0000    |</span><br><span class="line"> o                      |      reserved for COW      |     BY2PG                 |</span><br><span class="line"> o       UCOW    -----&gt; +----------------------------+------------0x003f f000    |</span><br><span class="line"> o                      |   reversed for temporary   |     BY2PG                 |</span><br><span class="line"> o       UTEMP   -----&gt; +----------------------------+------------0x003f e000    |</span><br><span class="line"> o                      |       invalid memory       |                          \|/</span><br><span class="line"> a     0 ------------&gt;  +----------------------------+ ----------------------------</span><br><span class="line"> o</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li><strong>kuseg</strong>：占低 <strong>2GB</strong> 的空间（<code>0x00000000 - 0x7FFFFFFF</code>），是用户态唯一可用的地址空间。这部分的地址都需要经过 <strong>MMU</strong> 进行物理地址的转换。并且对于这段地址的访问都会经过 <strong>cache</strong>。</li><li><strong>kseg0</strong>：占据 <strong>512MB</strong> 空间（<code>0x80000000 - 0x9FFFFFFF</code>）。<strong>MMU</strong> 将虚拟地址的最高位清零即得到物理地址。也就是说这段地址是连续映射到物理地址的低 <strong>512MB</strong> 空间的。<strong>对这段内存的存取都会经过cache</strong>。</li><li><strong>kseg1</strong>：占据 <strong>512MB</strong> 空间（<code>0xA0000000 - 0xBFFFFFFF</code>）。<strong>MMU</strong> 将虚拟地址的最高三位清零得到物理地址。这段地址也被连续映射到物理地址的低 <strong>512MB</strong> 空间。<strong>对这段内存的存取不会经过cache</strong>，往往使用 <strong>MMIO</strong>（Memory-Mapped I/O）技术来访问外设。</li><li><strong>kseg2</strong>：这段占 <strong>1GB</strong> 空间（<code>0xC0000000 - 0xFFFFFFFF</code>）。<strong>MMU</strong> 需要通过 <strong>TLB</strong> 进行地址转换，并且对这段地址的访存都会经过 <strong>cache</strong>。</li></ul><p>注意，只有低 <strong>2GB</strong> 的空间是用户态可用的，<strong>kseg0-kseg1</strong> 都是仅内核态可用的地址空间。</p><p>在载入内核时，<strong>TLB</strong> 需要操作系统配置管理，因此可选的地址空间只有 <strong>kseg0</strong> 和 <strong>kseg1</strong>。<strong>kseg1</strong> 往往只有访问外设时才会用到，因此我们将内核的 <strong>.text</strong>，<strong>.data</strong>，<strong>.bss</strong> 段都放到 <strong>kseg0</strong>。</p><p>在真实的系统中，<strong>bootloader</strong> 会在载入内核前进行 <strong>cache</strong> 的初始化工作。因此在使用 <strong>kseg1</strong> 时 <strong>cache</strong> 已经被配置好了。</p><h2 id="控制加载地址"><a href="#控制加载地址" class="headerlink" title="控制加载地址"></a>控制加载地址</h2><p>我们是通过 <strong>Link Script</strong> 来控制内核的加载地址的。它记载了各个节应该如何映射到段，以及各个段应该被加载的位置。</p><p>在链接过程中，目标文件被看作是节的集合。最重要的三个段的意义如下：</p><ul><li><strong>.text</strong>：保存可执行文件的操作指令。</li><li><strong>.data</strong>：保存已初始化的全局变量和静态变量。</li><li><strong>.bss</strong>：保存未初始化的全局变量和静态变量。</li></ul><h2 id="printk"><a href="#printk" class="headerlink" title="printk"></a>printk</h2><p>在 <strong>lab1</strong> 中，我们要实现一个 <strong>printk</strong> 函数（在 <strong>kern</strong> 中进行 <strong>print</strong> 的函数）。</p><p>我们需要读并理解以下三个文件：</p><ul><li><strong>kern/console.c</strong>：完成了向控制台写入、读取字符的功能。实际上是读取、写入一个特殊的内存。</li><li><strong>kern/printk.c</strong>：实现了 <strong>printk</strong>。通过调用 <strong>vprintfmt</strong> 来输出字符。</li><li><strong>lib/print.c</strong>：实现了格式化输出的主体逻辑。我们在课程中接触的输出函数都需要通过调用此函数来达到输出的目的。（如 <strong>printk</strong>，以及以后的 <strong>debugf</strong>，<strong>printf</strong>）</li></ul><p>在 <strong>lab1</strong> 中我们主要需要补全 <strong>lib/print.c</strong> 中的函数，这个实验很重要，是我们以后进行其他实验的基础。在补全过程中主要考察的是 <strong>C</strong> 语言基础能力。</p><p>这里提一嘴，<strong>C</strong> 语言基础能力在 <strong>OS</strong> 中是很重要的，无论是实验还是平时课下，都需要拥有良好的 <strong>C</strong> 语言基础才能够顺利通过。</p><h2 id="异常码"><a href="#异常码" class="headerlink" title="异常码"></a>异常码</h2><p>在 <code>include/err.h</code> 中定义了许多异常码。在报错时需要明白自己是报的什么错误，才能更好的定位 <strong>bug</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unspecified or unknown problem</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_UNSPECIFIED 1 <span class="comment">// 未知的错误</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Environment doesn&#x27;t exist or otherwise cannot be used in requested action</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_BAD_ENV 2 <span class="comment">// 进程不存在或无法在请求的操作中使用</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Invalid parameter</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_INVAL 3 <span class="comment">// 不合法的参数（一般用于函数判断参数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Request failed due to memory shortage</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_NO_MEM 4 <span class="comment">// 空间不足</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Invalid syscall number</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_NO_SYS 5 <span class="comment">// 未知的系统调用号</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Attempt to create a new environment beyond the maximum allowed</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_NO_FREE_ENV 6 <span class="comment">// 没有可分配的空闲进程</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Attempt to send to env that is not recving.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_IPC_NOT_RECV 7 <span class="comment">// 尝试发送到未接受的进程</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File system error codes -- only seen in user-level</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No free space left on disk</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_NO_DISK 8 <span class="comment">// 没有空余磁盘块</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Too many files are open</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_MAX_OPEN 9 <span class="comment">// 打开文件过多</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File or block not found</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_NOT_FOUND 10 <span class="comment">// 未找到磁盘块</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad path</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_BAD_PATH 11 <span class="comment">// 错误的路径</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File already exists</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_FILE_EXISTS 12 <span class="comment">// 文件已存在</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File not a valid executable</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_NOT_EXEC 13 <span class="comment">// 文件不是可执行程序</span></span></span><br></pre></td></tr></table></figure><h2 id="string-函数"><a href="#string-函数" class="headerlink" title="string 函数"></a>string 函数</h2><p>位于 <code>include/string.h</code> 下的头文件定义了一系列 <strong>C</strong> 语言函数，并于 <code>lib/string.c</code> 中实现。我们在课下也可以实现更多的字符处理函数，为以后的 <strong>lab</strong> 提供遍历。</p><p>函数的具体实现可以自己写也可以在网上找 <strong>C</strong> 标准库的源码。我个人比较推荐实现的函数有：</p><ul><li><strong>strcat</strong></li><li><strong>atoi</strong></li><li><strong>strncmp</strong></li></ul><p>这东西没事多扩充实现一点，将来在做挑战性任务的时候总会轻松一些的…</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab6 挑战性任务</title>
      <link href="/2023/05/20/OS-lab6-challenge/"/>
      <url>/2023/05/20/OS-lab6-challenge/</url>
      
        <content type="html"><![CDATA[<h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>挑战性任务共分为必做和选做两部分。</p><h3 id="必做部分"><a href="#必做部分" class="headerlink" title="必做部分"></a>必做部分</h3><h4 id="实现一行多命令"><a href="#实现一行多命令" class="headerlink" title="实现一行多命令"></a>实现一行多命令</h4><p>用 <code>;</code> 分开同一行内的两条命令，表示依次执行前后两条命令。<code>;</code> 左右的命令都可以为空。</p><h4 id="实现后台任务"><a href="#实现后台任务" class="headerlink" title="实现后台任务"></a>实现后台任务</h4><p>用 <code>&amp;</code> 分开同一行内的两条命令，表示同时执行前后两条命令。<code>&amp;</code> 左侧的命令应被置于后台执行，<strong>Shell</strong> 只等待 <code>&amp;</code> 右侧的命令执行完毕，然后继续执行后续语句，此时用户可以输入新的命令，并且可能同时观察到后台任务的输出。你需要自行设计测试，以展现此功能的运行效果。<code>&amp;</code> 左侧的命令不能为空。</p><h4 id="实现引号支持"><a href="#实现引号支持" class="headerlink" title="实现引号支持"></a>实现引号支持</h4><p>实现引号支持后，<strong>shell</strong> 可以处理如： <code>echo.b &quot;ls.b | cat.b&quot;</code> 这样的命令。即 <strong>shell</strong> 在解析时，会将双引号内的内容看作单个字符串，将 <code>ls.b | cat.b</code> 作为一个参数传递给 <code>echo.b</code>。</p><h4 id="实现键入命令时任意位置的修改"><a href="#实现键入命令时任意位置的修改" class="headerlink" title="实现键入命令时任意位置的修改"></a>实现键入命令时任意位置的修改</h4><p>现有的 <strong>shell</strong> 不支持在输入命令时移动光标。你需要实现：键入命令时，可以使用 <code>←Left</code> 和 <code>→Right</code> 移动光标位置，并可以在当前光标位置进行字符的增加与删除。要求每次在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。</p><h4 id="实现程序名称中-b-的省略"><a href="#实现程序名称中-b-的省略" class="headerlink" title="实现程序名称中 .b 的省略"></a>实现程序名称中 .b 的省略</h4><p>目前的用户程序被烧录到文件系统中后，其可执行文件以 <code>.b</code> 为后缀，为 <strong>shell</strong> 中命令的输入带来了不便。你需要修改现有的实现，以允许命令中的程序名称省略 <code>.b</code> 后缀，例如当用户指定的程序路径不存在时，尝试在路径后追加 <code>.b</code> 再打开。</p><h4 id="实现更丰富的命令"><a href="#实现更丰富的命令" class="headerlink" title="实现更丰富的命令"></a>实现更丰富的命令</h4><p>参考实验环境中的 <strong>Linux</strong> 命令 <code>tree</code>、<code>mkdir</code>、<code>touch</code> 来实现这三个命令，请尽可能地实现其完整的功能。</p><p>为了实现文件和目录的创建，你需要实现用户库函数 <code>mkdir()</code> 和文件打开模式 <code>O_CREAT</code>。</p><p>实现文件的创建后，你需要修改 <strong>shell</strong> 中输出重定向 <code>&gt;</code> 的实现，使其能够在目标路径不存在时自动创建并写入该文件。</p><h4 id="实现历史命令功能"><a href="#实现历史命令功能" class="headerlink" title="实现历史命令功能"></a>实现历史命令功能</h4><p>在 <strong>Linux</strong> 的 <strong>shell</strong> 中我们输入的命令都会被保存起来，并可以通过 <code>↑Up</code> 和 <code>↓Down</code> 键回溯，这为我们的 <strong>shell</strong> 操作带来了极大的方便。在此项任务中，需要实现保存所有输入至 <strong>shell</strong> 的命令，并可以通过 <code>history.b</code> 命令输出所有的历史命令，以及通过上下键回溯命令并运行。</p><p>禁止使用局部变量或全局变量的形式实现保存历史命令，即不能用进程的堆栈区保存历史命令。</p><p>禁止在烧录 <code>fs.img</code> 时烧录一个 <code>.history</code> 文件，即你需要在第一次写入时，创建一个 <code>.history</code> 文件，并在随后每次输入时在 <code>.history</code> 文件末尾写入。</p><h3 id="选做部分"><a href="#选做部分" class="headerlink" title="选做部分"></a>选做部分</h3><h4 id="实现-shell-环境变量"><a href="#实现-shell-环境变量" class="headerlink" title="实现 shell 环境变量"></a>实现 shell 环境变量</h4><p>支持 <code>declare [-xr] [NAME [=VALUE]]</code> 命令，其中：</p><p><code>-x</code> 表示变量 <code>NAME</code> 为环境变量，否则为局部变量。</p><p>环境变量对子 <strong>shell</strong> 可见，也就是说在 <strong>shell</strong> 中输入 <code>sh.b</code> 启动一个子 <strong>shell</strong> 后，可以读取并修改 <code>NAME</code> 的值，即支持环境变量的继承。</p><p>局部变量对子 <strong>shell</strong> 不可见，也就是说在 <strong>shell</strong> 中输入 <code>sh.b</code> 启动一个子 <strong>shell</strong> 后，没有该局部变量。</p><p><code>-r</code> 表示将变量 <code>NAME</code> 设为只读。只读变量不能被 <code>declare</code> 重新赋值或被 <code>unset</code> 删除。</p><p>如果变量 <code>NAME</code> 不存在，需要创建该环境变量；如果变量 <code>NAME</code> 存在，将该变量赋值为 <code>VALUE</code>。</p><p>其中 <code>VALUE</code> 为可选参数，缺省时将该变量赋值为空字符串即可。</p><p>如果没有 <code>[-xr]</code> 及 <code>[NAME [=VALUE]]</code> 部分，即只输入 <code>declare</code>，则输出当前 <strong>shell</strong> 的所有变量，包括局部变量和环境变量。</p><p>支持 <code>unset NAME</code> 命令，若变量 <code>NAME</code> 不是只读变量，则删除变量 <code>NAME</code>。</p><p>支持在命令中展开变量的值，如使用 <code>echo.b $NAME</code> 打印变量 <code>NAME</code> 的值。</p><h4 id="支持相对路径"><a href="#支持相对路径" class="headerlink" title="支持相对路径"></a>支持相对路径</h4><p><strong>MOS</strong> 中现有的文件系统操作并不支持相对路径，对于一切路径都从根目录开始查找，因此在 <strong>shell</strong> 命令中也需要用绝对路径指代文件，这为命令的描述带来了不便。你需要为每个进程维护工作目录这一状态，并为 <code>open()</code> 等用户库函数增加对参数中相对路径的支持，将不以 <code>/</code> 开头的路径视为相对路径，从当前进程的工作目录开始查找。同时，你需要添加 <code>chdir()</code> 和 <code>getcwd()</code> 等库函数，以支持切换当前进程的工作目录，并使进程的工作目录在 <code>fork()</code> 或 <code>spawn()</code> 时被子进程继承，从而实现以下功能：</p><p>支持内部命令 <code>cd &lt;path&gt;</code>，切换工作目录到 <code>&lt;path&gt;</code>，其中 <code>&lt;path&gt;</code> 可以是绝对路径或相对路径；</p><p>支持 <code>pwd</code> 命令，输出当前工作目录；</p><p>在切换工作目录后，测试 <code>cat.b</code>、<code>ls.b</code>、<code>touch.b</code> 等接受文件参数的命令，确保其参数中的相对路径能够正常工作。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="添加文件、命令"><a href="#添加文件、命令" class="headerlink" title="添加文件、命令"></a>添加文件、命令</h3><p>添加新的命令时，需要修改 <code>/user/include.mk</code>，在 <code>USERAPPS</code> 下添加对应文件的 <code>.b</code>。</p><p>想要将自己的 <strong>C</strong> 语言代码添加到编译过程（用户库）中，需要在 <code>user/include.mk</code> 的 <code>USERLIB</code> 后添加对应文件的 <code>.o</code>。</p><h3 id="一行多命令"><a href="#一行多命令" class="headerlink" title="一行多命令"></a>一行多命令</h3><p>在 <code>sh.c</code> 中已经为我们预留了 <code>;</code> 的 <strong>token</strong>，因此我们无需改变词法部分，只需改变语法解释部分。</p><p>由于需要实现命令的依次执行，因此我的做法是在 <code>fork()</code> 之后，子进程运行 <code>;</code> 之前的指令，父进程等待子进程结束之后运行剩下部分的指令。</p><h3 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h3><p>在 <code>sh.c</code> 中已经为我们预留了 <code>&amp;</code> 的 <strong>token</strong>，因此我们无需改变词法部分，只需改变语法解释部分。</p><p>同样是在 <code>fork()</code> 之后让父子进程分别运行前后的部分。我的方法是让子进程运行 <code>&amp;</code> 之前的指令，父进程无阻塞地运行 <code>&amp;</code> 之后的指令。</p><p>注意到 <code>read()</code> 函数会让进程阻塞在内核态从而没法进行进程调度，需要更改阻塞逻辑，将阻塞位置从内核态转移到用户态。</p><h3 id="引号支持"><a href="#引号支持" class="headerlink" title="引号支持"></a>引号支持</h3><p>在 <code>sh.c</code> 中没有为我们预留 <code>&quot;</code> 的 <strong>token</strong>，因此需要根据需求改变词法解释器或语法解释器。</p><p>我的做法是改变词法解释器，当解析到 <code>&quot;</code> 时则继续读取字符直到读取到匹配的 <code>&quot;</code> 为止。将整个字符串作为一个元素返回给语法解释器。</p><p>我的实现可以支持转义字符。效果如下所示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;a\&#x27;,\nancd\t,me&quot;</span><br><span class="line">a&#x27;,</span><br><span class="line">ancd        ,me</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>后来发现 <strong>shell</strong> 下的转义与 <strong>C</strong> 语言中的转义不是一个意思……不过问了助教这么做也可以所以就没动了。</p><h3 id="键入命令时任意位置的修改"><a href="#键入命令时任意位置的修改" class="headerlink" title="键入命令时任意位置的修改"></a>键入命令时任意位置的修改</h3><p>这部分进行的工作比较多。我重写了一遍读取行的部分（<code>user/sh.c</code> 中的 <code>readline()</code> 函数）。因为我认为在原有代码基础上新增功能比较复杂且容易出 <strong>bug</strong>（最主要是要理解原本的逻辑太麻烦了而且也不方便自己维护），还好原本 <code>readline()</code> 的内容就不算多，因此重构得还算顺利。</p><p>重构后的逻辑是：保存当前光标的位置，每次键入时都会保存光标之后的字符串（若有的话），依次输出光标前的字符串、输入字符、光标后的字符串。在实现过程中要注意维护光标的位置。</p><p>部分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == ESC) &#123;</span><br><span class="line">    <span class="type">char</span> temstr[<span class="number">5</span>] = &#123;<span class="number">27</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> ((r = read(<span class="number">0</span>, temstr+<span class="number">1</span>, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;read error: %d\n&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = read(<span class="number">0</span>, temstr+<span class="number">2</span>, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;read error: %d\n&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;                                       <span class="comment">// 读取键盘输入</span></span><br><span class="line">    <span class="keyword">switch</span> (judge_esc(temstr)) &#123;            <span class="comment">// 判断输入</span></span><br><span class="line">        <span class="keyword">case</span> RIGHT:</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; buf_len) &#123;</span><br><span class="line">                move_cursor(LEFT);</span><br><span class="line">                cnt--;                      <span class="comment">// 维护光标位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEFT:</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;                  <span class="comment">// 移动光标位置</span></span><br><span class="line">                cnt -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt = <span class="number">-1</span>;</span><br><span class="line">                move_cursor(RIGHT);         <span class="comment">// 维护光标位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            user_panic(<span class="string">&quot;error in readline\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序名称中-b-的省略"><a href="#程序名称中-b-的省略" class="headerlink" title="程序名称中 .b 的省略"></a>程序名称中 .b 的省略</h3><p>这部分需要修改 <code>spawn.c</code> 中的内容。</p><p>具体而言，在尝试打开文件失败时，首先将 <code>.b</code> 拼接到当前文件名之前（当前文件名末尾不是 <code>.b</code>），然后再次运行 <code>spawn()</code> 函数即可。</p><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>实现这个功能需要遍历目录。打印树需要递归实现。</p><p>关于如何遍历目录，可以参考 <code>ls.c</code> 文件。</p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_tree</span><span class="params">(<span class="type">char</span>* dir_path, <span class="type">const</span> <span class="type">char</span>* indent)</span> &#123;</span><br><span class="line"></span><br><span class="line">    FILE file = getfile(dir_path);</span><br><span class="line">    <span class="keyword">if</span> (file is dir) &#123;</span><br><span class="line">        <span class="keyword">for</span> (sons in file) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sons is dir) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(indent + <span class="string">&quot;|-&quot;</span> + file.name);</span><br><span class="line">                print_tree(dir_path + file.name, indent + <span class="string">&quot;|    &quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sons is file) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(indent + <span class="string">&quot;|-&quot;</span> + file.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="touch-和-mkdir"><a href="#touch-和-mkdir" class="headerlink" title="touch 和 mkdir"></a>touch 和 mkdir</h3><p>完成创建文件和文件夹的功能，具体而言是在 <code>fs/serv.c</code> 下修改 <code>serve_open()</code> 函数。在 <code>fs/fs.c</code> 里已经为我们实现了 <code>file_create</code> 函数，我们主要需要做的是在 <code>fs/serv.c</code> 中实现这一接口。</p><p>完成接口之后只需要以 <code>O_CREAT</code> 模式调用 <code>open()</code> 函数即可完成创建文件。（当然也可以支持类似于 <code>O_CREAT | O_WRONLY</code>，完成创建并以可写模式打开文件）</p><p>创建文件夹的时候将文件的属性更改为 <code>FTYPE_DIR</code> 即可。</p><h3 id="修改-gt"><a href="#修改-gt" class="headerlink" title="修改 &gt;"></a>修改 &gt;</h3><p>我们需要修改对 <code>&gt;</code> 的处理以保证在重定向的目标文件不存在时能够自动创建该文件并写入。在实现了 <code>touch</code> 和 <code>mkdir</code> 之后这个功能是很容易实现的。</p><p>具体而言，在打开文件失败时就尝试创建文件，对新创建的文件执行写入操作即可。</p><h3 id="history-功能"><a href="#history-功能" class="headerlink" title="history 功能"></a>history 功能</h3><p>我们需要实现 <code>history</code> 功能，完成上下键切换历史指令。这部分的工作量是必做部分最大的。我们需要完成写入、读取 <code>.history</code>。为了实现函数，我在 <code>user/lib/</code> 目录下新建了 <code>history.c</code> 文件，单独放置实现 <code>history</code> 功能的函数。就我个人而言，我实现的函数包括：</p><ul><li><code>history_init()</code>: 初始化 <code>.history</code> 文件。</li><li><code>int history_open()</code>: 打开 <code>.history</code> 文件。</li><li><code>void history_write(const char* content)</code>: 将字符串内容写入到 <code>.history</code> 中。</li><li><code>int history_get_last(char* buf)</code>: 获取最近的历史命令。</li><li><code>int history_next(char* buf, int off, int direction)</code>: 从给定的偏移处，按照指定的方向寻找下一个（上一个）历史指令。</li></ul><p>对于每一条历史指令，存入 <code>.history</code> 时采取 <code>&lt;strlen&gt;&lt;string&gt;&lt;strlen&gt;</code> 的格式，从而能够实现双向的遍历。</p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>我选择做相对路径部分，因为实现了相对路径之后 <code>shell</code> 使用起来将更加方便。</p><p>想要支持工作目录，需要在每个进程中维护各自的工作目录。需要在 <code>include/env.h</code> 中添加相应的变量。</p><p>注意，在进程控制块中添加对应变量后需要维护进程块初始化、<code>fork()</code> 时相应变量的变化。</p><p>此外需要至少实现两个系统调用。一个用于实现用户进程获取当前的工作目录，一个用于用户进程改变自己当前的工作目录。</p><p>添加系统调用的流程如下：</p><ul><li>在 <code>user/include/lib.h</code> 中添加 <code>syscall_*()</code> 函数。</li><li>在 <code>user/lib/syscall_lib.c</code> 中实现对应的函数。</li><li>在 <code>include/syscall.h</code> 中添加对应的系统调用号 <code>SYS_*</code>。</li><li>在 <code>kern/syscall_all.c</code> 中实现内核部分的函数并将调用关系添加到 <code>syscall_table</code> 中。</li></ul><p>获取工作目录直接在内核态 <code>strcpy()</code> 一下就行。</p><p>比较麻烦的是改变工作目录这个东西，不得不进行父子进程的通信（或是进行一些神秘的危险操作……）。原因在于在 <code>sh.c</code> 中会 <code>fork()</code> 一个子进程运行 <code>runcmd()</code> 函数，这样在进行 <code>cd</code> 操作时是在子进程中操作的。这个问题的解决办法不唯一。也可以允许子进程直接在内核态修改父进程的工作目录（不过这很危险）。</p><p>下一步是解析相对目录。这个是一些字符串操作，相对而言没什么困难的地方。</p><p>我在实现解析相对目录之后，修改了 <code>open()</code> 函数，对传入 <code>open()</code> 函数的参数进行相对目录解析，从而基本实现了对相对目录下文件的各种操作。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>在提交 <strong>ddl</strong> 的前一天终究是也把环境变量给做了…做起来发现环境变量比相对路径好做多了，泪目。</p><p>为了实现环境变量，我是直接在内核态新定义了一种结构体 <code>struct Var</code>，用于保存环境变量相关的信息。</p><p>具体要保存的信息至少有：变量的名、变量的值、变量的权限、变量的所有者。</p><p>共实现了五个对应的系统调用：</p><ul><li><code>sys_get_shell_id</code>：给一个 <strong>shell</strong> 分配一个独特的 <strong>shell_id</strong>，用以标识一个独特的 <strong>shell</strong>。</li><li><code>sys_declare_write</code>：写入一个环境变量。</li><li><code>sys_declare_unset</code>：取消一个环境变量。</li><li><code>sys_declare_get</code>：获取一个环境变量。</li><li><code>sys_declare_getall</code>：获取所有环境变量。</li></ul><p>在所有操作里都需要对环境变量的权限、所有者等进行逻辑判断。</p><p>在实现 <code>declare</code> 和 <code>unset</code> 两个函数时，需要额外将当前 <strong>shell</strong> 的 <strong>sheel_id</strong> 作为参数压入。</p><p>在进行参数的替换时，对当前所有的参数进行判断，若参数首字母为 <code>$</code> 且能取得对应的环境变量，则用环境变量的值替换掉参数。</p><p>以上均为我个人的实现方式，不保证思路完全正确，欢迎讨论交流。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW11</title>
      <link href="/2023/05/17/OO-hw11/"/>
      <url>/2023/05/17/OO-hw11/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于涉及了图以及图上的算法，本次作业的难度较高。难点主要在于单源最短环的查找方式。</p><p>本次作业添加了几个新的 <strong>Message</strong> 种类：<strong>EmojiMessage</strong>，<strong>NoticeMessage</strong>，<strong>RedEnvelopeMesssage</strong>。均按照规格写，无需过多改动此前的代码。</p><p>需要进行改动的代码主要是 <strong>NetWork</strong> 中的 <strong>addMessage</strong> 类和 <strong>sendMessage</strong> 类，需要针对不同的消息类型做出对应的处理。</p><p>此外需要完成单源最短环的查找（<strong>queryLeastMoments</strong>）。</p><h2 id="第十一次作业设计"><a href="#第十一次作业设计" class="headerlink" title="第十一次作业设计"></a>第十一次作业设计</h2><p>重点谈谈对于单源最短环的设计吧：</p><p>起初，我的设计是删边法 + 最短路：</p><p>对于起点 <strong>i</strong>，假如点 <strong>j</strong> 与 <strong>i</strong> 直接相连，则删掉此边后查询 <strong>i</strong> 和 <strong>j</strong> 之间是否仍然存在路径。若存在路径，则一个可能的最短环值就是 $u_{i,j}+Dijkstra_{i,j}$，遍历所有与起点直接相连的点即可找到最短环。</p><p>这个做法易于理解，实现起来并不复杂，我本来打算就用这个写法来着。当我按照这个设计写完之后，经过计算、考虑和询问助教后，认为这个方法的时间复杂度比较危险。按照我的预计，有可能会 <strong>t</strong> 掉 <strong>1-2</strong> 个点。（后来我交了一下这个做法发现果然会 <strong>t</strong> 掉一个点）</p><p>本来想着就这样算了，但是后来在周末的时候又觉得有点点不甘心，于是就对原来的方法进行了优化。</p><p>优化的方法参考了讨论区内的帖子和 <strong>CSDN</strong> 上的博客，在此不进行正确性证明，只描述一下我的实现方式：</p><p>首先以源点开始跑一遍 <strong>dijkstra</strong> 算法，能够得到图上所有点到源点的最短路的值。在跑最短路的过程中记录每个点和其父节点，最终我们可以得到一颗以源点为祖节点的生成树：</p><p><img src="https://pic2.imgdb.cn/item/646491260d2dde577788937d.jpg" alt="树图"></p><p>然后我们在树中尝试添加一条边来构造最短环。这条边的两个顶点不能处于同一颗子树下，否则生成的环路中不包含源点。</p><p>设源点为 <strong>o</strong>。于是对于树中的每一个定点 <strong>i</strong>，选择的边的另一个顶点 <strong>j</strong> 有两种情况：</p><ol><li><strong>j</strong> 是源点且 <strong>i</strong> 的父节点不是源点（若是源点则无环）。</li><li><strong>j</strong> 是其他子树上的定点。</li></ol><p><img src="https://pic2.imgdb.cn/item/646493f90d2dde57778d679f.jpg" alt="树图2"></p><p>对于第一种情况，得到的环值为 $Dijkstra_{o,i}+u_{o,i}$。对于第二种情况，得到的环值为 $Dijkstra_{o,i}+Dijkstra_{o,j}+u_{i,j}$。</p><p>遍历所有树上的顶点即可得到最短环值。</p><p>在实现过程中，为快速判断两个顶点是否是同一颗子树下，可以使用并查集。这部分可以复用以前的并查集代码。在实现 <strong>dijkstra</strong> 的过程中可以利用 <strong>Java</strong> 的优先队列进行优化。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>这里给出我实现 <strong>qlm</strong> 的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> id;                             <span class="comment">// 源点id</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; nodes;    <span class="comment">// 存储点到源点的距离</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; preId;    <span class="comment">// 存储每个点的父节点</span></span><br><span class="line">DisjointSet diffTree;               <span class="comment">// 存储不同子树的并查集</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;                       <span class="comment">// 存储答案</span></span><br><span class="line">dijkstra(id, nodes, preId);</span><br><span class="line">preIds.forEach((nowId, preId) -&gt; &#123;  <span class="comment">// 存储子树</span></span><br><span class="line">            <span class="keyword">if</span> (preId != id) &#123;</span><br><span class="line">                diffTree.merge(nowId, preId);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Person person: people.values()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (person.hasPath() &amp;&amp; person.id != id) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: person.getAcquaintance().keyset()) &#123; <span class="comment">// 所有与当前 person 直接相连的人的 id</span></span><br><span class="line">            <span class="keyword">if</span> (i == id) &#123;</span><br><span class="line">                <span class="comment">// 判断对应条件，更新 ans</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 判断对应条件，更新 ans</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// throw sth</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure><h2 id="OKTest"><a href="#OKTest" class="headerlink" title="OKTest"></a>OKTest</h2><p>本次作业的 <strong>OKTest</strong> 要求我们对 <strong>deleteColdEmoji</strong> 方法进行 <strong>OKTest</strong> 测试。</p><p>难点主要在于理解晦涩的 <strong>JML</strong>。</p><h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><p>本次作业没有遇上什么让我值得一记的 <strong>bug</strong>，强测和互测都顺利通过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次作业难度主要体现在 <strong>qlm</strong> 还有课程组飘忽不定的 <strong>JML</strong> 上。不得不吐槽的是 <strong>OKTest</strong> 的 <strong>JML</strong> 的可读性真的巨差，我时常怀疑是否是我的理解能力出现了问题还是说 <strong>JML</strong> 的可读性就是这么差劲。后来我用自然语言翻译了一遍 <strong>OKTest</strong> 的 <strong>JML</strong>，发现自然语言真是好用多了，帮同学 <strong>debug</strong> 也不用读 <strong>JML</strong> 了，主打的叫一个舒服。</p><h2 id="黑箱测试与白箱测试"><a href="#黑箱测试与白箱测试" class="headerlink" title="黑箱测试与白箱测试"></a>黑箱测试与白箱测试</h2><p>黑箱测试是从软件外部对软件进行测试，只关注输入和输出，不考虑软件是如何实现的。黑箱测试也称为功能测试或数据驱动测试，它主要根据功能需求设计测试用例，检验软件是否能按照规格说明书的要求正常工作。黑箱测试的优点是与软件具体实现无关，如果软件实现发生了变化，测试用例仍可用；缺点是可能遗漏一些内部错误或逻辑缺陷。黑箱测试常用的方法有等价类划分、边界值分析、因果图、决策表分析等。</p><p>黑箱测试的优点：</p><ul><li>独立性：黑盒测试相对于开发团队是相对独立的，测试人员可以独立进行测试，减少了开发者对测试过程的干扰。</li><li>用户导向：黑盒测试从用户的角度出发，关注系统是否满足用户需求和规格要求，能够更好地验证系统的功能和用户体验。</li><li>代码无关：黑盒测试不需要了解系统的内部实现细节和代码逻辑，测试人员只需关注输入和输出之间的关系。</li></ul><p>黑箱测试的缺点:</p><ul><li>遗漏内部错误：由于黑盒测试不考虑系统的内部结构和代码逻辑，可能无法发现由于内部错误或代码缺陷引起的问题。</li><li>覆盖范围有限：黑盒测试通常基于需求和规格说明，因此测试用例的设计可能受到这些文档的限制，导致无法覆盖所有可能的情况。</li><li>效率低下：由于黑盒测试无法直接访问系统的内部，测试人员需要通过用户界面或其他接口来进行测试，这可能导致测试过程效率较低。</li></ul><p>白箱测试的优点：</p><ul><li>内部错误发现：白盒测试可以深入系统的内部，检查代码的执行路径、逻辑错误、边界条件等，有助于发现由于代码缺陷引起的问题。</li><li>覆盖全面：通过访问系统的内部结构和代码，白盒测试可以设计更全面的测试用例，覆盖不同的代码路径和分支情况。</li><li>性能优化：白盒测试可以评估系统的性能瓶颈和资源利用情况，帮助开发团队进行性能优化和调优。</li></ul><p>白箱测试的缺点：</p><ul><li>依赖开发者技能：白盒测试需要测试人员具备一定的编程和调试技能，以理解代码逻辑并编写相应的测试用例。</li><li>开发团队的参与：由于白盒测试通常由开发团队的一部分执行，可能存在开发者对自己代码的偏见，导致测试过程缺乏独立性。</li><li>时间和资源消耗：白盒测试需要深入理解系统的内部结构和代码，因此可能需要更多的时间和资源来进行测试和分析。</li></ul><h2 id="数据构造策略"><a href="#数据构造策略" class="headerlink" title="数据构造策略"></a>数据构造策略</h2><p>本单元在做测试时我主要是针对自己的代码做的白箱测试。通过构造特定的图以及相应的指令来满足覆盖率的要求。这样做测试的针对性较高，基本不到十个数据点即可满足覆盖率的要求。相应的是编写测试点需要耗费较多的精力。</p><h2 id="规格与实现相分离"><a href="#规格与实现相分离" class="headerlink" title="规格与实现相分离"></a>规格与实现相分离</h2><p>规格与实现分离是一种软件设计的原则，它要求在编写软件需求规格说明时，只描述软件的功能和性能，而不描述软件的内部结构和实现方法。这样可以使软件需求更清晰、更稳定、更容易验证，也可以使软件设计和开发更灵活、更自由、更有创新。</p><p>规格是对系统功能、行为和性能的描述，通常以需求规格说明、设计规范或用户文档的形式存在。它们是开发团队与客户、用户之间的合同和共享理解的基础。规格的目的是定义系统应该做什么，而不是如何实现它。</p><p>实现是指将规格转化为实际的软件代码和系统组件的过程。它涉及开发者根据规格进行编码、调试、测试和部署的工作。实现的目的是将规格转化为具体的可执行代码，以实现系统的功能和要求。</p><p>这个原则实际上我们经常接触；打比方，在做题时题目只给出了要求完成的功能，没有限制实现的方法。我认为这也是一种规格与实现相分离（出题者和做题者之间）。</p><h2 id="OKTest-的理解"><a href="#OKTest-的理解" class="headerlink" title="OKTest 的理解"></a>OKTest 的理解</h2><p>本单元的 <strong>OKTest</strong> 要我们对于某些方法的正确性以及副作用按照规格进行检测。实际上是写了一个小型的评测机。</p><p>本单元中，我认为 <strong>OKTest</strong> 的输入输出接口设计得不算太好。虽然课程组使用的 <strong>HashMap</strong> 能在一定程度上方便代码的编写，但是我认为按照 <strong>JML</strong> 规格要求的 <strong>people-person-(acquaintanceId, value)</strong> 来传入数据或许是一个更好的选择。即在第九、十次作业中传入 <strong>Person[] people</strong> 而非 <strong>Hashmap</strong>，在第十一次作业中传入 <strong>Message[] messages, int[] emojiIdList, int[] emojiHeatList</strong>。这样是更容易让人理解，至于建图这种事情，我认为应当交给我们自己做。</p><h2 id="单元总结"><a href="#单元总结" class="headerlink" title="单元总结"></a>单元总结</h2><p>本单元接触了 <strong>JML</strong> 语言，让我深深体会到了这种语言的不足与局限性。我来细数一下我在本单元中对 <strong>JML</strong> 语言体会到的不便：</p><ol><li>同一个意思使用 <strong>JML</strong> 语言可能会有不同的表达方式，在较大的工程中不同的表达方式会给阅读者带来理解上的困难。比方说，<em>“对于所有 <strong>i</strong>，都满足条件 <strong>cond</strong>”</em> 这句话，我们既可以使用 <code>ensures (\forall i; 0 &lt;= i &amp;&amp; i &lt;= max; cond)</code>，也可以使用 <code>ensures !(\exist i; 0 &lt;= i &amp;&amp; i &lt;= max; !cond)</code>。不同的规格编写者有可能会写出不同的 <strong>JML</strong> 代码。阅读者在阅读 <strong>JML</strong> 时，一旦习惯了某一种表述方式，突然更换表述方式则会带来理解上的不便。</li><li><strong>JML</strong> 代码的正确性依赖于编写者。一旦 <strong>JML</strong> 代码出现了正确性问题，会带给阅读者深深的烦恼，而且越大的工程在迭代时维护 <strong>JML</strong> 会带来更大的困难。本单元的 <strong>JML</strong> 代码可以说是经常出现问题，每次作业都会出现规格上的错误，包括本单元的实验。这给同学们带来了不小的麻烦。</li><li><strong>JML</strong> 不易描述过于复杂的算法。或者说使用 <strong>JML</strong> 语言描述过于复杂的算法会让 <strong>JML</strong> 的体积过于庞大，让阅读者很难提起阅读的兴趣。使用自然语言几句话便可以解释清楚，使用 <strong>JML</strong> 语言则动辄数十行。这一问题在第十一次作业中的 <strong>queryLeastMoments</strong> 方法和 <strong>sendMessage</strong> 中体现的尤为明显。前者由于描述了一个相对比较复杂的算法，在 <strong>ensures</strong> 中不停地嵌套语句导致可读性降低；后者是由于方法要处理的情况稍稍有些复杂导致 <strong>JML</strong> 代码的行数足足有六十行。我的做法是读一句翻译一句，将 <strong>JML</strong> 语言翻译成我能看懂的自然语言，但是这样一来就体会不到 <strong>JML</strong> 语言的优越性了。</li><li>如果使用自然语言描述方法，那么时隔多日再次回看依然能够快速理解方法要干什么；但是如果使用 <strong>JML</strong> 语言描述方法，别说时隔多日了，我一边写代码一边都要搞不懂 <strong>JML</strong> 在说些什么。这个问题在同第三点的两个方法中体现得淋漓尽致。</li><li>阅读和编写 <strong>JML</strong> 都需要花费额外的学习精力。单单阅读的话还好，编写出好的 <strong>JML</strong> 则非常需要透彻理解方法并且将方法前后方方面面考虑得仔细透彻才能够写出一个相对合格的 <strong>JML</strong> 代码。代价未免有些太大了。</li><li><strong>JML</strong> 增加了迭代难度。在原有函数添加新功能时，其 <strong>JML</strong> 往往会产生较大的变化，导致阅读者不得不重新开始阅读整个 <strong>JML</strong>，特别是随着功能的增加，<strong>JML</strong> 代码长度的增加将导致可读性的降低。</li></ol><p>此外写第十一次作业的时候给我一种强烈的写算法题的感觉。这个感觉主要来源于最短环算法的复杂性。如果完全按照课程组的数据范围，则一般的算法难以满足课程组的要求。我们不敢赌课程组的数据强度，也不敢赌到底怎样的时间复杂度能够满足课程组的要求。在这种情况下，我们只好尽可能卷算法。感觉本单元对算法的考察远大于前两个单元（第二单元最复杂的是最短路，远比最短环简单），不知道课程组在单元初说的 <em>“本单元对算法的考察有所减弱，希望大家不要卷错方向~”</em> 体现在哪里。</p><h2 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h2><p>在本单元中大量使用了 <strong>HashMap</strong>，在第十一次作业中还使用了 <strong>PriorityQueue</strong>，让我对 <strong>Java</strong> 对这两种数据结构的支持有了更深入的理解。同时也学会了使用迭代器遍历数组等，以及使用 <strong>removeIf()</strong> 等简化循环的小技巧。通过一些课外的扩展对 <strong>Java</strong> 的一些语言特性有了更深入了认知，可以说这段日子我对 <strong>Java</strong> 的理解更加深入了。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> JML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW10</title>
      <link href="/2023/05/17/OO-hw10/"/>
      <url>/2023/05/17/OO-hw10/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次作业增加了 <strong>Message</strong>，<strong>Group</strong> 两个类。 <strong>NetWork</strong> 中增加了配套的一系列方法。并在原有的关系上增加了 <strong>modifyRelation</strong> 方法。</p><h2 id="第十次作业设计"><a href="#第十次作业设计" class="headerlink" title="第十次作业设计"></a>第十次作业设计</h2><p><strong>Message</strong> 没什么好说的，按着规格写就可以了。</p><p><strong>Group</strong> 类涉及到了 <strong>ageVar</strong> 的查询操作，采取动态维护策略即可。</p><p>要提一提的是 <strong>modifyRelation</strong> 方法。这个方法的作用是更改一对关系的值。如果更改后的值小于等于 <strong>0</strong>，则删除此对关系。</p><p>删除操作对于第九次作业中影响比较大的地方有并查集的维护和三角关系数量的维护。</p><p>对于并查集的维护：</p><p>朴素的思想是每次删边都重建并查集。但是考虑到每次建立并查集的复杂度为 <strong>O(\nlog(n))</strong>，每次删边都重建并查集是有很大概率会 <strong>t</strong> 的。于是我引入了一个 <strong>dirty</strong> 位。当发生了删边操作时，将 <strong>dirty</strong> 位置真。当涉及到查询并查集的操作时（即 <strong>isCircle</strong> 和 <strong>queryBlockSum</strong>），若 <strong>dirty</strong> 位为真，则重建并查集，否则直接查询。</p><p>对于三角关系的维护：</p><p>我的做法是将每一组三元关系保存下来（手写了一个 <strong>Tuple</strong> 类），当删边操作发生时，遍历所有三元关系，若三元对中包含了删边的两个点，则将此三元关系移除，并将 <strong>cntTriple</strong> 减一。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> disjoinSetDirty;        <span class="comment">// 脏位</span></span><br><span class="line"></span><br><span class="line">modifyRelation() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ... do sth</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*cond*/</span>) &#123;             <span class="comment">// 发生了删边操作</span></span><br><span class="line">        delCircle();            <span class="comment">// 维护三角形边数</span></span><br><span class="line">        disjoinSetDirty = <span class="literal">true</span>; <span class="comment">// 维护脏位</span></span><br><span class="line">        <span class="comment">//  do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isCircle() &#123;</span><br><span class="line">    <span class="keyword">if</span> (disjoinSetDirty) &#123;</span><br><span class="line">        rebuildDisjointSet();   <span class="comment">// 重建并查集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queryBlockSum() &#123;</span><br><span class="line">    <span class="keyword">if</span> (disjoinSetDirty) &#123;</span><br><span class="line">        rebuildDisjointSet();   <span class="comment">// 重建并查集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OKTest"><a href="#OKTest" class="headerlink" title="OKTest"></a>OKTest</h2><p>本次作业要求对 <strong>modifyRelation</strong> 方法进行 <strong>OKTest</strong> 测试。总共需要对输入输出进行 <strong>21</strong> 条规格测试。测试量比较大，写起来的难度相对也比较大。需要十分的仔细以及对 <strong>OKTest</strong> 进行充分的测试才能够保证没有 <strong>bug</strong>。</p><h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><p>本次作业在写 <strong>OKTest</strong> 的时候因为疏忽写出了几个 <strong>bug</strong>，所幸都通过做测试找到了，因此在强测和互测中没有被刀到。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次作业的难度有所增加，但由于正巧遇上了五一假期，所以时间比较充裕，进行写代码和测试的时间都比较充足。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> JML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW9</title>
      <link href="/2023/05/16/OO-hw9/"/>
      <url>/2023/05/16/OO-hw9/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本单元主要做的事情是读 <strong>JML</strong> 并且按照 <strong>JML</strong> 描述的规格编写对应的代码。在代码难度上较前两个单元有所下降，但是耗费的时间不一定比前两个单元少…</p><h2 id="第九次作业设计"><a href="#第九次作业设计" class="headerlink" title="第九次作业设计"></a>第九次作业设计</h2><p>虽然是按着 <strong>JML</strong> 写代码，但是具体的实现方式完全由自己决定，<strong>JML</strong> 只是规定了你要实现什么，没有说你要怎么做。</p><p>第九次作业中实现了以下几个类：</p><ul><li>NetWork：社交网络类</li><li>Person：人员类</li></ul><p>人们处于同一个社交网络中，人和人之间可能有 “好友” 关系。本次作业中主要要实现的 <strong>NetWork</strong> 功能有：</p><ul><li>addPerson：向社交网络中添加一个人</li><li>addRelation：建立两个人之间的关系</li><li>queryValue：查询两个人的关系值</li><li>isCircle：查询两个人之间是否有好友链</li><li>queryBlockSum：查询有几个不同的好友链</li><li>queryTripleSum：查询有几对三角关系（三个人之间相互认识）</li></ul><p>在 <strong>Person</strong> 中要实现 <strong>id-value</strong> 的映射，在 <strong>NetWork</strong> 中要实现 <strong>id-person</strong> 的映射。很自然地使用 <strong>HashMap</strong> 来存储这两组键值关系。</p><p>此外实现了一个并查集来存储人员之间的关系。当两个人建立关系时，将此二人塞到同一颗树下。这样查询两个人直接是否有好友链和查询有几个不同的好友链时都可以直接查询，无需额外的时间开销。</p><p>针对三角关系的查询，采取了动态维护的策略。比如说，当建立 $A$ 与 $B$ 的关系时，遍历 $A$ 的所有熟人 $C_i$，若 $C_i$ 与 $B$ 之间有关系则让计数加一。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集</span></span><br><span class="line">DisjoinSet:</span><br><span class="line">merge();        <span class="comment">// 合并</span></span><br><span class="line">addPerson();    <span class="comment">// 添加人</span></span><br><span class="line">find();         <span class="comment">// 以上均为并查集内函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> blockSum;   <span class="comment">// 好友链数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merge: blockSum--;</span><br><span class="line"><span class="keyword">if</span> addPerson: blockSum++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 社交网络</span></span><br><span class="line">NetWork:</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cntTriple;</span><br><span class="line"></span><br><span class="line">addPerson(person1, person2):</span><br><span class="line">    <span class="keyword">for</span> person in person1.acquaintance</span><br><span class="line">        <span class="keyword">if</span> <span class="title function_">isCircle</span><span class="params">(person2, person)</span> </span><br><span class="line">            cntRtiple++;</span><br></pre></td></tr></table></figure><h2 id="OKTest"><a href="#OKTest" class="headerlink" title="OKTest"></a>OKTest</h2><p>本次作业的 <strong>OKTest</strong> 是对 <strong>queryTripleSum</strong> 进行 <strong>OKTest</strong>。由于只需要判断结果是否正确，因此在保证自己代码正确的前提下，可以直接将输入输出塞到自己的 <strong>netWork</strong> ，输出出来做比较。</p><h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><p>本次作业完成的比较顺利，没有遇到什么 <strong>bug</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次作业作为第三单元的初次作业，难度并不大。主要难点在于理解 <strong>JML</strong> 上。由于指导书写的过于扑朔迷离，所以不得不仔细阅读 <strong>JML</strong> 才能写完代码。但是官方 <strong>JML</strong> 存在一些问题，对同学们造成了一些困扰。造成了不太良好的写题体验。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> JML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW5</title>
      <link href="/2023/03/25/OO-hw5/"/>
      <url>/2023/03/25/OO-hw5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>电梯月来咯~</p><p>虽然本单元理论上应该写多线程，但是我却采用了状态机逻辑…虽然这可能与训练目标不太一样，不过是正确的就好辣~</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>经过仔细地评估、设计后，我的代码中除了 <code>MainClass</code> 外只包含四个类。类图如下所示：</p><p><img src="https://pic.imgdb.cn/item/64200f56a682492fccac5c58.jpg" alt="类图"></p><ul><li><strong>Request</strong>：请求</li><li><strong>Building</strong>：楼</li><li><strong>Elevator</strong>：电梯</li><li><strong>Passenger</strong>：乘客</li></ul><h2 id="对各类的分析与评估"><a href="#对各类的分析与评估" class="headerlink" title="对各类的分析与评估"></a>对各类的分析与评估</h2><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>本类占据一个线程，负责拉取乘客的请求。</p><p>评价：没啥好说的。</p><h3 id="Building"><a href="#Building" class="headerlink" title="Building"></a>Building</h3><p>本类占据一个线程，负责六部电梯的运行以及分配乘客请求给电梯。</p><p>方法介绍：</p><h4 id="step"><a href="#step" class="headerlink" title="step"></a>step</h4><p>使状态机前进一个周期。</p><h4 id="isEnd"><a href="#isEnd" class="headerlink" title="isEnd"></a>isEnd</h4><p>判断状态机整体是否运行完毕。</p><h4 id="elevatorEnd"><a href="#elevatorEnd" class="headerlink" title="elevatorEnd"></a>elevatorEnd</h4><p>判断各个电梯是否运行完毕。</p><h4 id="pasAlloc"><a href="#pasAlloc" class="headerlink" title="pasAlloc"></a>pasAlloc</h4><p>尝试将乘客分配给电梯，分配失败返回 <strong>false</strong>。</p><h4 id="findNearEmpty"><a href="#findNearEmpty" class="headerlink" title="findNearEmpty"></a>findNearEmpty</h4><p>寻找与目标楼层最近的空电梯。</p><h4 id="Building评价"><a href="#Building评价" class="headerlink" title="Building评价"></a>Building评价</h4><p>本类是状态机的核心类。有关状态机的逻辑都包含在本类之中。</p><h3 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h3><p>电梯类。负责电梯的具体行为。</p><p>对于电梯，我具有两个乘客队列：<strong>tasks</strong> 队列中的乘客未入梯但是已被分配给这个电梯；<strong>passengers</strong> 队列中的乘客则已经进入了这个电梯。</p><p>在判断能否接客时，采用一个桶子（即属性 <strong>cnt</strong>）记载电梯的占用情况。</p><p>方法介绍：</p><h4 id="tryOpen"><a href="#tryOpen" class="headerlink" title="tryOpen"></a>tryOpen</h4><p>尝试开门操作。</p><h4 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h4><p>尝试进行关门、开门操作。</p><h4 id="move"><a href="#move" class="headerlink" title="move"></a>move</h4><p>尝试进行移动操作。</p><h4 id="ifCarry"><a href="#ifCarry" class="headerlink" title="ifCarry"></a>ifCarry</h4><p>判断电梯是否可以接受该乘客。（主要从容量方面考虑该乘客是否能买到“票”）</p><h4 id="ifPassingly"><a href="#ifPassingly" class="headerlink" title="ifPassingly"></a>ifPassingly</h4><p>判断电梯是否可以捎带该乘客。</p><h4 id="Elevator评价"><a href="#Elevator评价" class="headerlink" title="Elevator评价"></a>Elevator评价</h4><p>本类是电梯类，承载了电梯的所有行为逻辑。</p><h3 id="Passenger"><a href="#Passenger" class="headerlink" title="Passenger"></a>Passenger</h3><p>本类是乘客类，记录了一个乘客所包含的所有信息。</p><p>对于乘客的 <strong>state</strong>（状态）定义如下：</p><ul><li><strong>0</strong>：乘客尚未进入电梯</li><li><strong>1</strong>：乘客已经进入电梯</li></ul><p>没啥好评价的，普普通通的乘客类。</p><h2 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a>运行逻辑</h2><p>电梯的忙碌状态定义：</p><ul><li><strong>free</strong>：电梯中没有乘客且任务队列为空。</li><li><strong>empty</strong>：电梯中没有乘客但任务队列非空。</li><li><strong>busy</strong>：电梯中存在乘客。</li></ul><p>电梯的运行状态（<strong>action</strong>）定义：</p><ul><li><strong>true</strong>：本轮时钟周期可以进行行动。</li><li><strong>false</strong>：本轮时钟周期已经行动过了，不能进行行动。</li></ul><p><strong>Building</strong> 在初始化时会创建六个电梯。</p><p>一个时钟周期设置为 <strong>400ms</strong>。</p><p>每轮时钟周期首先尝试给电梯分配任务。分配完任务后电梯的运行逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Elevator elevator: elevators) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!elevator.isFree() || elevator.isOpen()) &#123;</span><br><span class="line">        elevator.init(); <span class="comment">// 将 action 置为 true</span></span><br><span class="line">        elevator.operator();</span><br><span class="line">        elevator.move();</span><br><span class="line">        elevator.tryOpen(); <span class="comment">// 到了一层后可以尝试开门</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>始终步进直至达到停止条件。</p><h2 id="移动策略"><a href="#移动策略" class="headerlink" title="移动策略"></a>移动策略</h2><p>首先需要保证每时每刻都保证电梯的乘客队列和任务队列中所有请求的方向（下文简称为请求方向）是一致的（由调度保证）。</p><p>电梯在运行共分为三个状态：</p><p><strong>FREE</strong>：保持不动</p><p><strong>EMPTY</strong>：前往最底部的请求所处的楼层（如果请求方向是上则要尽可能去更低的楼层开始接人，反之同理）。</p><p><strong>BUSY</strong>：保持当前运行方向直至所有乘客都到达了目的地。</p><h2 id="乘客分配策略"><a href="#乘客分配策略" class="headerlink" title="乘客分配策略"></a>乘客分配策略</h2><p>首先尝试将乘客分配给电梯捎带。</p><p>这里的捎带分为两种情况：</p><ul><li>对于 <strong>empty</strong> 的电梯：<ul><li>乘客与电梯运行方向一致时：待分配的乘客与电梯当前运行方向相同，且电梯尚未运行到乘客起始楼层，且电梯容量足够，则判断为可捎带。</li><li>乘客与电梯运行方向不一致时：待分配的乘客与电梯任务队列中的乘客的请求方向一致，且电梯容量足够，则判断为可捎带。</li></ul></li><li>对于 <strong>busy</strong> 的电梯：待分配的乘客与电梯当前运行方向相同，且电梯尚未运行到乘客起始楼层，且电梯容量足够，则判断为可捎带。</li></ul><p>若无法捎带，则分配给最近的<strong>空电梯</strong>。这里的空电梯指电梯处于 <strong>free</strong> 状态，即乘客队列与任务队列均为空。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Building.Building(int, ArrayList\<Passenger>, Request)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Building.elevatorEnd()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.findNearEmpty(int)</td><td>6.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Building.isEnd()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Building.pasAlloc(Passenger)</td><td>4.0</td><td>4.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Building.run()</td><td>3.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.step()</td><td>7.0</td><td>1.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Elevator.carry(Passenger)</td><td>6.0</td><td>1.0</td><td>1.0</td><td>4.0</td></tr><tr><td>Elevator.checkBegin()</td><td>5.0</td><td>2.0</td><td>4.0</td><td>6.0</td></tr><tr><td>Elevator.checkTop()</td><td>2.0</td><td>1.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Elevator.close()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.closeDoor()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.Elevator(int, int, int, int, int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Elevator.findBottom()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.findTop()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.getFloor()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.ifCarry(Passenger)</td><td>12.0</td><td>6.0</td><td>1.0</td><td>6.0</td></tr><tr><td>Elevator.ifOut()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Elevator.ifOut(Passenger)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.ifPassingly(Passenger)</td><td>6.0</td><td>5.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Elevator.ifTake()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Elevator.ifTake(Passenger)</td><td>1.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.init()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEmpty()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEnd()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isFree()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isOpen()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.move()</td><td>13.0</td><td>2.0</td><td>4.0</td><td>7.0</td></tr><tr><td>Elevator.open()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.operator()</td><td>7.0</td><td>2.0</td><td>5.0</td><td>6.0</td></tr><tr><td>Elevator.takeOn()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.takeOn(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.takeOut()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.takeOut(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.tryOpen()</td><td>3.0</td><td>2.0</td><td>2.0</td><td>4.0</td></tr><tr><td>MainClass.main(String[])</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getDirection()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getFinish()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getId()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getStart()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.isTake()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.Passenger(int, int, int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Passenger.takeOn()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Request.getRequest()</td><td>4.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Request.isEnd()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Request.Request(ArrayList\<Passenger>)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Request.run()</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Total</td><td>111.0</td><td>73.0</td><td>95.0</td><td>122.0</td></tr><tr><td>Average</td><td>2.3125</td><td>1.5208333333333333</td><td>1.9791666666666667</td><td>2.5416666666666665</td></tr></tbody></table></div><p>本次作业类之间关系比较简单，总体上有高内聚，低耦合的特点。</p><h2 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h2><p>本次作业出了一个很离谱的 <strong>bug</strong>。我竟然忘记在下客人的时候维护桶子了。太悲伤了……</p><p>最后寄了三个点，都是 <strong>tle</strong>。因为这个 <strong>bug</strong> 会极大的影响我的性能，但是不会影响正确性。（最后就会变成只有空电梯才能接客，而不能捎带客人，从而 <strong>tle</strong> 掉。）</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 电梯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW3</title>
      <link href="/2023/03/08/OO-hw3/"/>
      <url>/2023/03/08/OO-hw3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是面向对象课程的第三次作业总结博客。在第二次作业上进行了一定的迭代开发。工作量相比第二次作业而言并不大。</p><p>相较于第二次作业，本次作业实现的功能有：实现求导算子。</p><p>因为只需要实现一个功能，从任务量和难度来讲都是三次作业中最简单的一次。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>经过迭代后第三次作业的类图如下所示：</p><p><img src="https://pic.imgdb.cn/item/64113ff7ebf10e5d538ed335.jpg" alt="类图"></p><p>本次迭代中涉及的工作有：</p><ul><li><strong>Expr</strong>、<strong>Term</strong>、<strong>Var</strong> 新增了求导方法（<strong>Expr</strong> 的求导方法处于 <strong>Tool</strong> 类中）。</li><li><strong>Parser</strong> 新增了求导算子语法分析方法。</li><li>对自定义函数的构造方法进行了一定的调整。</li><li>对预处理函数进行了一些调整</li></ul><h2 id="对预处理的调整"><a href="#对预处理的调整" class="headerlink" title="对预处理的调整"></a>对预处理的调整</h2><p>主要调整是将 <strong>dx</strong> 替换为了 <strong>1*dx</strong>，这样可以保证解析到求导算子时处在 <strong>Term</strong> 的解析过程中。</p><h2 id="求导实现思路"><a href="#求导实现思路" class="headerlink" title="求导实现思路"></a>求导实现思路</h2><p>在遇到求导算子 <strong>dx/y/z</strong> 时，对其管辖的表达式进行语法分析。分析结束后对得到的表达式调用表达式求导函数得到求导后的表达式，后续处理与括号解析相同。</p><p>对于出现在自定义函数中的求导算子，我的处理是对自定义函数的表达式调用表达式语法分析，对表达式进行展开、化简操作，再进行形参替换。</p><h3 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h3><p>对于 <strong>Expr</strong> 就是对其中每个 <strong>Term</strong> 都进行求导。采取循环即可，在循环过程中对每一项都进行求导。此3方法位于工具类 <strong>Tool</strong> 中。</p><h3 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h3><p>对于 <strong>Term</strong> 的求导主要考虑乘法法则。考虑到 <strong>(f(x)*g(x)*h(x))’=f(x)’*(g(x)*h(x))+f(x)*(g(x)*h(x))’=…</strong>，采用递归的方法解析。伪代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Term&gt; termDerivative</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">terms</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.vars.size == <span class="number">1</span>                  <span class="comment">// 当只剩下一项的时候</span></span><br><span class="line">        add vars[<span class="number">0</span>].derivative to terms     <span class="comment">// 返回原子项的求导结果</span></span><br><span class="line">        <span class="keyword">return</span> terms</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        add <span class="title function_">mul</span><span class="params">(<span class="built_in">this</span>.vars[<span class="number">0</span>].derivative, <span class="built_in">this</span>.vars[<span class="number">1</span>,])</span> to terms <span class="comment">// 前导后不导</span></span><br><span class="line">        add <span class="title function_">mul</span><span class="params">(<span class="built_in">this</span>.vars[<span class="number">0</span>], <span class="built_in">this</span>.vars[<span class="number">1</span>,].derivative)</span> to terms <span class="comment">// 前不导后导</span></span><br><span class="line">        <span class="keyword">return</span> terms </span><br></pre></td></tr></table></figure><h3 id="Var"><a href="#Var" class="headerlink" title="Var"></a>Var</h3><p>对于 <strong>Var</strong> 的求导，分为三种情况：</p><ol><li>常数求导返回零</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.442ex" height="1.553ex" role="img" focusable="false" viewBox="0 -675.5 1079.3 686.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(605,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container> 返回 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="7.981ex" height="1.912ex" role="img" focusable="false" viewBox="0 -833.9 3527.4 844.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="msup" transform="translate(1544.4,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="TeXAtom" transform="translate(605,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></g></svg></mjx-container></li><li>三角函数返回三角函数求导后的值。</li></ol><p>其中对三角函数的求导举例：</p><script type="math/tex; mode=display">(sin^n(Expr))'=n*sin^{n-1}(Expr)*cos(Expr)*(Expr)'</script><h2 id="类复杂度分析"><a href="#类复杂度分析" class="headerlink" title="类复杂度分析"></a>类复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CgoC</th><th>ev</th><th>iv</th><th>v</th></tr></thead><tbody><tr><td>Expr.equals(Expr)</td><td>16</td><td>5</td><td>5</td><td>9</td></tr><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.Expr(ArrayList)</td><td>2</td><td>2</td><td>2</td><td>3</td></tr><tr><td>Expr.getTerms()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.toString()</td><td>6</td><td>3</td><td>5</td><td>5</td></tr><tr><td>Function.call(String)</td><td>9</td><td>1</td><td>6</td><td>7</td></tr><tr><td>Function.Function(String, ArrayList)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Function.getState()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Function.toString()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getFunction()</td><td>5</td><td>1</td><td>2</td><td>4</td></tr><tr><td>Lexer.getNumber()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.next()</td><td>9</td><td>2</td><td>6</td><td>8</td></tr><tr><td>Lexer.peek()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MainClass.main(String[])</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Parser.cket(ArrayList)</td><td>4</td><td>2</td><td>3</td><td>3</td></tr><tr><td>Parser.parseDerivation(ArrayList)</td><td>4</td><td>2</td><td>3</td><td>3</td></tr><tr><td>Parser.parseExpr()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Parser.parseFunction(ArrayList, String)</td><td>7</td><td>4</td><td>5</td><td>5</td></tr><tr><td>Parser.Parser(Lexer, ArrayList)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.parseTerm()</td><td>14</td><td>1</td><td>11</td><td>11</td></tr><tr><td>Parser.parseVar()</td><td>23</td><td>7</td><td>11</td><td>15</td></tr><tr><td>Term.add(Term)</td><td>9</td><td>3</td><td>5</td><td>7</td></tr><tr><td>Term.addVar(Var)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Term.addVars(Term)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Term.copy()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.equals(Term)</td><td>17</td><td>6</td><td>5</td><td>10</td></tr><tr><td>Term.getConstant()</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>Term.getSymbol()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.setSymbol()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Term.setSymbol(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.similar(Term)</td><td>39</td><td>13</td><td>15</td><td>21</td></tr><tr><td>Term.simplify()</td><td>23</td><td>5</td><td>13</td><td>14</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.Term(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.Term(Var)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.termDerivative(Character)</td><td>6</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Term.toString()</td><td>6</td><td>3</td><td>3</td><td>6</td></tr><tr><td>Tool.afterTreat(String)</td><td>3</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Tool.exprDerivative(ArrayList, Character)</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Tool.exprSimplify(ArrayList)</td><td>8</td><td>2</td><td>5</td><td>6</td></tr><tr><td>Tool.mul(ArrayList, ArrayList)</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Tool.mul(ArrayList, Term)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Tool.mul(Term, Term)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Tool.preTreat(String)</td><td>2</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Tool.removeSpace(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.addAbs(Var)</td><td>2</td><td>2</td><td>1</td><td>3</td></tr><tr><td>Var.copy()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.equals(Var)</td><td>5</td><td>4</td><td>3</td><td>6</td></tr><tr><td>Var.getCharacter()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.getExpr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.getIndex()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.getNum()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Var.getSymbol()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.getType()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.setSymbol(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.simplify()</td><td>8</td><td>4</td><td>5</td><td>8</td></tr><tr><td>Var.subAbs(Var)</td><td>2</td><td>2</td><td>1</td><td>3</td></tr><tr><td>Var.toString()</td><td>11</td><td>6</td><td>7</td><td>10</td></tr><tr><td>Var.Var(int)</td><td>1</td><td>1</td><td>1</td><td>2</td></tr><tr><td>Var.Var(int, BigInteger, Character, int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.Var(int, BigInteger, Character, int, int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.Var(int, BigInteger, Character, int, int, ArrayList)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.Var(int, BigInteger, int, int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.Var(int, Character, int, int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.Var(int, int, int, ArrayList)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.varDerivative(Character)</td><td>15</td><td>3</td><td>6</td><td>8</td></tr><tr><td>Total</td><td>276</td><td>131</td><td>201</td><td>249</td></tr><tr><td>Average</td><td>4.119402985</td><td>1.955223881</td><td>3</td><td>3.71641791</td></tr></tbody></table></div><p><img src="https://pic.imgdb.cn/item/6411fa49ebf10e5d5330ecbe.png" alt="复杂度分析"></p><p>本次迭代后复杂度并没有额外的增加。整体上基本与第二次作业相同。</p><h2 id="bug-分析"><a href="#bug-分析" class="headerlink" title="bug 分析"></a>bug 分析</h2><p>本次作业并没有发现 <strong>bug</strong>。</p><h2 id="hack-策略"><a href="#hack-策略" class="headerlink" title="hack 策略"></a>hack 策略</h2><p>整体上 <strong>hack</strong> 以跑评测机为主，手动构造数据为辅。</p><p>值得一提的是在互测过程中成功刀到了 <strong>TLE</strong> 与 <strong>MLE</strong>。出刀的过程中包含了各种卡着代价上限的微调…结果是成功爆了一个人的时间与另一个人的堆，给我留下了珍贵的回忆。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>拜整体还算是优良的架构所赐，第三次作业的难度可谓是三次作业中最简单的。经验是在编程过程中，优良的架构设计是很重要的。在写出屎山代码时要勇于重构，不要尝试在屎山上添砖加瓦。</p><p>因为没有参加 <strong>OOpre</strong>，所以在写第一次作业的过程中遇到了莫大的困难，当时的心态也受到了莫大的影响。很希望课程组以后会改进这一点，要么不要取消寒假的 <strong>OOpre</strong>，要么把 <strong>OOpre</strong> 课程变成大二上的必修课。</p><p>另外是互测刀的很爽（逃），但是个人感觉代价的设定有点太严苛了，过于严苛的代价设定让本来是比较合理的 <strong>hack</strong> 都无法通过合法性检验，比较影响刀人体验。</p><p>第一单元的学习还是很有遗憾的，比如第一次作业强测直接寄的经历呜呜呜。</p><p>特别感谢 <strong>Toby</strong> 和 <strong>sheep</strong> 对我学习的帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 计算器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW2</title>
      <link href="/2023/03/04/OO-hw2/"/>
      <url>/2023/03/04/OO-hw2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相较于第一次作业，第二次作业进行迭代开发主要完成的功能有：</p><ol><li>支持三角函数</li><li>支持自定义函数</li></ol><p>括号嵌套在第一次作业中就已经实现。</p><hr><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><strong>hw2</strong> 的类图如下所示：</p><p><img src="https://pic.imgdb.cn/item/64023415f144a0100761b22e.jpg" alt="类图"></p><p>本次迭代中主要涉及到的工作有：</p><ul><li>新增了 <strong>Function</strong> 类，用于存储自定义函数的定义并作为 <strong>Parser</strong> 的属性参与解析过程。</li><li>在 <strong>Var</strong> 类中新增了属性 <strong>exprs</strong>，用于存储三角函数的表达式。</li><li>对 <strong>Expr</strong>、<strong>Term</strong>、<strong>Var</strong> 三个类新增了 <strong>equals()</strong> 方法。</li><li>对 <strong>Parser</strong> 类新增了 <strong>parseBracket()</strong> 用于专门解析括号，<strong>parseFunction()</strong> 用于专门解析函数。</li><li>对 <strong>Lexer</strong> 类增加了识别 <strong>Function</strong> 的方法：<strong>getFunction()</strong>。</li><li>对预处理函数进行了若干调整。</li></ul><h2 id="迭代思路"><a href="#迭代思路" class="headerlink" title="迭代思路"></a>迭代思路</h2><h3 id="处理三角函数"><a href="#处理三角函数" class="headerlink" title="处理三角函数"></a>处理三角函数</h3><p>首先，将三角函数作为一项新的属性添加到了原子项当中。</p><p>在视图中，三角函数内部包含一个表达式。判断两个三角函数是否相等即等价于判断其内部的表达式是否相等。于是对 <strong>Expr</strong>、<strong>Term</strong>、<strong>Var</strong> 三个类中添加了 <strong>equals()</strong> 方法。</p><p>解析三角函数等价于解析括号内部表达式。将解析得到的表达式添加至三角函数内即可。</p><p>并没有对三角函数作出很强的优化。仅做了类似 <strong>sin(0)</strong> 等于 <strong>0</strong> 这样的简单化简。</p><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>本类是第二次作业中新增的类，用于处理、解析、调用函数。</p><p>本类主要包含构造函数和调用函数。</p><p>在构造过程中，将函数表达式进行格式化处理。举例而言：<code>f(x,y)=sin(x**2)+y</code> 经处理后，解析得到 <code>sin(($0)**2)+($1)</code> 存储进 <strong>function</strong> 的 <strong>expr</strong> 中。</p><p>在调用方法，调用流程如下：</p><ol><li>识别实参列表。</li><li>将 <strong>$n</strong> 替换成对应的实参。</li><li>传回替换实参后的字符串。</li></ol><h3 id="自定义函数解析"><a href="#自定义函数解析" class="headerlink" title="自定义函数解析"></a>自定义函数解析</h3><p>在 <strong>Parser</strong> 类中新增了 <strong>parseFunction()</strong> 方法用于解析表达式中的函数。</p><p>在解析过程中，首先进行函数的调用得到替换实参后的字符串，之后对字符串进行表达式解析，再传回解析得到的表达式。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>对预处理函数的主要处理有：将 <strong>cos1*(</strong> 、<strong>sin1*(</strong>、<strong>f1*(</strong> 等替换成 <strong>cos(</strong>、<strong>sin(</strong>、<strong>1*f(</strong>。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Expr.addTerm(Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.addTerms(ArrayList\<Term>)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.equals(Expr)</td><td>16.0</td><td>5.0</td><td>5.0</td><td>9.0</td></tr><tr><td>Expr.Expr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.Expr(ArrayList\<Term>)</td><td>2.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Expr.getTerms()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.toString()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Function.call(String)</td><td>9.0</td><td>1.0</td><td>6.0</td><td>7.0</td></tr><tr><td>Function.Function(String)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Function.getExpr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Function.getState()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Function.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.getFunction()</td><td>5.0</td><td>1.0</td><td>2.0</td><td>4.0</td></tr><tr><td>Lexer.getNumber()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Lexer.Lexer(String)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.next()</td><td>8.0</td><td>2.0</td><td>5.0</td><td>7.0</td></tr><tr><td>Lexer.peek()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>MainClass.main(String[])</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseBracket(ArrayList\<Term>)</td><td>4.0</td><td>2.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Parser.parseExpr()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Parser.parseFunction(ArrayList\<Term>, String)</td><td>7.0</td><td>4.0</td><td>5.0</td><td>5.0</td></tr><tr><td>Parser.Parser(Lexer, ArrayList\<Function>)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseTerm()</td><td>13.0</td><td>1.0</td><td>10.0</td><td>10.0</td></tr><tr><td>Parser.parseVar()</td><td>23.0</td><td>7.0</td><td>11.0</td><td>15.0</td></tr><tr><td>Term.add(Term)</td><td>9.0</td><td>3.0</td><td>5.0</td><td>7.0</td></tr><tr><td>Term.addVar(Var)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.addVars(ArrayList\<Var>)</td><td>2.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Term.addVars(Term)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.copy()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.equals(Term)</td><td>17.0</td><td>6.0</td><td>5.0</td><td>10.0</td></tr><tr><td>Term.getConstant()</td><td>3.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Term.getSymbol()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.setSymbol()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.setSymbol(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.similar(Term)</td><td>39.0</td><td>13.0</td><td>15.0</td><td>21.0</td></tr><tr><td>Term.simplify()</td><td>23.0</td><td>5.0</td><td>13.0</td><td>14.0</td></tr><tr><td>Term.Term()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term(Var)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.toString()</td><td>6.0</td><td>3.0</td><td>3.0</td><td>6.0</td></tr><tr><td>Tool.afterTreat(String)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Tool.exprSimplify(ArrayList\<Term>)</td><td>8.0</td><td>2.0</td><td>5.0</td><td>6.0</td></tr><tr><td>Tool.mul(ArrayList\<Term>, ArrayList\<Term>)</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Tool.mul(Term, Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Tool.preTreat(String)</td><td>2.0</td><td>1.0</td><td>5.0</td><td>5.0</td></tr><tr><td>Tool.removeSpace(String)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.addAbs(Var)</td><td>2.0</td><td>2.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Var.copy()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.equals(Var)</td><td>5.0</td><td>4.0</td><td>3.0</td><td>6.0</td></tr><tr><td>Var.getCharacter()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getExpr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getIndex()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getNum()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Var.getSymbol()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getType()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.setSymbol(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.simplify()</td><td>8.0</td><td>4.0</td><td>5.0</td><td>8.0</td></tr><tr><td>Var.subAbs(Var)</td><td>2.0</td><td>2.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Var.toString()</td><td>9.0</td><td>4.0</td><td>7.0</td><td>9.0</td></tr><tr><td>Var.Var(int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Var.Var(int, BigInteger, Character, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, BigInteger, Character, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, BigInteger, Character, int, int, ArrayList\<Term>)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, BigInteger, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, Character, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>239.0</td><td>121.0</td><td>179.0</td><td>225.0</td></tr><tr><td>Average</td><td>3.6769230769230767</td><td>1.8615384615384616</td><td>2.753846153846154</td><td>3.4615384615384617</td></tr></tbody></table></div><p><img src="https://pic.imgdb.cn/item/6411e83debf10e5d530c5265.png" alt="复杂度分析"></p><p>可以看到在添加了三角函数后 <strong>Term</strong> 类的 <strong>similar</strong> 方法复杂度直接爆炸了…这主要是因为对三角函数的判断逻辑比较复杂。此外对原子项的语法解析也因为三角函数的加入而变得稍显臃肿。考虑改进的话可以将对三角函数的语法解析提取到单独的类中。</p><h2 id="bug-分析"><a href="#bug-分析" class="headerlink" title="bug 分析"></a>bug 分析</h2><p>第二次作业的构建过程中没有遇到什么特别的 <strong>bug</strong>。强测互测也都顺利通过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第二周的压力比第一周小了很多，仿佛一切都在步上正轨，令人欣慰。虽然一度为弱智 <strong>bug</strong> 所苦恼，不过跟第一周的坐牢比起来已经幸福太多了。并且由于第一周架构比较合理（貌似是），我在本次的迭代开发的过程中并未遇到什么困难，整体架构也几乎没有变动。唯一最大的困难就是我本人捉急的码力（悲）</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 计算器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW1</title>
      <link href="/2023/02/28/OO-hw1/"/>
      <url>/2023/02/28/OO-hw1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次 <strong>OO</strong> 作业经历过一次重构，而且重构的完成时间是在提交截止之后（哭）。所以强测寄的很惨，呜呜呜。（不过在房里刀的也很爽）</p><p>不过这份重构我个人是十分满意的。</p><p>特别感谢 <strong>sheep</strong> 和 <strong>toby</strong> 的帮助！</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>类图如下所示：</p><p><img src="https://pic.imgdb.cn/item/63fdb4d7f144a01007c743f6.jpg" alt="类图"></p><ul><li><strong>Expr</strong>：表达式</li><li><strong>Term</strong>：项</li><li><strong>Var</strong>：原子项</li><li><strong>Lexer</strong>：词法分析器</li><li><strong>Parser</strong>：语法分析器</li><li><strong>Tool</strong>：工具类</li></ul><p>注：图中省略了若干构造函数和获取类属性的接口。</p><h2 id="对各类的分析"><a href="#对各类的分析" class="headerlink" title="对各类的分析"></a>对各类的分析</h2><h3 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h3><p>本类作为词法解析器。<strong>peek()</strong> 方法可以取得当前解析得到的词汇。<strong>next()</strong> 方法会继续取得下一个词汇。当读取到句末时，继续使用 <strong>next()</strong> 将会读取到一个空格。</p><p>评价：中规中矩的词法解释器，基本是抄课程组的。</p><h3 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h3><p>本类是表达式。我对表达式的定义如下：</p><ul><li>表达式由至少一个项连接而成。</li><li>表达式本身不含符号，由各个项决定各自的符号。</li></ul><p>只有一个属性：<strong>ArrayList\<Term\></strong>，存储表达式内部的各个项。</p><p>具有 <strong>toString()</strong> 方法将表达式转换为字符串。</p><p>评价：或许应该将表达式乘法添加到其中。不过这样在运算过程中会涉及到一层额外的包装，可能有损性能。此外可以对表达式内部项进行排序，但是考虑到递归时可能带来的性能开销也作罢。</p><h3 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h3><p>本类是项。我对项的定义如下：</p><ul><li>项由至少一个原子项相乘得到。</li><li>项本身默认的符号为正。在化简过程中符号根据项内部原子项符号改变。</li><li>输出项时会输出项本身的符号。</li></ul><p>项包含两个属性：<strong>ArrayList\<Var\></strong> 和 <strong>symbol</strong>。<strong>arraylist</strong> 内存储实际的内容，<strong>symbol</strong> 内存储项本身的符号。</p><p>具有化简方法、设置符号方法、深拷贝方法、取得常数方法、判断是否相似方法。</p><p>评价：项的方法普遍比较复杂，这个类也是逻辑上最复杂的类。项的化简方法的复杂度相对也比较高。</p><h3 id="Var"><a href="#Var" class="headerlink" title="Var"></a>Var</h3><p>本类是原子项。我对原子项的定义如下：</p><ul><li>原子项要么是常数，要么是变量。</li><li>原子项含有幂次和符号。</li></ul><p>原子项包含的属性：<strong>type</strong> 用于决定原子项的类型（常数或变量），<strong>num</strong> 存储常数，<strong>character</strong> 存储变量，<strong>index</strong> 存储幂次，<strong>symbol</strong> 存储符号。</p><p>原子项具有加减的方法。（仅限于常数运算）</p><p>评价：写的时候脑子一抽写了很多不必要的重载构造方法。实际上第一次作业中只需要两个构造方法就够用了。本类在第一次作业中复杂度较低。</p><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>本类是语法分析类。进行语法分析工作。</p><ul><li><strong>parseExpr</strong>：对表达式进行语法分析。</li><li><strong>parseTerm</strong>：对项进行语法分析。括号的解析也将在这一层中进行。</li><li><strong>parseVar</strong>：分析原子项。</li></ul><p>其中对表达式和项的语法分析都会返回一个项的集合。对表达式的分析返回项的集合的原因不言而喻。对项的语法分析返回一个项的集合的原因如下：</p><ol><li>对括号的解析处在项这一级。</li><li>解析到括号时，由于括号内部是表达式，解析项会将这个括号展开，于是会得到一个项的集合。</li><li>在解析项的过程中各个项之间都是相乘的关系。</li></ol><p>评价：核心解析、化简流程皆在本类中进行。对括号的解析和对基本项的解析都可以新增方法以降低原有方法的复杂度。</p><h3 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h3><p>本类是工具类。包含了一些通用的工具：</p><ul><li>包含预处理和事后处理。</li><li>包含对乘法方法的重载。</li><li>包含表达式的化简方法。</li></ul><p>之所以将乘法的重载和表达式的化简方法置于 <strong>Tool</strong> 内部是考虑到在 <strong>Parser</strong> 类中主要通过 <strong>ArrayList\<Term\></strong> 的形式计算化简，所以需要在工具类中定义静态方法操作数组。</p><p>其中表达式化简的时机是在已经解析了表达式，返回表达式之前时。</p><p>评价：本类的方法全部是静态方法，供全局调用。重载了表达式与表达式、表达式与项之间的乘法。还做了必要的预处理和事后处理。预处理也可以说是化简流程中的一个精髓了。经过预处理后，无需考虑空格、连续符号的问题，对括号的解析流程也符合我自己定义的标准。</p><h2 id="化简流程"><a href="#化简流程" class="headerlink" title="化简流程"></a>化简流程</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理的流程：</p><ol><li>去除所有空字符</li><li>将 “(” 替换成 “1*(”</li><li>将所有连续的正负号化简成一个符号</li><li>将 “*+” 化简成 “*”</li><li>将 “**” 化简成 “^”</li></ol><p>经过预处理后，我们得到的字符串中没有任何的空白与连续的符号，并且乘方使用 “^” 表示后更加易于处理。</p><p>将括号前面添加 <strong>1*</strong> 是为了保证解析到括号时处于项的解析流程中。</p><p>使用 <strong>replaceAll()</strong> 正则替换就可以实现预处理。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将表达式视作 <strong>表达式->项->原子项</strong> 的结构。即：</p><ul><li>Expr = Term + Term</li><li>Term = Var * Var</li></ul><p>对于符号，解析时首先将符号读取至原子项中，在化简过程中将符号归一到其所属的项中。</p><p>对于括号，整个解析过程是边解析边化简的。具体而言，在读取到括号时我会将括号内部视作一个表达式进行解析，返回经过化简后的 <strong>ArrayList\<Term\></strong>（<strong>ArrayList\<Term\></strong> 与表达式在逻辑上是等价的）。</p><p>由于 <strong>ArrayList\<Term\></strong> 与表达式在逻辑上是等价的，故 <strong>parseExpr()</strong> 与 <strong>parseTerm()</strong> 的返回值都是 <strong>ArrayList\<Term\></strong>。后者之所以返回数组是为了支持括号的解析。</p><h3 id="处理括号"><a href="#处理括号" class="headerlink" title="处理括号"></a>处理括号</h3><p>遇到括号时，在 <strong>praseTerm()</strong> 中递归调用 <strong>praseExpr()</strong>。在 <strong>praseExpr()</strong> 中将括号内的表达式分析、化简完毕再回溯到 <strong>praseTerm()</strong>（此时 <strong>parseTerm()</strong> 就会返回多个 <strong>Term</strong>）。</p><p>举例而言：对于 <code>1+(x**2-1)*3</code>，经过预处理后：<code>1+1*(x**2-1)*3</code>，在读取到 “<strong>(</strong>” 时处于 <strong>parseTerm()</strong> 的调用中。经调用 <strong>parseExpr()</strong> 后得到一个 <strong>ArrayList\<Term\></strong>。之后接着读取处理后面的 <code>*3</code>，最后返回的 <strong>Term</strong> 数组中包含 <strong>3*x**2</strong>，<strong>-3</strong>。</p><h3 id="处理乘方"><a href="#处理乘方" class="headerlink" title="处理乘方"></a>处理乘方</h3><p>“^” 可能出现在 “xyz)” 的后面。于是在 <strong>praseVar()</strong> 中和 <strong>praseTerm()</strong> 中相应的位置直接进行分析、展开（暴力循环即可）。我使用 <strong>Var</strong> 中的一个属性 <strong>index</strong> 来存储原子项（<strong>xyz</strong> 与数字，不过数字的乘方采取直接计算的方法）的乘方。</p><h3 id="事后处理"><a href="#事后处理" class="headerlink" title="事后处理"></a>事后处理</h3><p>事后处理（ <strong>afterTreat</strong> ）的时候使用正则替换进行简单的优化。包括：</p><ol><li>将 “^” 展开为 “**”</li><li>将 “+1*” 化简为 “+”</li><li>将 “-1*” 化简为 “-”</li><li>去除首位的正号</li></ol><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Expr.addTerm(Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.addTerms(ArrayList\<Term\>)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.Expr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.Expr(ArrayList\<Term\>)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.toString()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Lexer.getNumber()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Lexer.Lexer(String)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.next()</td><td>3.0</td><td>2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Lexer.peek()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>MainClass.main(String[])</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseExpr()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseTerm()</td><td>19.0</td><td>1.0</td><td>9.0</td><td>9.0</td></tr><tr><td>Parser.parseVar()</td><td>8.0</td><td>3.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Term.add(Term)</td><td>7.0</td><td>1.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Term.addVar(Var)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.addVars(ArrayList\<Var\>)</td><td>2.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Term.addVars(Term)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.copy()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.getConstant()</td><td>3.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Term.getSymbol()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.setSymbol()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.setSymbol(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.similar(Term)</td><td>9.0</td><td>3.0</td><td>5.0</td><td>7.0</td></tr><tr><td>Term.simplify()</td><td>8.0</td><td>2.0</td><td>5.0</td><td>6.0</td></tr><tr><td>Term.Term()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term(Var)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.toString()</td><td>3.0</td><td>2.0</td><td>2.0</td><td>4.0</td></tr><tr><td>Tool.afterTreat(String)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Tool.exprSimplify(ArrayList\<Term>)</td><td>7.0</td><td>2.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Tool.mul(ArrayList\<Term>, ArrayList\<Term>)</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Tool.mul(Term, Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Tool.preTreat(String)</td><td>2.0</td><td>1.0</td><td>5.0</td><td>5.0</td></tr><tr><td>Var.addAbs(Var)</td><td>2.0</td><td>2.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Var.copy()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.equals(Var)</td><td>3.0</td><td>2.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Var.getCharacter()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getIndex()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getNum()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Var.getSymbol()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getType()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.setSymbol(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.similar(Var)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Var.simplify()</td><td>6.0</td><td>4.0</td><td>4.0</td><td>6.0</td></tr><tr><td>Var.subAbs(Var)</td><td>2.0</td><td>2.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Var.toString()</td><td>7.0</td><td>3.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Var.Var(int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Var.Var(int, BigInteger, Character, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, BigInteger, Character, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, BigInteger, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, Character, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>108.0</td><td>71.0</td><td>113.0</td><td>132.0</td></tr><tr><td>Average</td><td>2.076923076923077</td><td>1.3653846153846154</td><td>2.173076923076923</td><td>2.5384615384615383</td></tr></tbody></table></div><p><img src="https://pic.imgdb.cn/item/6411cb26ebf10e5d53c62e1f.png" alt="复杂度分析"></p><p>第一次作业类之间的耦合度不高，方法的复杂度也较低。其中对项的语法解析方法的复杂度较高。这是因为其中蕴含了对括号的分析。在之后的迭代过程中我将括号的解析拿到了新的方法中，降低了这一方法的复杂度。</p><h2 id="bug-分析"><a href="#bug-分析" class="headerlink" title="bug 分析"></a>bug 分析</h2><p>重构前的代码有一个 <strong>bug</strong>，是会将 <strong>-x**0</strong> 解析成 <strong>+1</strong>。但是在交完中测之后直接把第一版代码抛弃了，故没有具体分析 <strong>bug</strong> 出现的原因（本文也没有对初版代码进行分析）。重构后的代码（即当前分析的代码）没有遇到 <strong>bug</strong>。此后的迭代工作也都是基于这版代码进行的。</p><h2 id="hack-经验"><a href="#hack-经验" class="headerlink" title="hack 经验"></a>hack 经验</h2><p>因为交的代码比较寄所以去了 <strong>B</strong> 房…前两天还在忙着重构，最后只刀了一下午 <strong>+</strong> 一晚上。不过战绩还是可以的，总共中了 <strong>12</strong> 刀，经过修复后也拿了六分多的样子。</p><p><strong>hack</strong> 的时候可以先手动构造一些易错的数据。跑评测机测出大量错误数据后要精缩数据到代价范围内，并且也方便同学修复 <strong>bug</strong>。此外要把刀过的数据记录下来，防止刀同质数据。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 计算器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P7 回顾</title>
      <link href="/2023/01/05/BUAA-CO-P7/"/>
      <url>/2023/01/05/BUAA-CO-P7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做完前六 <strong>P</strong> 之后，我们已经做出来一个相当厉害的流水线了。在 <strong>P7</strong> 中，我们的任务是增加外部中断响应和异常处理。</p><p>本篇博客中我将结合我做 <strong>P7</strong> 的方法，按照我的搭建过程逐个讲解 <strong>P7</strong> 中所要完成的工作。</p><p>注：本篇博客记录的是 <strong>21</strong> 级的 <strong>P7</strong> 搭建过程。计组课程组每年都可能会对细节有一些改动。因此建议自行甄别内容。最终实现细节还请以教程为准。</p><h1 id="调整模块架构"><a href="#调整模块架构" class="headerlink" title="调整模块架构"></a>调整模块架构</h1><p>在 <strong>P7</strong> 中，我们需要对流水线的架构做一些调整。我们需要添加<strong>系统桥</strong>和两个<strong>计时器</strong>，这三个组件和我们在 <strong>P6</strong> 中搭建的 <strong>CPU</strong> 在同一级别。也就是这样的：</p><p><img src="../picture/P7_mips.png" alt=""></p><h2 id="系统桥"><a href="#系统桥" class="headerlink" title="系统桥"></a>系统桥</h2><p>系统桥是 <strong>CPU</strong> 与外部组件进行通信的通道。我们的 <strong>CPU</strong> 与 <strong>DM</strong>、两个计时器、其他硬件之间的通信都需要经过系统桥进行。</p><p>在实现系统桥的过程中，主要有两个方向的信息流：<strong>CPU</strong> 到外部，以及外部到 <strong>CPU</strong>。</p><h3 id="CPU-到外部"><a href="#CPU-到外部" class="headerlink" title="CPU 到外部"></a><strong>CPU</strong> 到外部</h3><p>我们需要向外部传递的信息包括：</p><ul><li>读写的 <strong>DM</strong> 地址与使能信号。</li><li>读写的计时器地址与使能信号。</li><li>对于外部中断的响应信号。</li></ul><p>事实上这些信息的传播都是通过 <strong>store</strong> 类指令完成的。也就是说我们只将 <strong>P6</strong> 中 <strong>CPU</strong> 与 <strong>DM</strong> 通信的接口重新连接至系统桥内即可。</p><p>重点在于系统桥内部对于地址的选择。</p><p>对于常规读写 <strong>DM</strong>：不需要进行额外修改。</p><h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>需要判断 <strong>CPU</strong> 中给出的存储地址是否在两个计时器的地址范围内。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> timer1_sel = (m_data_addr_in &gt;= <span class="number">32&#x27;h7f00</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f0b</span>);</span><br><span class="line"><span class="keyword">wire</span> timer2_sel = (m_data_addr_in &gt;= <span class="number">32&#x27;h7f10</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f1b</span>);</span><br><span class="line"><span class="comment">// m_data_addr_in 是从CPU处拿到的存储地址信号</span></span><br></pre></td></tr></table></figure><p>若 <strong>store</strong> 的地址在这个范围内，说明我们要对计时器进行写入。将传给 <strong>timer</strong> 的信号进行相应的连接即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> timer1_WE = (&amp;m_data_byteen_in == <span class="number">1&#x27;b1</span>) &amp;&amp; (m_data_addr_in &gt;= <span class="number">32&#x27;h7f00</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f0b</span>);</span><br><span class="line"><span class="keyword">assign</span> timer2_WE = (&amp;m_data_byteen_in == <span class="number">1&#x27;b1</span>) &amp;&amp; (m_data_addr_in &gt;= <span class="number">32&#x27;h7f10</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f1b</span>);</span><br><span class="line"><span class="keyword">assign</span> timer1_addr = m_data_addr_in[<span class="number">31</span>:<span class="number">2</span>];</span><br><span class="line"><span class="keyword">assign</span> timer2_addr = m_data_addr_in[<span class="number">31</span>:<span class="number">2</span>];</span><br><span class="line"><span class="keyword">assign</span> timer1_Din = m_data_wdata_in;</span><br><span class="line"><span class="keyword">assign</span> timer2_Din = m_data_wdata_in;</span><br></pre></td></tr></table></figure><p>注：前两行代码中 <code>&amp;m_data_byteen_in == 1&#39;b1</code> 是因为对计时器写入必须按字写入。</p><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>课程组给出了中断响应时应写入的地址。注意，什么时候进行中断的响应是软件决定的事情，不需要硬件做决定。我们只需要在 <strong>写入 “中断响应对应的地址” 时将响应信号传出 CPU</strong> 即可。</p><p>在系统桥中的代码连接如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Int_sel = (m_data_addr_in &gt;= <span class="number">32&#x27;h7f20</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f23</span>) &amp;&amp; (|m_data_byteen_in == <span class="number">1&#x27;b1</span>);</span><br><span class="line"><span class="keyword">assign</span> m_int_addr = Int_sel == <span class="number">1&#x27;b1</span> ? m_data_addr_in : <span class="number">32&#x27;h0</span>;</span><br><span class="line"><span class="keyword">assign</span> m_int_byteen = Int_sel == <span class="number">1&#x27;b1</span> ? m_data_byteen_in : <span class="number">4&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="外部到-CPU"><a href="#外部到-CPU" class="headerlink" title="外部到 CPU"></a>外部到 <strong>CPU</strong></h3><p>外部至 <strong>CPU</strong> 的信号除了 <strong>load</strong> 类指令的相关信号外，还要增加 <strong>HWInt</strong> 信号来实现<strong>外部中断</strong>。</p><p>注意到 <strong>load</strong> 类指令可能从计时器中读取数据，因此我们在连接信号时要对来自计时器的信号做出相应的选择。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> m_data_rdata_out = timer1_sel == <span class="number">1&#x27;b1</span> ? timer1_Dout :</span><br><span class="line">  timer2_sel == <span class="number">1&#x27;b1</span> ? timer2_Dout :</span><br><span class="line">  m_data_rdata_in;</span><br></pre></td></tr></table></figure><p><strong>HWInt</strong> 共有六位，从低位开始依次是：<strong>timer1</strong> 的中断信号、<strong>timer2</strong> 的中断信号、外部中断信号与 <strong>3’b0</strong>。</p><p>即：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> HWInt = &#123;<span class="number">3&#x27;b0</span>, interrupt_in, timer2_IRQ, timer1_IRQ&#125;;</span><br></pre></td></tr></table></figure><p>其中 <strong>interrupt_in</strong> 是来自外部的中断信号。</p><h2 id="计时器-1"><a href="#计时器-1" class="headerlink" title="计时器"></a>计时器</h2><p>计时器这部分我们简单的阅读源码，理解后大致了解各个端口的连接方式即可。计时器的源码在教程中已经给出。</p><p>注意，由于教程未来可能会有版本更新，计时器的具体连接方式也可能有变化。笔者不保证我的连接方式一定是正确的。还请同学们依据实际情况自行定夺。</p><h1 id="宏观-PC"><a href="#宏观-PC" class="headerlink" title="宏观 PC"></a>宏观 <strong>PC</strong></h1><p>由于我们要封装流水线，即让流水线看上去像一个单周期 <strong>CPU</strong>，所以我们使用了宏观 <strong>PC</strong> 这一概念。宏观 <strong>PC</strong> 表达的是 <strong>CPU</strong> 当前正在运转哪一条指令。</p><p>宏观 <strong>PC</strong> 要和协处理器 <strong>CP0</strong> 处于同一流水级中。有关协处理器的设计后文详谈。依据实现方式的不同，<strong>CP0</strong> 放在 <strong>E</strong> 级和 <strong>M</strong> 级均可。一般而言放在 <strong>M</strong> 级的同学居多，所以我也放在了 <strong>M</strong> 级，以便于和同学（大佬）们进行对拍。所以我宏观 <strong>PC</strong> 也就是 <strong>PC_M</strong> 的值。</p><p>在异常发生时，我们要保证产生异常的那条指令不会对 <strong>CPU</strong> 的状态造成影响。并将发生异常的指令作为 <strong>受害指令</strong> 存入协处理器的 <strong>EPC</strong> 中。这部分之后再详谈。</p><h1 id="侦测异常"><a href="#侦测异常" class="headerlink" title="侦测异常"></a>侦测异常</h1><p>在 <strong>P7</strong> 中，最重要的任务是侦测程序运行过程中产生的 <strong>异常</strong>。</p><p>我们首先要侦测异常，然后根据异常的种类生成相应的 <strong>Exccode</strong> 码，并将 <strong>Exccode</strong> 码存入协处理器 <strong>CP0</strong> 中。</p><h2 id="异常的种类"><a href="#异常的种类" class="headerlink" title="异常的种类"></a>异常的种类</h2><p>我们要实现的异常分为以下几类：</p><ul><li><strong>AdEL</strong>（<strong>Exccode</strong> 码为 <strong>5’d4</strong>）<ul><li>取 <strong>pc</strong> 的值时地址不对齐。</li><li><strong>lw</strong> 未字对齐与 <strong>lh</strong> 未半字对齐。</li><li>尝试使用 <strong>lh</strong> 和 <strong>lb</strong> 取 <strong>timer</strong> 的寄存器中的值。</li><li>计算取数地址的过程中出现加法溢出情况。</li><li>取数地址不在允许的范围中。</li></ul></li><li><strong>AdES</strong>（<strong>Exccode</strong> 码为 <strong>5’d5</strong>）<ul><li><strong>sw</strong> 未字对齐与 <strong>lh</strong> 未半字对齐。</li><li>尝试使用 <strong>sh</strong> 和 <strong>sb</strong> 向 <strong>timer</strong> 的寄存器中存值，或尝试向 <strong>timer</strong> 中的 <strong>Count</strong> 寄存器存值。</li><li>计算存数地址的过程中出现加法溢出情况。</li><li>存数地址不在允许的范围中。</li></ul></li><li><strong>Syscall</strong>（<strong>Exccode</strong> 码为 5’d8）<ul><li>由指令 <strong>syscall</strong> 产生的系统调用异常。</li></ul></li><li><strong>RI</strong>（<strong>Exccode</strong> 码为 <strong>5’d10</strong>）<ul><li>未知的指令码。</li></ul></li><li><strong>Ov</strong>（<strong>Exccode</strong> 码为 <strong>5’d12</strong>）<ul><li>加减指令的计算过程中出现溢出情况。</li></ul></li></ul><h2 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h2><p>笔者使用 <strong>OverFlow</strong> 指示溢出的产生。对溢出的判读需要在 <strong>E</strong> 级的 <strong>ALU</strong> 中进行。其具体过程在指令集中已有说明。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">32</span>:<span class="number">0</span>]tempAdd = &#123;A[<span class="number">31</span>], A&#125; + &#123;B[<span class="number">31</span>], B&#125;;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">32</span>:<span class="number">0</span>]tempSub = &#123;A[<span class="number">31</span>], A&#125; - &#123;B[<span class="number">31</span>], B&#125;;</span><br><span class="line"><span class="keyword">assign</span> OverFlowE = (ALUOp == <span class="number">4&#x27;b0000</span> &amp;&amp; tempAdd[<span class="number">32</span>] ^ tempAdd[<span class="number">31</span>] == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> :</span><br><span class="line">                   (ALUOp == <span class="number">4&#x27;b0001</span> &amp;&amp; tempSub[<span class="number">32</span>] ^ tempSub[<span class="number">31</span>] == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><p>其中 <strong>ALUOp</strong> 是我的实现方式中添加的信号。这个信号指示 <strong>ALU</strong> 要进行哪种运算。<strong>ALUOp</strong> 为 <strong>4’b0000</strong> 代表当前进行加法运算；<strong>ALUOp</strong> 为 <strong>4’b0001</strong> 代表当前进行减法运算。</p><p><strong>A</strong> 和 <strong>B</strong> 分别是传入 <strong>ALU</strong> 的两个操作数。</p><p><strong>OverFlow</strong> 在 <strong>E</strong> 级产生，需要流水到 <strong>M</strong> 级才能判断具体出现了哪种异常。</p><h2 id="Exccode-信号的产生"><a href="#Exccode-信号的产生" class="headerlink" title="Exccode 信号的产生"></a><strong>Exccode</strong> 信号的产生</h2><p>我们可以创建一个模块来产生 <strong>Exccode</strong> 信号。这里我将其称为 <strong>ExccodeOccur</strong>。此模块最好和协处理器位于同一流水级。（设置在 <strong>M</strong> 级中）</p><p>在清楚了各个异常产生的条件后，依次产生各个异常即可。</p><h3 id="AdEL"><a href="#AdEL" class="headerlink" title="AdEL"></a><strong>AdEL</strong></h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> AdEL = pcErrorM == <span class="number">1&#x27;b1</span> ? <span class="number">1&#x27;b1</span> : <span class="comment">//pcError</span></span><br><span class="line">(Lw == <span class="number">1&#x27;b1</span> &amp;&amp; (ALUAnsM[<span class="number">0</span>] | ALUAnsM[<span class="number">1</span>])) ? <span class="number">1&#x27;b1</span> : <span class="comment">//lw未字对齐</span></span><br><span class="line">(Lh == <span class="number">1&#x27;b1</span> &amp;&amp; ALUAnsM[<span class="number">0</span>]) ? <span class="number">1&#x27;b1</span> : <span class="comment">//lh未半字对齐</span></span><br><span class="line">((Lh | Lb) &amp;&amp; (ALUAnsM &gt;= <span class="number">32&#x27;h00007f00</span> &amp;&amp; ALUAnsM &lt;= <span class="number">32&#x27;h00007f1b</span>)) ? <span class="number">1&#x27;b1</span> : <span class="comment">//取Timer寄存器的值</span></span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; OverFlowM == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> :<span class="comment">//计算地址时加法溢出</span></span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f23</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f0b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f10</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f1b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f20</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00002fff</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f00</span>)) ? <span class="number">1&#x27;b1</span> :<span class="number">1&#x27;b0</span>; <span class="comment">//取数地址超出上限</span></span><br><span class="line"><span class="comment">// 注：其实可以简化但是因为写完后感觉工工整整的看上去很帅气所以就没有改</span></span><br></pre></td></tr></table></figure><h3 id="AdES"><a href="#AdES" class="headerlink" title="AdES"></a><strong>AdES</strong></h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> AdES = (Sw == <span class="number">1&#x27;b1</span> &amp;&amp; (ALUAnsM[<span class="number">0</span>] | ALUAnsM[<span class="number">1</span>])) ? <span class="number">1&#x27;b1</span> :<span class="comment">//sw未字对齐</span></span><br><span class="line">            (Sh == <span class="number">1&#x27;b1</span> &amp;&amp; ALUAnsM[<span class="number">0</span>]) ? <span class="number">1&#x27;b1</span> :<span class="comment">//sh未半字对齐</span></span><br><span class="line">            ((Sh | Sb) &amp;&amp; (ALUAnsM &gt;= <span class="number">32&#x27;h00007f00</span> &amp;&amp; ALUAnsM &lt;= <span class="number">32&#x27;h00007f1b</span>)) ? <span class="number">1&#x27;b1</span> :<span class="comment">//存Timer寄存器的值</span></span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; OverFlowM == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> :<span class="comment">//计算地址时加法溢出</span></span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM == <span class="number">32&#x27;h00007f08</span> || ALUAnsM == <span class="number">32&#x27;h00007f18</span>)) ? <span class="number">1&#x27;b1</span> :<span class="comment">//向计时器的Count存值</span></span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f23</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f0b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f10</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f1b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f20</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00002fff</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f00</span>)) ? <span class="number">1&#x27;b1</span> :<span class="number">1&#x27;b0</span>;<span class="comment">//存数地址超出上限</span></span><br></pre></td></tr></table></figure><h3 id="Syscall"><a href="#Syscall" class="headerlink" title="Syscall"></a><strong>Syscall</strong></h3><p>直接识别指令是否是 <strong>syscall</strong> 就行。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Syscall = (func == <span class="number">6&#x27;b001100</span> &amp;&amp; R_R == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="RI"><a href="#RI" class="headerlink" title="RI"></a><strong>RI</strong></h3><p><strong>RI</strong> 信号在 <strong>Controller</strong> 中产生，然后流水到 <strong>ExccodeOccur</strong> 所在的流水级，参与 <strong>Exccode</strong> 的生成。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Controller中产生，也就是在D级产生。</span></span><br><span class="line"><span class="keyword">assign</span> RID = ~(Beq | Bgez| Bne | Addi| Andi| Ori | Lui | J   | </span><br><span class="line">               Jal | Sb  | Sh  | Sw  | Lb  | Lh  | Lw  | Add | </span><br><span class="line">               Sub | And | Or  | Sll | Srl | Jr  | Slt | Sltu| </span><br><span class="line">               Mult|Multu| Div | Divu| Mfhi| Mflo| Mthi| Mtlo| </span><br><span class="line">            Syscall| Mfc0| Mtc0| Eret);</span><br></pre></td></tr></table></figure><h3 id="Ov"><a href="#Ov" class="headerlink" title="Ov"></a><strong>Ov</strong></h3><p>注意是由加减法运算指令导致的溢出才会产生 <strong>Ov</strong> 信号。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Ov = ((Add | Addi | Sub) &amp;&amp; OverFlowM == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="Exccode"><a href="#Exccode" class="headerlink" title="Exccode"></a><strong>Exccode</strong></h3><p>在得到所需的各个信号后，进行判断、生成即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> ExcCodeM = AdEL == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d4</span> :</span><br><span class="line">                  AdES == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d5</span> :</span><br><span class="line">                  Syscall == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d8</span> :</span><br><span class="line">                  RIM  == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d10</span> :</span><br><span class="line">                  Ov   == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d12</span> : <span class="number">5&#x27;d0</span>;</span><br></pre></td></tr></table></figure><h1 id="协处理器-CP0-设计"><a href="#协处理器-CP0-设计" class="headerlink" title="协处理器 CP0 设计"></a>协处理器 <strong>CP0</strong> 设计</h1><p><strong>CP0</strong> 的设计是整个 <strong>P7</strong> 的关键所在。这里特别感谢 <strong>roief</strong> 佬及其博客。<strong>roief</strong> 的博客指路：<a href="https://roife.github.io/2021/01/02/buaa-co-lab-p7/">P7 MIPS 微体系</a></p><h2 id="CP0-的端口"><a href="#CP0-的端口" class="headerlink" title="CP0 的端口"></a><strong>CP0</strong> 的端口</h2><p>我个人的 <strong>CP0</strong> 端口完全按照教程所推荐的设计。即：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">moudle CP0(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> en,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] CP0Add,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] CP0In,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] CP0Out,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] VPC,</span><br><span class="line">    <span class="keyword">input</span> BDIn,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] ExcCodeIn,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">5</span>:<span class="number">0</span>] HWInt,</span><br><span class="line">    <span class="keyword">input</span> EXLClr,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] EPCOut,</span><br><span class="line">    <span class="keyword">output</span> Req</span><br><span class="line">    );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于各个输入端口的粗略解释：</p><p><strong>CP0Add</strong> 和 <strong>CP0In</strong> 都是在实现 <strong>mtc0</strong> 和 <strong>mfc0</strong> 中要用到的。<strong>VPC</strong> 是受害指令的宏观 <strong>PC</strong>，此处即为 <strong>M</strong> 级 <strong>PC</strong>。</p><p><strong>ExccodeIn</strong> 是我们在 <strong>ExccodeOccur</strong> 中产生的 <strong>Exccode</strong>。<strong>HWInt</strong> 是我们在系统桥中产生并传入 <strong>CPU</strong> 的，传入 <strong>CPU</strong> 后直接连接到 <strong>CP0</strong> 的端口上。</p><p><strong>EXLClr</strong> 由指令 <strong>eret</strong> 产生。</p><p><strong>BDIn</strong> 指示当前指令是不是延迟槽内部指令，这与 <strong>EPC</strong> 的产生有关。</p><h2 id="CP0-中寄存器的实现"><a href="#CP0-中寄存器的实现" class="headerlink" title="CP0 中寄存器的实现"></a><strong>CP0</strong> 中寄存器的实现</h2><p>在 <strong>CP0</strong> 中我们要实现三个寄存器：<strong>SR</strong>、<strong>Cause</strong>、<strong>EPC</strong>。</p><p>为了便于 <strong>mtc0</strong> 和 <strong>mfc0</strong> 的实现以及不知道这两个指令会不会存取我们尚未实现的寄存器，我的 <strong>CP0</strong> 设计中添加了一个寄存器堆：<code>reg [31:0]CP[0:31];</code>，并添加以下宏定义便于代码编写（注：下文的代码使用到的宏定义均位于此处）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> SR CP[12]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> Cause CP[13]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> EPC CP[14]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> IE CP[12][0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> EXL CP[12][1]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> IM CP[12][15:10]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> BD CP[13][31]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> IP CP[13][15:10]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> ExcCode CP[13][6:2]</span></span><br></pre></td></tr></table></figure><p>各个域的功能：</p><ul><li><strong>IE</strong>：是否允许中断。</li><li><strong>EXL</strong>：是否处于核心态（异常中断处理程序中）。</li><li><strong>IM</strong>：六个位分别指示是否允许发生对应的中断。</li><li><strong>BD</strong>：是否是延迟槽中指令</li><li><strong>IP</strong>：每周期更新，记录 <strong>HWInt</strong> 的值。</li><li><strong>ExcCode</strong>：发生异常时更新，记录异常码。</li></ul><p>事后得知貌似是不会存取我们没有实现的寄存器的……不过这么写实现 <strong>mtc0</strong> 和 <strong>mfc0</strong> 都很方便，所以也是有其优点的。实际上协处理器 <strong>CP0</strong> 中就是包含有 <strong>32</strong> 个寄存器，因此这样实现可以说是毫无毛病（乐）。</p><h2 id="BD-的产生"><a href="#BD-的产生" class="headerlink" title="BD 的产生"></a><strong>BD</strong> 的产生</h2><p><strong>BD</strong> 这个信号是在外部产生并传入 <strong>CP0</strong> 中，指示当前指令是否处于延迟槽内。这里有一处要注意的地方是：在产生 <strong>BD</strong> 时，不管跳转指令是否跳转，都要将其视为处于延迟槽内。</p><p>我在 <strong>F</strong> 级产生这一信号，从而满足 <strong>BD</strong> 的产生晚于跳转指令一周期的条件。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> BDF = JalD | JrD | BeqD | BneD | <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h2 id="CP0Out-和-EPCOut"><a href="#CP0Out-和-EPCOut" class="headerlink" title="CP0Out 和 EPCOut"></a><strong>CP0Out</strong> 和 <strong>EPCOut</strong></h2><p>很方便的，我的 <strong>CP0Out</strong> 的产生方式为：<code>assign CP0Out = CP[CP0Add];</code>，一行搞定。</p><p>相应的，<strong>EPCOut</strong> 的产生方式为：<code>assign EPCOut = `EPC;</code>。</p><h2 id="EPC-的产生"><a href="#EPC-的产生" class="headerlink" title="EPC 的产生"></a><strong>EPC</strong> 的产生</h2><p>对于 <strong>EPC</strong> 的产生，要注意：如果指令是延迟槽指令（即 <code>BDIn == 1&#39;b1</code>），那么我们记录的 <strong>EPC</strong> 应当是其所属的跳转指令（即受害指令的上一条指令，<code>VPC - 32&#39;d4</code>）。</p><h2 id="Req-的产生"><a href="#Req-的产生" class="headerlink" title="Req 的产生"></a><strong>Req</strong> 的产生</h2><p>注：这部分参照了 <strong>roief</strong> 佬的写法。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> IntReq = (|(HWInt &amp; `IM)) &amp; !`EXL &amp; `IE; <span class="comment">// 允许当前中断 且 不在中断异常中 且 允许中断发生</span></span><br><span class="line"><span class="keyword">wire</span> ExcReq = (|ExcCodeIn) &amp; !`EXL; <span class="comment">// 存在异常 且 不在中断中</span></span><br><span class="line"><span class="keyword">assign</span> Req  = IntReq | ExcReq;</span><br></pre></td></tr></table></figure><p><strong>Req</strong> 的产生就意味着我们要进入异常处理程序了。除了要在 <strong>CP0</strong> 中做出改变外，我们还需要在 <strong>CPU</strong> 中做出相应的操作。下文再说。</p><h2 id="CP0-的时序逻辑"><a href="#CP0-的时序逻辑" class="headerlink" title="CP0 的时序逻辑"></a><strong>CP0</strong> 的时序逻辑</h2><p>遵循设计即可。</p><p>结合注释观看效果更佳。</p><p>这里提一个要注意的点：当中断和异常同时发生时，要优先响应中断，即向 <strong>`ExcCode</strong> 存入的值应当是象征中断的 <strong>0</strong>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            CP[i] = <span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(en == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span> <span class="comment">// 使能信号为真时将数据写入对应的寄存器</span></span><br><span class="line">            CP[CP0Add] = CP0In;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(Req == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span> <span class="comment">// 当异常或中断发生时</span></span><br><span class="line">            `EXL &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            `ExcCode &lt;= IntReq == <span class="number">1&#x27;b1</span> ? <span class="number">0</span> : ExcCodeIn; <span class="comment">// 中断的优先级高于异常</span></span><br><span class="line">            `EPC &lt;= BDIn == <span class="number">1&#x27;b1</span> ? VPC - <span class="number">32&#x27;d4</span> : VPC; <span class="comment">// 结合BDIn生成EPC</span></span><br><span class="line">            `BD &lt;= BDIn;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(EXLClr == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">            `EXL &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>((en == <span class="number">1&#x27;b1</span> &amp;&amp; CP0Add == <span class="number">13</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 这里是为了防止mtc0的目标寄存器是Cause时会对IP域写入两次</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            `IP &lt;= HWInt; <span class="comment">//每周期更新IP的值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="REQ-发生时"><a href="#REQ-发生时" class="headerlink" title="REQ 发生时"></a><strong>REQ</strong> 发生时</h1><p>当 <strong>CP0</strong> 中的 <strong>Req</strong> 信号处于高位，即我们要进入异常处理程序时，我们要对流水线进行以下处理：</p><ul><li>清空 <strong>D, E, M, W</strong> 级流水线寄存器。实现上可以直接将 <strong>Req</strong> 信号接入 <strong>reset</strong> 中。</li><li>将 <strong>PC</strong> 的值强制修改到异常处理程序的入口：<code>32&#39;h00004180</code>。</li><li>保证异常发生时不会对 <strong>DM</strong> 等外部模块产生写信号（即 <code>m_data_byteen == 4&#39;h0</code>）。</li><li>正处于 <strong>E</strong> 级的指令不应修改乘除模块。</li></ul><h1 id="指令拓展"><a href="#指令拓展" class="headerlink" title="指令拓展"></a>指令拓展</h1><p>在 <strong>P7</strong> 中，我们要拓展以下几个指令：<code>syscall, mfc0, mtc0, eret</code></p><p>其中 <strong>syscall</strong> 没什么好说的，产生相应的异常码就行。</p><p><strong>mfc0</strong> 和 <strong>mtc0</strong> 的实现有些类似于 <strong>mfhi</strong>，<strong>mthi</strong> 。根据指令集进行拓展即可。此外根据个人实现的不同可能需要处理和 <strong>mfc0</strong> 与 <strong>mtc0</strong> 相关的转发（增加 <strong>W</strong> 级到 <strong>M</strong> 级的通路等），还请注意。</p><p><strong>eret</strong> 要修改 <strong>PC</strong> 的值，返回 <strong>EPC</strong> 处继续执行指令。此处要有一个数据冲突问题需要注意：</p><p>当 <strong>mfc0</strong> 要修改 <strong>CP0</strong> 中的 <strong>14</strong> 号寄存器（即 <strong>`EPC</strong>），且后面跟着 <strong>eret</strong> 时，要进行相应的阻塞。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> stall_eret = EretD &amp; ((Mtc0E &amp; (instrE[<span class="number">15</span>:<span class="number">11</span>] == <span class="number">5&#x27;d14</span>)) | (Mtc0M &amp; (instrM[<span class="number">15</span>:<span class="number">11</span>] == <span class="number">5&#x27;d14</span>)));</span><br></pre></td></tr></table></figure><p>此外，当 <strong>eret</strong> 流水至 <strong>M</strong> 级时要将 <strong>CP0</strong> 中的 <strong>`EXL</strong> 置 <strong>0</strong>。</p><h1 id="修改-PC-的信号优先级"><a href="#修改-PC-的信号优先级" class="headerlink" title="修改 PC 的信号优先级"></a>修改 <strong>PC</strong> 的信号优先级</h1><p>优先级为：<strong>reset &gt; REQ &gt; eret &gt; 其他</strong></p><p>自行体悟一下即可，不作过多解释。</p><h1 id="阻塞时中断产生的问题"><a href="#阻塞时中断产生的问题" class="headerlink" title="阻塞时中断产生的问题"></a>阻塞时中断产生的问题</h1><p>在 <strong>P6</strong> 的 <strong>CPU</strong> 中，当我们阻塞时插入 <strong>nop</strong>，<strong>nop</strong> 对应的 <strong>pc</strong> 值一般是 <strong>0</strong>。这个设计在 <strong>P7</strong> 中会招致问题：当处于阻塞时外部产生了中断信号，我们记录的 <strong>EPC</strong> 将会是 <strong>0</strong>。这会导致错误的产生。</p><p>正确的处理方法，是在阻塞时让 <strong>pc</strong> 和 <strong>BD</strong> 这两个信号依旧正常流水。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P7</strong> 的工程量还是很大的。往年 <strong>P7</strong> 也被称为是最玄学的一 <strong>P</strong>。今年我在搭建时据说教程大更新，因此实际上并没有感觉有那么的 “玄学”。计组课程在不断地改进啊（喜）。</p><p>今年因为 <strong>P8</strong> 和烤漆完全撞上的缘故（考完概统的当天晚上进行 <strong>P8</strong> 上机），为了复习期末，不得已放弃了做 <strong>P8</strong> 的想法，不得不说是一个计组学习中的遗憾。</p><p>计组回忆的这一系列到这就结束了。虽然过程艰辛又曲折，但是回顾已有的成果，还是会有一种 “我都已经做出来这么多东西了啊！” 的感叹。</p><p>不知读者在学习计组的过程中是否体会到了乐趣呢？</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P6 回顾</title>
      <link href="/2023/01/05/BUAA-CO-P6/"/>
      <url>/2023/01/05/BUAA-CO-P6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是 <strong>bluebean</strong> 的 <strong>P6</strong> 回忆录。</p><p>我认为 <strong>P6</strong> 的难度较 <strong>P5</strong> 降低了许多，因为在 <strong>P6</strong> 只需要在 <strong>P5</strong> 的流水线基础上进行增量开发即可。当然，若 <strong>P5</strong> 的架构不完善的话，在 <strong>P6</strong> 可能将要坐大牢。</p><p>按照课程组（<strong>2021</strong> 版，以后可能会有变化）的要求，在 <strong>P6</strong> 中主要需要完成一下任务：</p><ul><li><strong>IM</strong> 和 <strong>DM</strong> 的外置。</li><li>在 <strong>P5</strong> 的基础上对指令集进行增量拓展。</li><li>添加乘除法模块，实现和乘除法相关的指令。</li></ul><h1 id="外置-IM-与-DM-模块"><a href="#外置-IM-与-DM-模块" class="headerlink" title="外置 IM 与 DM 模块"></a>外置 <strong>IM</strong> 与 <strong>DM</strong> 模块</h1><p>在 <strong>P6</strong> 中，我们的 <strong>IM</strong> 与 <strong>DM</strong> 模块需要外置，外置的模块在课程组提供的 <strong>test bench</strong> 中。在 <strong>CPU</strong> 中需要提供相应的与 <strong>IM</strong> 和 <strong>DM</strong> 通信的端口。</p><p>与 <strong>IM</strong> 的通信没什么好说的，直接把原来 <strong>IM</strong> 的接口接出去就行。</p><p>课程组的 <strong>DM</strong> 模块采用了字节使能方法来支持按字节读写的功能。这部分可以阅读课程组的代码后自行思考相应的实现方式。</p><p>我在实现过程中，产生了一个新的信号 <strong>MemWrite</strong> 用于指示读写哪些字节。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]MemWriteD = Sw == <span class="number">1&#x27;b1</span> ? <span class="number">4&#x27;b1111</span> :</span><br><span class="line">                    Sh == <span class="number">1&#x27;b1</span> ? <span class="number">4&#x27;b0011</span> :</span><br><span class="line">                    Sb == <span class="number">1&#x27;b1</span> ? <span class="number">4&#x27;b0001</span> : <span class="number">4&#x27;b0000</span>;</span><br></pre></td></tr></table></figure><p>在连接 <strong>DM</strong> 的信号时，采用了如下方式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> m_data_wdata  = AD1M &lt;&lt; &#123;ALUAnsM[<span class="number">1</span>:<span class="number">0</span>], <span class="number">3&#x27;b000</span>&#125;;</span><br><span class="line"><span class="keyword">assign</span> m_data_byteen = MemWriteM &lt;&lt; ALUAnsM[<span class="number">1</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>其中 <strong>ALUAnsM</strong> 是 <strong>ALU</strong> 的计算结果（<strong>M</strong> 级），存储着要写入的地址信息。</p><p>另外在 <strong>DM</strong> 读出的数据要进行相应的数据扩展。这里写一个 <strong>DM_EXT</strong> 模块判断一下对应的指令再进行相应的符号扩展就可以了。</p><h1 id="指令集拓展"><a href="#指令集拓展" class="headerlink" title="指令集拓展"></a>指令集拓展</h1><p>在 <strong>P6</strong> 中一项重要的工作就是进行指令集拓展。在一个良好的 <strong>P5</strong> 基础上进行拓展并不是难事。</p><p>建议每拓展一个指令就进行相应的功能测试。不求数据点多强，至少基本的功能测试要做好。</p><p>例如在拓展了 <strong>bne</strong> 指令后，进行简单的功能测试：<br><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ori </span>$<span class="number">1</span> <span class="number">0xf0</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">2</span> <span class="number">0xf0</span></span><br><span class="line"><span class="keyword">bne </span>$<span class="number">1</span> $<span class="number">2</span> end</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">lui </span>$<span class="number">1</span> <span class="number">0xff</span> <span class="comment"># run this</span></span><br><span class="line"><span class="keyword">bne </span>$<span class="number">1</span> $<span class="number">2</span> end</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span> <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lui </span>$<span class="number">1</span> <span class="number">0xee</span> <span class="comment"># not run this</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="number">5</span> <span class="number">0xcc</span></span><br></pre></td></tr></table></figure></p><p>建议同学们在课下针对每一个指令都做好测试，减少后期 <strong>dbug</strong> 难度。</p><h1 id="乘除模块"><a href="#乘除模块" class="headerlink" title="乘除模块"></a>乘除模块</h1><p>关于乘除指令，我们要拓展的有 <code>mult, multu, div, divu, mfhi, mflo, mthi, mtlo</code>。</p><p>我们要模拟出 <code>hi, lo</code> 这两个寄存器。</p><p>在写乘法时可以采用写法：<code>&#123;HiTem, LoTem&#125; = $signed(A) * $signed(B);</code>。这里 <strong>HiTem</strong> 和 <strong>LoTem</strong> 是用来暂时存储计算的值，当模拟乘除延迟结束时将结果存入 <strong>hi, lo</strong> 寄存器。</p><p>此外要注意和乘除法指令相关的阻塞。当乘除模块正在运行时，遇到新的乘除指令是要阻塞流水线的。这里存在一定的优化空间，比如两条连续的乘法指令，我们就可以忽略掉前一条乘法指令，因为后一条指令会重新写 <strong>hi, lo</strong> 寄存器。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p>上机一般是两道简单题 <strong>+</strong> 一道难题。可能会涉及改动乘除模块。建议也是提前把课上可能用到的接口留出来。此外上机前可以提前想好添加一个功能时可能要改动哪些相应的信号。</p><p>这里给出一个我在上机时遇到的一个困难指令：<strong>shl</strong></p><p><strong>shl</strong> 的功能是交换乘除法模块中 <strong>hi</strong> 寄存器和 <strong>lo</strong> 寄存器中的值。乍看上去很简单，但是这里存在坑点。比如在乘除法之后紧跟一串 <strong>shl</strong> 指令，最优情况是不进行阻塞。</p><p>标准思路：交换两个寄存器的值，等价于交换两个寄存器的名字。使用一个 <strong>tag</strong> 标记，当 <strong>tag</strong> 为 <strong>1</strong> 时，<strong>hi</strong> 作为 <strong>lo</strong> 寄存器，<strong>lo</strong> 作为 <strong>hi</strong> 寄存器；<strong>tag</strong> 为 <strong>0</strong> ，情况照常。</p><p>这个题实际上是可难可易……如果不卡时间的话（允许乘除法后遇到 <strong>shl</strong> 时阻塞），本题毫无难度，否则难度暴增。（主要是没有考虑到这样阴间的阻塞情况。我在考前一直以为在乘除法后紧跟的是 <strong>mflo</strong> 或 <strong>mfhi</strong>，直到舍友告诉我那是“在乘除法<strong>结束</strong>后紧跟 <strong>mfhi</strong> 或 <strong>mflo</strong>”）</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P6</strong> 的工作基本上只有这些内容了。说实话我感觉 <strong>P5</strong> 做的更艰难一点（毕竟是从头开始搭流水线）。</p><p>有能力的同学也可以在课下空余时间拓展更多指令。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件信息流追踪与 RTL 代码安全性分析综述</title>
      <link href="/2023/01/04/RTL-security-IFT/"/>
      <url>/2023/01/04/RTL-security-IFT/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li><p>计算机安全的<strong>核心原则</strong> = 维护所计算信息的<strong>保密性</strong> +  维护所计算信息的<strong>完整性</strong></p><p>保密性 = 信息只开放给授权用户</p><p>完整性 = 维护信息的准确性 + 一致性</p></li><li><p>信息流跟踪（<strong>IFT</strong>）是一种模拟系统计算时信息传播方式的安全技术。</p><p>特点：拥有一些 <strong>tag</strong> 来表示安全类别，且这些 <strong>tag</strong> 可以更新。</p></li><li><p>本次调研主要介绍<strong>硬件 IFT 分类方法</strong>，用于调查、分类、比较不同的硬件 <strong>IFT</strong> 技术。</p></li></ul><h1 id="Information-Flow"><a href="#Information-Flow" class="headerlink" title="Information Flow"></a>Information Flow</h1><ul><li><strong>IFT</strong> 技术的工作原理 = 用安全类别标记存储对象，并在计算数据时跟踪这些标签</li></ul><h4 id="Storage-Objects-and-Processes"><a href="#Storage-Objects-and-Processes" class="headerlink" title="Storage Objects and Processes"></a>Storage Objects and Processes</h4><ul><li><p>存储对象是信息的容器，进程描述了对这些对象执行的计算。存储对象和进程因安全策略和抽象级别而异。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f38dbe43e0d30e814b86.png" alt="image-20230104101318676"></p><p><em>附：上图为安全语言结构示例。</em></p></li></ul><h4 id="Security-Classes-and-Flow-Relations"><a href="#Security-Classes-and-Flow-Relations" class="headerlink" title="Security Classes and Flow Relations"></a>Security Classes and Flow Relations</h4><ul><li>信息流策略定义了数据对象之间允许的关系。为此，<strong>IFT</strong> 将每个对象与一个安全类别相关联，即给对象一个安全标签或安全标记。</li><li>在实际中，大多数策略使用<img src="https://pic.imgdb.cn/item/63b4f38dbe43e0d30e814ba1.png" alt="image-20230104101707494" style="zoom: 50%;" /> 两元素网络，允许将保密性和完整性相关的安全属性建模为<img src="https://pic.imgdb.cn/item/63b4f40abe43e0d30e81f033.png" alt="image-20230104101833762" style="zoom:67%;" /></li></ul><h4 id="Noninterference"><a href="#Noninterference" class="headerlink" title="Noninterference"></a>Noninterference</h4><ul><li><p>Noninterference 通过将所有系统输入、输出和状态建模为 <strong>high</strong> 或 <strong>low</strong> 来创建信息流模型，指出 <strong>high</strong> 的任何变化不应该导致 <strong>low</strong> 的输出变化。一个主要的挑战是硬件中的对象数量通常比软件中的多得多。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f409be43e0d30e81ef4d.png" alt="image-20230104102613227"></p><p><em>附：上图是 explicit flow 的一个简单示例。</em></p></li></ul><h4 id="Types-of-Information-Flow-Relations"><a href="#Types-of-Information-Flow-Relations" class="headerlink" title="Types of Information Flow Relations"></a>Types of Information Flow Relations</h4><ul><li><p>虽然流关系提供了一种方式来指定与是否允许信息在对象之间传输相关的安全策略，但是它们没有严格定义确定是否存在信息流的方法。 信息可以通过许多不同的方式传播。 理解不同类型的信息流关系以及它们如何在硬件中表现出来，是精确测量所有信息流并进一步严格执行安全策略的重要的第一步。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f409be43e0d30e81ef6d.png" alt="image-20230104102742921"></p><p><em>附：上图是 implicit flow 的一个简单示例。</em></p></li></ul><h4 id="Covert-and-Side-Channels"><a href="#Covert-and-Side-Channels" class="headerlink" title="Covert and Side Channels"></a>Covert and Side Channels</h4><ul><li><p><strong>Covert Channel</strong> 是使用非预期来源的信息传输。</p><p>Covert Channels = storage channel + timing channel</p></li><li><p><strong>Side Channel</strong> 是通过非功能(通常是物理)特征(例如，执行时间、功耗、电磁辐射和声发射)的信息泄漏。</p></li></ul><h1 id="Operator-Precision"><a href="#Operator-Precision" class="headerlink" title="Operator Precision"></a>Operator Precision</h1><h4 id="Precision-of-IFT"><a href="#Precision-of-IFT" class="headerlink" title="Precision of IFT"></a>Precision of IFT</h4><ul><li><strong>IFT</strong> 技术的精度反映了它准确测量硬件设计中所有现有信息流的能力。精确的 <strong>IFT</strong> 技术将精确地模拟硬件设计的信息流行为，而不精确的技术可能指示不存在的信息流，即假阳性（<strong>false positives</strong>），或者错过实际的信息流，即假阴性（<strong>false negatives</strong>）。</li></ul><h4 id="Imprecise-IFT"><a href="#Imprecise-IFT" class="headerlink" title="Imprecise IFT"></a>Imprecise IFT</h4><ul><li>虽然不精确的 <strong>IFT</strong> 技术可能会导致保守的验证结果，但它们通常可以快速分析潜在的信息流安全漏洞， 这对于识别在罕见情况下发生的安全违规非常有用。</li></ul><h4 id="Precise-IFT"><a href="#Precise-IFT" class="headerlink" title="Precise IFT"></a>Precise IFT</h4><ul><li><p>精确 <strong>IFT</strong> 技术在确定流量关系时考虑了硬件组件的功能和输入值， 该标签传播策略可以被形式化为输入及其标签的函数。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f40abe43e0d30e81efba.png" alt="image-20230104104019463"></p><p><em>附：上图表示 flow relation 和 class combining operation的示例，显示了考虑和不考虑数据值的class combining operation的差异。</em></p><ul><li>（a）是与门；</li><li>（b）是不考虑数据值的 <strong>flow relation</strong> 和 <strong>class combining operation</strong>；</li><li>（c）是考虑数据值的 <strong>flow relation</strong> 和 <strong>class combining operation</strong>。</li></ul></li></ul><h4 id="Precision-and-Complexity-Tradeoffs"><a href="#Precision-and-Complexity-Tradeoffs" class="headerlink" title="Precision and Complexity Tradeoffs"></a>Precision and Complexity Tradeoffs</h4><ul><li><p>精确度和复杂性是评估硬件 <strong>IFT</strong> 技术的两个相互矛盾的因素，需要在两者之间进行权衡。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f40abe43e0d30e81f005.png" alt="image-20230104104755791"></p><p><em>附：上图为与门推导简化的硬件 IFT 逻辑，展现了一种有效的方法来推导不同版本的具有可变精度和复杂度的布尔门硬件IFT逻辑，通过逐渐忽略输入，来放松精确度。</em></p></li></ul><h1 id="Security-Properties"><a href="#Security-Properties" class="headerlink" title="Security Properties"></a>Security Properties</h1><ul><li><p>信息流属性被表示为对象上的 <strong>flow relations</strong>。 属性指定存储在硬件对象中的信息能否流向其他对象。</p><p><strong>IFT</strong> 属性是超属性（<strong>hyperproperties</strong>）的例子，因为它们表达了需要跨多个轨迹验证的预期行为。</p></li><li><p>硬件 <strong>IFT</strong> 工具使用存储安全相关信息的标签来模拟信息在硬件中的移动。标签指示对象是可信的还是不可信的，机密的还是公开的，是否包含时间变化等等。属性定义标签的初始条件，以及标签在执行过程中是否可以更改。</p></li></ul><h4 id="Confidentiality"><a href="#Confidentiality" class="headerlink" title="Confidentiality"></a>Confidentiality</h4><ul><li><p>保密性属性确保任何与敏感对象(标记为 <strong>high</strong>)相关的信息永远不会流向未分类的对象(标记为 <strong>low</strong>)。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f455be43e0d30e825002.png" alt="image-20230104110053926"></p><p><em>附：表1的前四行显示了各种硬件设计(如加密内核和算术单元)的保密性属性示例。使用assume语句将敏感对象的标签设置为high，并将公共可见对象的标签设置为low。</em></p></li></ul><h4 id="Integrity"><a href="#Integrity" class="headerlink" title="Integrity"></a>Integrity</h4><ul><li>完整性是保密性的双重含义，在这里我们用 <strong>high</strong> 标签标记不可信的硬件资源，并用 <strong>low</strong> 标签标记它们不会影响关键组件。</li><li><img src="https://pic.imgdb.cn/item/63b4f455be43e0d30e825002.png" alt="image-20230104110053926"><em>附：表1显示了为加密核心（crypto cores）、调试单元（debug units）、处理器（processors）和访问控制单元（ access control units)编写的四个完整性属性。</em></li></ul><h4 id="lsolation"><a href="#lsolation" class="headerlink" title="lsolation"></a>lsolation</h4><ul><li><strong>isolation</strong> 也可以作为信息流安全属性来实施。<strong>isolation</strong> 声明在具有不同信任级别的两个组件之间不应该有信息交换，是一种双向属性。</li></ul><h4 id="Constant-Time"><a href="#Constant-Time" class="headerlink" title="Constant Time"></a>Constant Time</h4><ul><li><p>信息流模型可用于捕获硬件设计中运行时变化产生的时序侧信道。 常数时间属性通过测量计算时间来评估是否可以检索敏感信息。 为了精确地捕获定时流，信息流模型需要区分逻辑流和定时流。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f455be43e0d30e825086.png" alt="image-20230104111258616"></p><p><em>附：表2总结了几种在验证不同硬件设计中的时序侧通道时所使用的特性。</em></p></li></ul><h4 id="Design-Integrity"><a href="#Design-Integrity" class="headerlink" title="Design Integrity"></a>Design Integrity</h4><ul><li><p><strong>IFT</strong> 可用于检测某些类型的未记录的设计修改，这些修改会泄漏敏感信息或通过在设计中插入恶意信息通道来覆盖关键内存位置。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f456be43e0d30e82510b.png" alt="image-20230104112205281"></p><p><em>附：表3总结了 Trust-HUB中GLIFT检测信息泄露的特性。</em></p></li></ul><h1 id="现有的IFT技术"><a href="#现有的IFT技术" class="headerlink" title="现有的IFT技术"></a>现有的IFT技术</h1><h2 id="基于状态机的IFT语言"><a href="#基于状态机的IFT语言" class="headerlink" title="基于状态机的IFT语言"></a>基于状态机的IFT语言</h2><p><strong>Caisson</strong> 和 <strong>Sapper</strong> 是增强了 <strong>IFT</strong> 能力的 <strong>HDL</strong> 语言，可以直接生成执行所需 <strong>IFT</strong> 属性的电路。这两种语言都使用状态机进行硬件设计，并可以防止产生非法流。</p><p><strong>Caisson</strong> 通过静态类型检查来执行。这迫使他保守地执行复制以限制信息流。这会带来很大的硬件区域开销。但也显著地提高逻辑能力。</p><p><strong>Sapper</strong> 添加了动态类型系统以减少逻辑复制的需求。它通过采用混合方法进行标签检查来改进 <strong>Caisson</strong>。它使用静态分析生成一组动态检查，这些检查被插入到硬件设计中，以实现动态跟踪。这样可以重用资源，从而降低区域开销。</p><h2 id="Coq"><a href="#Coq" class="headerlink" title="Coq"></a>Coq</h2><p><strong>Coq</strong> 是一个交互式定理证明器。它允许数学断言的表达式，机械性地检查这些假设的证明，帮助寻找形式化的证明，并从构建性的证明中输出一个关于它的形式化规范的被证明有效的程序。<strong>Coq</strong> 不是一个自动定理证明器，但是包括自动定理证明工具以及各种决策流程。</p><h2 id="VeriCoq-IFT"><a href="#VeriCoq-IFT" class="headerlink" title="VeriCoq-IFT"></a>VeriCoq-IFT</h2><p><strong>VeriCoq-IFT</strong> 自动将设计从 <strong>HDL</strong> 语言转换为 <strong>Coq</strong> 形式语言，无需重新设计硬件。</p><h2 id="SecVerilog"><a href="#SecVerilog" class="headerlink" title="SecVerilog"></a>SecVerilog</h2><p><strong>SecVerilog</strong> 使用表达型类型系统扩展了 <strong>Verilog</strong> 语言。其使用的是静态类型检查方法。<strong>SecVerilog</strong> 用户需要显式地为代码中的每个变量添加安全标签。它使用类型系统来确保支持指定的信息流策略。</p><h2 id="SecChisel"><a href="#SecChisel" class="headerlink" title="SecChisel"></a>SecChisel</h2><p><strong>ChiselFlow</strong> 是另一种类型强制 <strong>HDL</strong>，带有用于开发安全硬件架构的定时标签。它已被用于创建具有硬件级信息流控制的加密加速器，并正式验证这些实现的安全性。</p><h1 id="IFT验证技术"><a href="#IFT验证技术" class="headerlink" title="IFT验证技术"></a>IFT验证技术</h1><p><strong>IFT</strong> 验证技术可以以静态或是动态的方式运行。静态 <strong>IFT</strong> 技术在设计期间通过模拟、形式化方法、仿真等来检查设计是否符合所需的安全属性。验证完成后，<strong>IFT</strong> 模型将被删除。动态硬件 <strong>IFT</strong> 是一种运行时机制，它通过跟踪逻辑来增强原始硬件设计，监视信息流行为并防止有害的信息流。通常需要付出额外的代价，例如，额外的资源使用和性能开销。</p><h2 id="模拟（simulation）"><a href="#模拟（simulation）" class="headerlink" title="模拟（simulation）"></a>模拟（simulation）</h2><p>模拟是验证硬件设计行为的常用方法。硬件安全模拟在测试台输入电路设计，观察结果是否违反了安全策略。</p><h2 id="形式化方法验证"><a href="#形式化方法验证" class="headerlink" title="形式化方法验证"></a>形式化方法验证</h2><p>形式化验证工具可以通过等价性检验、<strong>SAT</strong> 求解、定理证明或类型检验等方式，对信息流模型的安全属性进行形式化(或半形式化)验证。形式化方法的好处是，对于已证明的属性，硬件保证是安全的。验证结果在很大程度上依赖于指定的安全属性的质量和完整性。</p><h2 id="仿真（emulation）"><a href="#仿真（emulation）" class="headerlink" title="仿真（emulation）"></a>仿真（emulation）</h2><p>随着 <strong>IC</strong> 验证平台的发展，领先的 <strong>EDA</strong> 公司也开发了工具来验证 <strong>FPGA</strong> 仿真服务器上硬件设计的信息流安全属性。硬件仿真通常比软件仿真的验证性能好 <strong>10</strong> 倍。仿真是一种很有前途的方法，它利用底层硬件的信息流测量功能来执行安全协同验证并检测利用硬件安全漏洞的软件攻击。</p><h1 id="RTLIFT"><a href="#RTLIFT" class="headerlink" title="RTLIFT"></a>RTLIFT</h1><p>一种 <strong>RTLIFT</strong> 的实现步骤如下所示：设计流程跟踪库；增强跟踪逻辑的组合电路；用跟踪隐式流所需的逻辑增强条件语句。</p><p><img src="https://pic.imgdb.cn/item/63b50acfbe43e0d30ea3607b.jpg" alt=""></p><h2 id="流跟踪库"><a href="#流跟踪库" class="headerlink" title="流跟踪库"></a>流跟踪库</h2><p>为了通过 <strong>RTL</strong> 代码跟踪信息流，每个操作都应该进行检测，以便它可以同时对操作数的布尔值和安全标签进行操作。对于每个操作 <strong>OP</strong>，即 <strong>Z = X OP Y</strong> 是 <strong>Verilog</strong> 中的有效语句，我们定义了一个模块 <strong>OP_IFT</strong>，它接收输入 <strong>X</strong> 和 <strong>Y</strong> 以及它们的安全标签 <strong>X_t</strong> 和 <strong>Y_t</strong>，并生成输出 <strong>Z</strong> 和它的安全标签 <strong>Z_t</strong>。这些模块被预定义，并作为一个称为“流跟踪库”的输入文件提供给 <strong>RTLIFT</strong> 软件。</p><h2 id="显式流跟踪"><a href="#显式流跟踪" class="headerlink" title="显式流跟踪"></a>显式流跟踪</h2><p>流跟踪首先要对每个数据位进行扩展，即在给定的 <strong>Verilog</strong> 代码中连接寄存器，使用标签承载关于数据安全属性的信息。</p><h2 id="隐式流跟踪"><a href="#隐式流跟踪" class="headerlink" title="隐式流跟踪"></a>隐式流跟踪</h2><p>仅仅跟踪显式流可能会因为忽略隐式流的存在而错误地报告条件语句中不存在流。为了跟踪这些流程，对于每个赋值操作，我们都会获得一个影响语句执行的变量列表。在这个列表中，我们生成跟踪隐式流所需的逻辑。</p><p>引用文献：<br><code>Register Transfer Level Information Flow Tracking for Provably Secure Hardware Design. Armaiti Ardeshiricham, Wei Hu, Joshua Marxen and Ryan Kastner Dept. of Computer Science and Engineering, University of California, San Diego</code></p><p><code>Hardware Information Flow Tracking. WEI HU, Northwestern Polytechnical University ARMAITI ARDESHIRICHAM and RYAN KASTNER, University of California, San Diego</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> IFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P5 回顾</title>
      <link href="/2023/01/02/BUAA-CO-P5/"/>
      <url>/2023/01/02/BUAA-CO-P5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是 <strong>bluebean</strong> 的 <strong>P5</strong> 回忆。</p><p>从 <strong>P5</strong> 开始，计组的难度暴增。课上的 <strong>P5</strong> 也是大量同学挂 <strong>P</strong> 的起点。</p><p><strong>P5</strong> 要求我们设计一个五级流水线，并带有完备的转发、阻塞逻辑。</p><p>注：本篇博客中给出的实现方法均为笔者自己的实现方法。实际上的细节实现方法不唯一，笔者的方法也不一定是最优解。</p><h1 id="流水线结构"><a href="#流水线结构" class="headerlink" title="流水线结构"></a>流水线结构</h1><p>五级流水线包含以下内容：</p><ul><li>F级：进行取指令工作。</li><li>D级：进行指令的译码，并取出 <strong>GRF</strong> 中的数据。</li><li>E级：进行 <strong>ALU</strong> 运算操作。</li><li>M级：进行 <strong>DM</strong> 存取操作。</li><li>W级：将数据写回 <strong>GRF</strong> 中。</li></ul><p>其中每两级之间都存在<strong>流水线寄存器</strong>进行级和级之间的数据交换。</p><p>借用 <strong>gxp</strong> 老师 <strong>ppt</strong> 中的图片，流水线结构如下所示：</p><p><img src="../picture/p5_cpu.png" alt=""></p><h1 id="数据冒险与转发"><a href="#数据冒险与转发" class="headerlink" title="数据冒险与转发"></a>数据冒险与转发</h1><p>考虑以下指令：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">I1:</span> <span class="keyword">add </span>$<span class="number">2</span> $<span class="number">0</span> $<span class="number">1</span></span><br><span class="line"><span class="symbol">I2:</span> <span class="keyword">add </span>$<span class="number">3</span> $<span class="number">0</span> $<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>I1</strong> 和 <strong>I2</strong> 的指令在流水线中的流水情况可表示如下（<strong>nop</strong> 表示空指令）：</p><div class="table-container"><table><thead><tr><th>F级</th><th>D级</th><th>E级</th><th>M级</th><th>W级</th></tr></thead><tbody><tr><td>I1</td><td>nop</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>I2</td><td>I1</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>I1</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>I2</td><td>I1</td><td>nop</td></tr></tbody></table></div><p>我们可以看到，当 <strong>I1</strong> 处在 <strong>M</strong> 级时， <strong>I2</strong> 处在 <strong>E</strong> 级。<strong>I1</strong> 的数据要在 <strong>W</strong> 级才能写回 <strong>GRF</strong>，但是 <strong>I2</strong> 指令在 <strong>E</strong> 级就要使用 <strong>I1</strong> 提供的数据（<code>$2</code> 的数据）。如果不采用转发逻辑，则 <strong>I2</strong> 在 <strong>E</strong> 级进行计算时将会使用错误的数据进行计算。</p><p>这就是一种常见的数据冒险。解决数据冒险的办法是增加从 <strong>M</strong> 级到 <strong>E</strong> 级的数据通路，如下图所示（蓝线为新增数据通路）：</p><p><img src="../picture/p5_cpu1.png" alt=""></p><p>在将数据传入 <strong>ALU</strong> 时判断是否产生数据冲突，若产生冲突则采用转发过来的数据。</p><p>除了上图所示的 <strong>M</strong> 级向 <strong>E</strong> 级转发，流水线中还应该包括 <strong>W</strong> 级向 <strong>E</strong> 级转发、<strong>W</strong> 级向 <strong>M</strong> 级转发、<strong>M</strong> 级向 <strong>D</strong> 级转发、<strong>W</strong> 级向 <strong>D</strong> 级转发以及寄存器堆的内部转发。</p><p>这里解释一下寄存器堆的内部转发：在同一时刻，我们可能对同一个寄存器既读又写。在这种情况，我们读出的数据应当是要写入的数据（写入的数据是更新的数据）。这就是寄存器堆的内部转发。</p><p>推荐将转发功能综合成一个模块。拿我的实现举例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> AD1E = A1useE == <span class="number">1&#x27;b0</span> ? RD1E  :</span><br><span class="line"> A1E == <span class="number">1&#x27;b0</span> ? <span class="number">32&#x27;b0</span> :</span><br><span class="line"> A1E == A3M  ? DataM :</span><br><span class="line"> A1E == A3W  ? DataW : RD1E;</span><br><span class="line"><span class="keyword">assign</span> AD2E = A2useE == <span class="number">1&#x27;b0</span> ? RD2E  :</span><br><span class="line"> A2E == <span class="number">1&#x27;b0</span> ? <span class="number">32&#x27;b0</span> :</span><br><span class="line"> A2E == A3M  ? DataM :</span><br><span class="line"> A2E == A3W  ? DataW : RD2E;</span><br></pre></td></tr></table></figure><p>解释一下各个 <strong>wire</strong> 的含义：</p><ul><li><strong>AD1E</strong> 与 <strong>AD2E</strong>：<strong>AD</strong> 是 <strong>Adventure_Data</strong> 的缩写，<strong>E</strong> 代表数据来自 <strong>E</strong> 级，<strong>1</strong> 和 <strong>2</strong> 分别是要传入 <strong>ALU</strong> 的两个操作数。</li><li><strong>A1useE</strong> 与 <strong>A2useE</strong>：<strong>A1</strong> 与 <strong>A2</strong> 分别是要使用到的两个寄存器编号，<strong>use</strong> 代表指令有没有用到寄存器。（如 <strong>addi</strong> 的 <strong>A1use</strong> 是 <strong>1</strong>， <strong>A2use</strong> 是 <strong>0</strong>，因为第二个操作数不来自寄存器堆）</li><li><strong>RD1E</strong> 与 <strong>RD2E</strong>：来自流水线寄存器的流水数据。</li><li><strong>A1E</strong> 与 <strong>A2E</strong>：要使用的寄存器编号。</li><li><strong>A3M</strong> 与 <strong>A3W</strong>：在 <strong>M</strong> 级和 <strong>W</strong> 级的指令各自的写入寄存器编号。</li><li><strong>DataM</strong> 与 <strong>DataW</strong>：分别来自 <strong>M</strong> 级和 <strong>W</strong> 级的数据。</li></ul><p>如此便实现了 <strong>M</strong> 级和 <strong>W</strong> 级向 <strong>E</strong> 级的转发逻辑。其余的转发逻辑类似。可以集成到一个模块里。</p><h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><p>有些时候，转发不能处理所有的数据冲突。</p><p>举例而言：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I1: lw $<span class="number">1</span> <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line">I2: add $<span class="number">2</span> $<span class="number">1</span> $<span class="number">0</span></span><br></pre></td></tr></table></figure><br>假如不增加阻塞逻辑的话，指令流水如下所示：</p><div class="table-container"><table><thead><tr><th>F级</th><th>D级</th><th>E级</th><th>M级</th><th>W级</th></tr></thead><tbody><tr><td>I1</td><td>nop</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>I2</td><td>I1</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>I1</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>I2</td><td>I1</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>nop</td><td>I2</td><td>I1</td></tr></tbody></table></div><p>乍看好像没有问题。但是要注意：<strong>lw</strong> 指令与其他通常的指令不同，要在 <strong>M</strong> 级才能产生新的数据。所以当 <strong>I1</strong> 处于 <strong>M</strong> 级时，<strong>E</strong> 级的 <strong>I2</strong> 是拿不到新数据的。 <strong>I1</strong> 必须要流水到 <strong>W</strong> 级才能够提供最新的数据。</p><p>于是转发处理不了这种数据冲突。所以我们添加<strong>阻塞</strong>逻辑。在解释阻塞之前，先看添加了阻塞逻辑之后的流水图：</p><div class="table-container"><table><thead><tr><th>F级</th><th>D级</th><th>E级</th><th>M级</th><th>W级</th></tr></thead><tbody><tr><td>I1</td><td>nop</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>I2</td><td>I1</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>I1</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>nop</td><td>I1</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>I2</td><td>nop</td><td>I1</td></tr></tbody></table></div><p>可以看到，我们在 <strong>I1</strong> 和 <strong>I2</strong> 之间插入了一条 <strong>nop</strong>，从而让 <strong>I2</strong> 阻塞在 <strong>D</strong> 级。这样当 <strong>I2</strong> 流水到 <strong>E</strong> 级时，就可以拿到 <strong>I1</strong> 提供的新数据了。</p><p>实现阻塞，具体而言，是在阻塞的时候冻结 <strong>F</strong> 级和 <strong>D</strong> 级，并且向 <strong>E</strong> 级传递 <strong>nop</strong> 指令（指令码全为 <strong>0</strong>）。</p><p>我们使用 <strong>AT</strong> 法判断是否需要阻塞。这部分教程讲的很详细。在实现的时候，可以在 <strong>D</strong> 级增加一个处理阻塞的模块，将各级指令产生数据的周期和需要使用数据的周期传入这个模块。模块内部使用寄存器记录处于 <strong>E</strong> 级和 <strong>W</strong> 级指令的 <strong>Tnew</strong>。在 <strong>D</strong> 级接收新的指令时，由这个模块判断新的指令与处于流水过程中的指令产生的数据冲突是否必须采用阻塞解决。若需要阻塞，则由这个模块产生阻塞信号（<strong>stall</strong>）。</p><p>关于 <strong>AT</strong> 法的更多细节可以参考教程。</p><h1 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h1><p>因为我们是在 <strong>D</strong> 级译码，所以跳转指令的判断最早只能在 <strong>D</strong> 级。于是我们就在 <strong>D</strong> 级进行跳转指令的判断。</p><p>要注意，<strong>beq</strong> 指令要使用寄存器的数据，因此也需要对其进行转发和阻塞的判断。并且由于 <strong>beq</strong> 的 <strong>Tuse</strong> 是 <strong>0</strong> （在 <strong>D</strong> 级马上就要使用数据），因此理论上 <strong>beq</strong> 经常需要阻塞的情况。</p><p>在实现跳转时，我们需要在 <strong>D</strong> 级增加一个模块 <strong>NPC</strong>，其向 <strong>F</strong> 级提供跳转使能信号和跳转的目的地址。</p><h1 id="延迟槽"><a href="#延迟槽" class="headerlink" title="延迟槽"></a>延迟槽</h1><p>当我们进行指令跳转时，由于是在 <strong>D</strong> 级做出的判断，按照单周期 <strong>CPU</strong> 的逻辑，处于 <strong>F</strong> 级中的指令（即跳转指令紧跟的下一条指令）理论上就需要作废。</p><p>所谓延迟槽，就是我们让这条<strong>按照单周期逻辑应该作废的指令不作废</strong>，从而提高指令的运行效率。</p><p>事实上，对于延迟槽我们不需要进行额外的操作。无为就可以了（乐）。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p><strong>P5</strong> 的上机难度暴增。许多同学都在 <strong>P5</strong> 献出了首挂。</p><p>上机前建议向流水线中增加额外的数据通路以供课上指令使用（在流水线寄存器中增加课上指令的通路）。</p><p>此外 <strong>P5</strong> 的课上数据点虽然也有课下的强测，但是分布不均，并且大多数测试点仍然是测试课上指令的，这一点与 <strong>P3</strong>、<strong>P4</strong> 不同。</p><p>在课上要认真读题，确保自己读懂了题目再开始写代码。在增加指令的时候一定要仔细地考虑，将每一条指令相关的信号都进行相应的判断。如涉及跳转指令除了要修改 <strong>Controller</strong> 外，还要修改 <strong>NPC</strong> 中的跳转使能信号和跳转地址。</p><p>在课上不要过于拘泥于流水线的结构。有些课上指令十分阴间。比如要在 <strong>M</strong> 级才能得知写入寄存器的编号此类。</p><p>此外就是在课上之前要好好休息，休养精神。笔者因为当天过于疲惫，在课上睡着以至于献出了首挂。大家不要学我啊呜呜呜。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P5</strong> 开始难度骤增。不过如果 <strong>P5</strong> 做的比较好，<strong>P6</strong> 就会简单很多。至于 <strong>P7</strong>，那就又是另一个故事了……</p><p>在这里特别感谢 <strong>yt</strong> 的帮助。没有 <strong>yt</strong>，就没有我的 <strong>p5</strong> （哭）。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P4 回顾</title>
      <link href="/2023/01/01/BUAA-CO-P4/"/>
      <url>/2023/01/01/BUAA-CO-P4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从 <strong>P4</strong> 开始，我们就告别 <strong>logisim</strong>，进入 <strong>verilog</strong> 的领域了。</p><p><strong>P4</strong> 要做的事情很简单，使用 <strong>verilog</strong> 实现单周期 <strong>CPU</strong>。<strong>P4</strong> 的任务实际上就是要把 <strong>P3</strong> 的 <strong>CPU</strong> 翻译到 <strong>verilog</strong> 语言。</p><p>根据不同的实现细节，在 <strong>P4</strong> 会需要数百行的码量。<strong>P4</strong> 的任务相对不难。在编写代码的时候要有良好的代码风格，遵循命名规范。</p><h1 id="CPU-设计"><a href="#CPU-设计" class="headerlink" title="CPU 设计"></a><strong>CPU</strong> 设计</h1><p>在设计上可以完全照搬 <strong>P3</strong> 中用 <strong>logisim</strong> 实现的 <strong>CPU</strong>。另外建议进行模块化设计。<strong>P3</strong> 的模块 <strong>P4</strong> 里最好都继承（或改编）过来，<strong>P3</strong> 中没有综合成模块的地方视情况也可以综合为模块。</p><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><p>在 <strong>verilog</strong> 中遵循一套自己的命名规范是很重要的。无论是驼峰法还是下划线法还是其他的规范，必须在整个代码中遵循同一套命名规范才能利于自己写代码。许多同学在大一的时候没有特意培养自己的代码风格。我的建议是可以在计组实验里开始初步培养代码风格，而不是等到下学期的 <strong>OO</strong>。</p><p>此外，能够让代码更美观的办法比如对齐等。举个例子：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> RegWrite = Add | Sub | And | Or  | Sll |</span><br><span class="line">                  Srl | Lw  | Lui | Ori | Jal |</span><br><span class="line">                  Andi| <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><p>如果将大量堆到一行里或者行之间不对齐都会导致代码的可读性降低。因此，培养良好的代码风格，从 <strong>P4</strong> 开始！</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>在有时序功能模块中记得将寄存器初始化。<strong>GRF</strong> 模块可以直接申请一个寄存器堆，在初始化的时候使用 <strong>for</strong> 循环初始化。要特别注意 <strong>GRF</strong> 中 <strong>0</strong> 号寄存器的值始终为1。</p><p>另外特殊的 <strong>IM</strong> 模块的初始化要使用 <code>$readmemh()</code>。</p><h1 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h1><p>关于 <strong>Controller</strong> 中信号的产生，可以使用宏定义的方式，或使用 <strong>wire</strong> 定义的方式。我个人采用了 <strong>wire</strong> 生成信号，距离如下：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Ori = op == <span class="number">6&#x27;b001101</span> ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> Lw  = op == <span class="number">6&#x27;b100011</span> ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> Sw  = op == <span class="number">6&#x27;b101011</span> ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><br>如此生成对应指令的信号。在使用的时候相当于直接将线接到对应的位置上。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p><strong>P4</strong> 的上机难度和 <strong>P3</strong> 相当，也不是很困难。</p><p>小提示：要提前留好给课上用的接口。这样会方便于通过课上。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>单周期 <strong>CPU</strong> 的绝大多数难点重点工作在 <strong>P3</strong> 中其实都已经设计完了。在 <strong>P4</strong> 中你所需要做的只有耐心的翻译代码。</p><p>话虽如此，<strong>P4</strong> 必须要认真搭建，<strong>P4</strong> 的单周期 <strong>CPU</strong> 是接下来几个 <strong>P</strong> 的起点，也是熟练 <strong>verilog</strong> 语法的机会。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 单周期CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P3 回顾</title>
      <link href="/2022/12/31/BUAA-CO-P3/"/>
      <url>/2022/12/31/BUAA-CO-P3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从 <strong>P3</strong> 开始，工作量暴增。<strong>P3</strong> 的任务是我们使用 <strong>logisim</strong> 搭建一个单周期 <strong>CPU</strong>。想搭好这个 <strong>CPU</strong>，既要充分地掌握 <strong>logisim</strong> 的语法，又得学习单周期 <strong>CPU</strong> 的架构。</p><p>以下我将结合自身搭建的过程举例，讲解 <strong>CPU</strong> 的搭建过程。</p><h1 id="CPU-的顶层模块"><a href="#CPU-的顶层模块" class="headerlink" title="CPU 的顶层模块"></a><strong>CPU</strong> 的顶层模块</h1><p>在搭建前，要对 <strong>CPU</strong> 的整体架构有一个大致的把握。</p><p>单周期 <strong>CPU</strong> 的顶层包含的模块：<strong>PC</strong>，<strong>IM</strong>，<strong>Splitter</strong>，<strong>Controller</strong>，<strong>GRF</strong>，<strong>ALU</strong>，<strong>DM</strong>。</p><p>除此之外也可以增加一些自定义模块，起到增加 <strong>CPU</strong> 集成度，简化布线等作用。</p><p>我自己在 <strong>P3</strong> 增加了两个模块：<strong>GRFChooser</strong> 和 <strong>ALUChooser</strong>，分别选择 <strong>GRF</strong> 和 <strong>ALU</strong> 的输入信号。</p><p>我的 <strong>CPU</strong> 顶层模块一览：</p><p><img src="https://pic.imgdb.cn/item/63b048632bbf0e79945cbd1a.png" alt=""></p><p>通过编辑模块外观做到了简洁布线，视觉效果整体较为美观。</p><h1 id="PC"><a href="#PC" class="headerlink" title="PC"></a><strong>PC</strong></h1><p><strong>PC</strong> 模块的输出端口需要提供当前的指令地址。其输入端口需要包含跳转地址与跳转使能信号。</p><p><strong>PC</strong> 模块在功能上要做到以下两点：</p><ol><li>在经过一个周期后 <strong>PC</strong> 值能自增 <strong>4</strong>。</li><li>在收到跳转类指令时能修改 <strong>PC</strong> 的值到目标地址。</li></ol><h1 id="IM"><a href="#IM" class="headerlink" title="IM"></a><strong>IM</strong></h1><p><strong>IM</strong> 使用 <strong>ROM</strong> 模块实现即可。</p><p>我们需要做的只是初始化 <strong>RAM</strong> 内部数据。将当前指令地址连接到 <strong>RAM</strong> 的地址端，数据端就是对应的 <strong>指令值</strong>。</p><h1 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a><strong>Splitter</strong></h1><p><strong>Splitter</strong> 需要将读到的指令进行拆分，拆分成不同信号传递给不同的模块以供使用。</p><p>其内部直接使用分线器实现即可。</p><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a><strong>Controller</strong></h1><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>在 <strong>Controller</strong> 我们要进行指令的译码工作。根据指令的内容生成相应的控制信号。</p><p>一般而言需包含以下控制信号：</p><ul><li><strong>ALUControl</strong>：控制 <strong>ALU</strong> 模块行为，根据不同指令 <strong>ALU</strong> 对输入需要实现不同的运算。</li><li><strong>MemWrite</strong>：控制 <strong>DM</strong> 模块的写入使能信号。</li><li><strong>GRFWrite</strong>：控制 <strong>GRF</strong> 模块的写入使能信号。</li></ul><p>此外根据个人实现的不同还需要生成跳转信号（<strong>Jal</strong> 和 <strong>Beq</strong>）以及 <strong>GRF</strong>、<strong>ALU</strong>、<strong>DM</strong> 的相应选择信号。</p><p>拿我个人举例，我生成了 <strong>RegChoose</strong> 信号传递给 <strong>REGChooser</strong> 模块来选择读取 <strong>GRF</strong> 的寄存器；生成 <strong>ALUChoose</strong> 模块来选择 <strong>ALU</strong> 模块的操作数；生成 <strong>MemtoReg</strong> 信号来控制写入 <strong>GRF</strong> 的信号是来自 <strong>ALU</strong> 还是 <strong>DM</strong>。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p><strong>Controller</strong> 只需要对指令中的 <strong>op</strong> 字段和 <strong>func</strong> 字段进行译码。因此实际上只需要传入这两个信号就可以。在内部生成信号时，采用与逻辑判断指令，或逻辑生成信号。举例而言：</p><p>采用与逻辑判断指令：<br><img src="../picture/Controller.png" alt=""></p><p>采用或逻辑生成控制信号：<br><img src="../picture/Controller2.png" alt=""></p><p>我的 <strong>Controller</strong> 内的控制信号基本上都是按照这样的逻辑生成的，仅供参考。</p><h1 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a><strong>GRF</strong></h1><p><strong>GRF</strong> 这个东西大家应该在 <strong>P0</strong> 做过了，直接拿过来用就行。这个模块没有什么技术含量，硬着头皮连线就行。</p><h1 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a><strong>ALU</strong></h1><p>运算的操作数都使用 <strong>32</strong> 位数。一般而言需要完成基本的加减乘除还有移位操作。</p><p>所有运算操作都可以使用 <strong>logisim</strong> 内置的运算器实现。</p><h1 id="DM"><a href="#DM" class="headerlink" title="DM"></a><strong>DM</strong></h1><p><strong>DM</strong> 使用 <strong>RAM</strong> 部件即可。<strong>Data Interface</strong> 可设置成 <strong>Separate load and store ports</strong></p><p>下图是 <strong>DM</strong> 的具体连线：</p><p><img src="../picture/DM.png" alt=""></p><p>其中 <strong>MemAddr</strong> 来自于 <strong>ALU</strong> 的运算结果，<strong>MemData</strong> 是写入 <strong>DM</strong> 的数据，来自于 <strong>GRF</strong>。</p><h1 id="ALU-和-GRF-的信号片选"><a href="#ALU-和-GRF-的信号片选" class="headerlink" title="ALU 和 GRF 的信号片选"></a><strong>ALU</strong> 和 <strong>GRF</strong> 的信号片选</h1><p>这部分可以按照自己的方式自行设计。</p><p>我在这部分的设计是这样的：</p><ol><li>传给 <strong>ALU</strong> 的第一个操作数默认来自 <strong>GRF</strong> 的 <strong>RD1</strong>，于是在 <strong>REGChooser</strong> 模块里要对传给 <strong>GRF</strong> 的第一个读数地址 <strong>A1</strong> 进行相应的选择。</li><li>传给 <strong>ALU</strong> 的第二个操作数从 <strong>GRF</strong> 的 <strong>RD2</strong>、指令的 <strong>shamt</strong> 字段（用于 <strong>sll</strong>  和 <strong>srl</strong> 指令的移位操作）、有符号扩展立即数和无符号扩展立即数（立即数来自于指令的立即数字段）。</li><li><strong>GRF</strong> 的写入数据来自于 <strong>DM</strong>、<strong>ALU</strong>、以及指令的 <strong>instr_index</strong> 字段（用于 <strong>Jal</strong> 指令）。</li><li>根据要实现的以上功能，依据不同的指令生成对应的控制信号。集成设计 <strong>Chooser</strong> 。</li></ol><p>关于我在这部分的连线可以参考上文的顶层模块图。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p>上机的时候会让你添加一些奇怪的指令。在课下建议扩展移位指令 <strong>sll</strong> 和 <strong>srl</strong> ，以及存取指令 <strong>sb</strong>、<strong>sh</strong>、<strong>lb</strong>、<strong>lh</strong>。此外对 <strong>logism</strong> 中一些基本但是不常用的运算器等也要好好掌握，比如 <strong>Bit Adder</strong>。</p><p>在课上扩展指令的时候要仔细判断控制信号的生成。建议在课下的 <strong>CPU</strong> 中预留接口。我在课上添加指令的时候基本都是采用对课上指令特判的方式。整体而言，<strong>P3</strong> 的课上是很简单的，只要课下做的足够认真，课上 <strong>AK</strong> 都不会有问题。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P3</strong> 是我搭建的第一个 <strong>CPU</strong>。当时是照着计组的大黑书生闷硬造的。从整体架构到细节都由自己设计，看着搭建完的 <strong>CPU</strong> 心中是成就感满满。</p><p>这或许也是学习计组的乐趣所在吧。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> 单周期CPU </tag>
            
            <tag> logisim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P0 到 P2 回顾</title>
      <link href="/2022/12/31/BUAA-CO-P0-P2/"/>
      <url>/2022/12/31/BUAA-CO-P0-P2/</url>
      
        <content type="html"><![CDATA[<p>在写下这篇博客的时候，<strong>CO</strong> 课程已经结束了。在此回忆并记录一下计组实验过程中那些难忘的经历。</p><h1 id="P0"><a href="#P0" class="headerlink" title="P0"></a><strong>P0</strong></h1><p><strong>P0</strong> 要求我们掌握 <strong>logisim</strong> 的基本用法，并且要会在 <strong>logisim</strong> 中实现摩尔型状态机和米莉型状态机。</p><p>关于 <strong>logisim</strong> 的基本部件，我在学习的时候主要参考查阅了以下博客：</p><p><a href="https://blog.csdn.net/Hi_KER/article/details/120928866">Logisim元件用法详解一：Wiring 线</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121044637">Logisim元件用法详解二：Gates 门</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121049347">Logisim元件用法详解四：Arithmetic 运算器</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121046215">Logisim元件用法详解三：Plexers 复用器</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121059937">Logisim元件用法详解五：Memory 储存库</a></p><p>这几篇博客对基本部件的基本功能叙述基本齐全，在学习 <strong>logisim</strong> 的时候给了我很大帮助。</p><p>在此补充一下关于 <strong>ROM</strong> 和 <strong>RAM</strong> 部件的使用方法：</p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a><strong>ROM</strong></h2><p><strong>ROM</strong> 是只读存储器。在我们的课程中主要用于 <strong>P3</strong> 中指令存储器的设计。</p><p>侧边栏功能介绍：</p><p><img src="../picture/RAM.png" alt=""></p><ul><li><strong>Address Bit Width</strong>：这是地址位数，决定 <strong>ROM</strong> 的容量。</li><li><strong>Data Bit Width</strong>：这是数据的位数。</li><li><strong>Contents</strong>：点击这里来编辑 <strong>ROM</strong> 中的内容。</li></ul><p>编辑 <strong>RAM</strong> 中的内容需要打开文本文件。点击 <strong>Contents</strong> 后页面如下所示：<br><img src="../picture/RAMContents.png" alt=""><br>点击 <strong>Open</strong> 可以选择载入 <strong>txt</strong> 中的内容。点击 <strong>Save</strong> 可以将 <strong>ROM</strong> 中的内容保存在本地文件中。</p><p><strong>logisim</strong> 对于载入 <strong>ROM</strong> 的文本有格式要求：首行必须是 <code>v2.0 raw</code>，并且以十六进制格式导入数据。</p><p>比如我上面那个 <strong>Contents</strong> 示例就是将以下内容导入到 <strong>ROM</strong> 之后的结果。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v2.0 raw</span><br><span class="line">3c1fff10</span><br><span class="line">37ff00ff</span><br><span class="line">0c000c00</span><br></pre></td></tr></table></figure><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a><strong>RAM</strong></h2><p><strong>RAM</strong> 是随机存储存储器。其 <strong>Address Bit Width</strong> 和 <strong>Data Bit Width</strong> 的意义和 <strong>ROM</strong> 相同。<strong>Data Interface</strong> 可以改变 <strong>RAM</strong> 的存取端口设置。</p><p>在 <strong>P3</strong> 中，一般采用 <strong>Separate load and store ports</strong> 设置（分离的加载和存储端口）。</p><p>此外我们可以右键 <strong>RAM</strong> 模块，来编辑或清空 <strong>RAM</strong> 模块的内容。编辑 <strong>RAM</strong> 模块内容的方法和 <strong>ROM</strong> 相同。</p><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>要好好理解摩尔型状态机和米莉型状态机的区别，明确实现方法。</p><h3 id="摩尔型状态机"><a href="#摩尔型状态机" class="headerlink" title="摩尔型状态机"></a>摩尔型状态机</h3><p>一言以蔽之，输出只取决于当前状态，次态由当前状态和输入共同决定，在时钟上升沿来临时更改状态。</p><h3 id="米莉型状态机"><a href="#米莉型状态机" class="headerlink" title="米莉型状态机"></a>米莉型状态机</h3><p>与摩尔型状态机不同的地方在于<strong>输出由当前状态和输入共同决定</strong>。这意味着，当输入改变时，即使时钟上升沿没有到来，输出也应该随着输入的改变而做出相应的变化。</p><h3 id="同步复位与异步复位"><a href="#同步复位与异步复位" class="headerlink" title="同步复位与异步复位"></a>同步复位与异步复位</h3><p>异步复位的做法十分简单，直接将复位信号连接到 <strong>register</strong> 的 <strong>reset</strong> 端口即可。</p><p>同步复位则稍微复杂一些。给出一个往届的方法：</p><p><img src="../picture/reset2.png" alt=""></p><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p>设计状态机的过程中最重要的一点是设计好状态转移的过程。 <strong>logisim</strong> 中可以根据真值表自动生成电路。这个方法在计组的教程中讲的已经十分详细了。在我们设计的状态机的状态位数和输入位数之和不太多的情况下，可以利用这一功能快速生成状态转移模块。</p><p>具体做法如下：</p><p><img src="../picture/Moore.png" alt=""></p><p>因为按照真值表生成的电路的输入输出端口只能是一位的，故我们要将状态转移模块的输入拆分开，输出合并起来。上图中 <strong>register</strong> 中存储现态， <strong>now</strong> 代表现态输出，<strong>in</strong> 代表输入，<strong>next</strong> 代表次态。这个电路中的 <strong>MUX</strong> 起到了同步复位的作用。</p><p>其中状态转移模块内部就是由 <strong>logisim</strong> 根据真值表自动生成的电路。我们不需要关心内部具体是什么样子的，只需要保证我们的转移逻辑和拆分、合并信号时连线没有错误就可以。</p><h2 id="编辑模块外观"><a href="#编辑模块外观" class="headerlink" title="编辑模块外观"></a>编辑模块外观</h2><p><strong>logisim</strong> 默认的模块外观总是比较丑陋的…我们可以点击这个摁钮来编辑模块的外观：</p><p><img src="../picture/logisim.png" alt=""></p><p>我们可以编辑模块的形状、端口位置、添加文字说明等等。通过编辑模块的外观我们可以大大美化电路，这在 <strong>P3</strong> 中尤为明显（或许不是十分的重要）。</p><h2 id="合理运用-Tunnel"><a href="#合理运用-Tunnel" class="headerlink" title="合理运用 Tunnel"></a>合理运用 <strong>Tunnel</strong></h2><p><strong>Tunnel</strong> 是尤为常用的一个部件。合理使用 <strong>Tunnel</strong> 能大大简化我们的布线，让模块整体更加美观。但是不建议滥用 <strong>Tunnel</strong>。滥用的缺点是让电路更难看懂（因为不能直观的看到连线情况）。</p><h2 id="一个-logisim-的-bug"><a href="#一个-logisim-的-bug" class="headerlink" title="一个 logisim 的 bug"></a>一个 <strong>logisim</strong> 的 <strong>bug</strong></h2><p>我在 <strong>P0</strong> 上机的时候遇到了一个 <strong>logisim</strong> 的 <strong>bug</strong>：所有的连线全部是蓝色 的。遇到这种情况首先要检查 <strong>Simulate</strong> 设置中的 <strong>Simulation Enable</strong> 选项，这个选项应该是打开的；然后在保存后直接重启 <strong>logisim</strong> 就可以恢复啦！</p><h1 id="P1"><a href="#P1" class="headerlink" title="P1"></a><strong>P1</strong></h1><p>在 <strong>P1</strong> 中我们要掌握 <strong>Verilog</strong> 的基本语法，学会组合逻辑和时序逻辑，并且要会在 <strong>Verilog</strong> 中写状态机。</p><h2 id="常数的写法"><a href="#常数的写法" class="headerlink" title="常数的写法"></a>常数的写法</h2><p><strong>verilog</strong> 中常数的写法是 <code>&lt;常数位数&gt;&#39;&lt;类型&gt;&lt;值&gt;</code>。教程里说的很详细，这里不再多说。</p><p>主要是想提醒大家在写代码的时候每一个数字都要遵循 <code>&lt;常数位数&gt;&#39;&lt;类型&gt;&lt;值&gt;</code> 的形式，不要没头没尾的写一个数字上去。一般而言，写 <strong>verilog</strong> 程序中我们接触二进制、十六进制数字的次数要比十进制数字的次数多得多。</p><h2 id="阻塞赋值与非阻塞赋值"><a href="#阻塞赋值与非阻塞赋值" class="headerlink" title="阻塞赋值与非阻塞赋值"></a>阻塞赋值与非阻塞赋值</h2><p>在初学 <strong>Verilog</strong> 时要区分阻塞赋值与非阻塞赋值。</p><h3 id="阻塞赋值"><a href="#阻塞赋值" class="headerlink" title="阻塞赋值"></a>阻塞赋值</h3><p>阻塞赋值使用 <code>=</code>。阻塞赋值可以理解为物理上的直接连线。当右边的值（驱动量）发生变化时，左侧值将立刻发生变化。建议只在组合逻辑中使用阻塞赋值。</p><p>阻塞赋值一般是赋值给 <strong>wire</strong> 型变量的。但是视情况也可以赋值给 <strong>reg</strong> 型变量和 <strong>integer</strong> 型变量。</p><h3 id="非阻塞赋值"><a href="#非阻塞赋值" class="headerlink" title="非阻塞赋值"></a>非阻塞赋值</h3><p>非阻塞赋值使用 <code>&lt;=</code>。非阻塞赋值会在一个块结束后统一赋值。比如下列代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">    b &lt;= a;</span><br><span class="line">    a &lt;= b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以上代码的结果是在每一个时钟上升沿到来时交换 <strong>a</strong> 和 <strong>b</strong> 的值。非阻塞赋值建议只在 <strong>always</strong> 块内给 <strong>reg</strong> 型变量赋值使用（时序逻辑）。</p><h2 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h2><p>组合逻辑有两种写法，一种是使用 <strong>wire</strong> 和阻塞赋值（下称连线），一种是使用 <strong>wire</strong> 和 <code>always@(*)</code> 块内使用非阻塞赋值。我个人比较喜欢使用第一种写法。在进行条件判断时，要嵌套三目运算符 <code>? :</code>。</p><p>使用第一种写法时注意 <strong>wire</strong> 型变量只能连线一次。此外可以在定义 <strong>wire</strong> 型变量时直接连线。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> judge = <span class="keyword">input</span> &amp; <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]ans = en == <span class="number">1&#x27;b0</span> ? <span class="number">2&#x27;b00</span> :</span><br><span class="line">                judge == <span class="number">1&#x27;b1</span> ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b10</span>;</span><br></pre></td></tr></table></figure><p>上述代码的功能：当使能信号 <strong>en</strong> 为 <strong>0</strong> 时，<strong>ans</strong> 保持为 <strong>0</strong>，当使能信号为 <strong>1</strong> 且输入为奇数时， <strong>ans</strong> 为 <strong>1</strong>，否则为 <strong>2</strong>。</p><h2 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h2><p>时序逻辑使用 <strong>always</strong> 块和非阻塞赋值。建议一个模块只使用一个 <strong>always</strong> 块，并且在一个 <strong>always</strong> 内要保证每个时钟上升沿来临时对使用到的每个 <strong>reg</strong> 变量都<strong>有且仅有</strong>一次赋值。</p><p>在时序逻辑中可以使用 <em>if-else</em> 语句和 <em>switch</em> 语句进行条件判断。不再多说。</p><h2 id="同步复位与异步复位-1"><a href="#同步复位与异步复位-1" class="headerlink" title="同步复位与异步复位"></a>同步复位与异步复位</h2><p>同步复位的写法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset == <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行复位操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行其他操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>异步复位的写法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset == <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行复位操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行其他操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这两种复位方法都要掌握，在上机时一般都会考到。</p><h2 id="状态机-1"><a href="#状态机-1" class="headerlink" title="状态机"></a>状态机</h2><p>在通过 <strong>P0</strong> 之后相信对两种状态机已经足够了解了。在 <strong>verilog</strong> 中实现两种状态机并不难。合理地将组合逻辑和时序逻辑组合使用便可以搭建两种状态机。在写状态机的时候最重要的还是设计状态和状态转移逻辑，编写代码只需要足够的细心即可。</p><p>在编写时序逻辑的时候要注意每一个 <strong>if</strong> 块都要有 <strong>else</strong> 作为结尾，在 <strong>else</strong> 内部编写 <strong>default</strong> 逻辑。</p><h1 id="P2"><a href="#P2" class="headerlink" title="P2"></a><strong>P2</strong></h1><p>在 <strong>P2</strong> 中，我们要掌握 <strong>Mars</strong> 的用法。<strong>Mars</strong> 的用法在教程里教的很详细，不再多说。这里主要是提几点建议和要注意的地方。</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>写 <strong>Mars</strong> 程序时要合理地使用宏（<code>.micro</code>）来简化代码。诸如读取数字、输出数字、数据的压栈、弹栈等都可以使用宏来编写。这里给两个压栈和弹栈的例子：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据压栈</span></span><br><span class="line"><span class="meta">.macro</span> stackPush(%num)</span><br><span class="line"><span class="keyword">sw </span>%num <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">sp</span> $<span class="built_in">sp</span> -<span class="number">4</span></span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据弹栈</span></span><br><span class="line"><span class="meta">.macro</span> stackPop(%num)</span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">sp</span> $<span class="built_in">sp</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">lw </span>%num <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>写递归的时候要注意数据的压栈和弹栈。在进入函数的时候压栈，在函数结束的时候弹栈。</p><p>一般使用 <strong>$a0-$a3</strong> 来进行函数的传参，使用 <strong>$v0-$v1</strong> 来接受函数的返回值。</p><h2 id="Mars-文档"><a href="#Mars-文档" class="headerlink" title="Mars 文档"></a><strong>Mars</strong> 文档</h2><p>在 <strong>Mars</strong> 中 <strong>F1</strong> 键可以调出 <strong>Mars</strong> 帮助文档。在写代码的时候可以提供莫大帮助。在上机前建议弄懂字符串的读写，我这届有许多同学因为不了解字符串的读写而在 <strong>P2</strong> 上机的时候翻车。</p><h2 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h2><p><strong>P2</strong> 上机写 <strong>Mars</strong> 代码个人感触最重要的还是细心。在 <strong>P2</strong> 中哪怕写错一个寄存器的名字也会寄。细心编写的代码能减少 $80$% 的 <strong>bug</strong>。我在上机时遇到的 <strong>bug</strong> 基本全都是因为粗心导致的。</p><p>在上机前可以提前在机房电脑上做一些准备，诸如调整机房里 <strong>Mars</strong> 的字体设置等；也可以背下来一些宏，提前敲进去。</p><p>一般而言 <strong>P2</strong> 的上机都是翻译 <strong>C</strong> 语言代码。如果他没有给出 <strong>C</strong> 代码，那就自己写一份 <strong>C</strong> 代码再翻译成 <strong>Mars</strong> 代码，能减少 <strong>bug</strong> 数量和 <strong>dbug</strong> 难度。在翻译代码的时候合理分配那几个寄存器的使用，个人翻译本身感觉难度不大。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大致回忆了一下 <strong>P0</strong> 到 <strong>P2</strong> 的知识点和坑点。这几个 <strong>P</strong> 都是在为后面搭 <strong>CPU</strong> 打基础，因此难度不是很大。</p><p>欢迎在评论区讨论交流。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> logisim </tag>
            
            <tag> mips </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
