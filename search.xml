<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面向对象课程 HW11</title>
      <link href="/2023/05/17/OO-hw11/"/>
      <url>/2023/05/17/OO-hw11/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于涉及了图以及图上的算法，本次作业的难度较高。难点主要在于单源最短环的查找方式。</p><p>本次作业添加了几个新的 <strong>Message</strong> 种类：<strong>EmojiMessage</strong>，<strong>NoticeMessage</strong>，<strong>RedEnvelopeMesssage</strong>。均按照规格写，无需过多改动此前的代码。</p><p>需要进行改动的代码主要是 <strong>NetWork</strong> 中的 <strong>addMessage</strong> 类和 <strong>sendMessage</strong> 类，需要针对不同的消息类型做出对应的处理。</p><p>此外需要完成单源最短环的查找（<strong>queryLeastMoments</strong>）。</p><h2 id="第十一次作业设计"><a href="#第十一次作业设计" class="headerlink" title="第十一次作业设计"></a>第十一次作业设计</h2><p>重点谈谈对于单源最短环的设计吧：</p><p>起初，我的设计是删边法 + 最短路：</p><p>对于起点 <strong>i</strong>，假如点 <strong>j</strong> 与 <strong>i</strong> 直接相连，则删掉此边后查询 <strong>i</strong> 和 <strong>j</strong> 之间是否仍然存在路径。若存在路径，则一个可能的最短环值就是 $u_{i,j}+Dijkstra_{i,j}$，遍历所有与起点直接相连的点即可找到最短环。</p><p>这个做法易于理解，实现起来并不复杂，我本来打算就用这个写法来着。当我按照这个设计写完之后，经过计算、考虑和询问助教后，认为这个方法的时间复杂度比较危险。按照我的预计，有可能会 <strong>t</strong> 掉 <strong>1-2</strong> 个点。（后来我交了一下这个做法发现果然会 <strong>t</strong> 掉一个点）</p><p>本来想着就这样算了，但是后来在周末的时候又觉得有点点不甘心，于是就对原来的方法进行了优化。</p><p>优化的方法参考了讨论区内的帖子和 <strong>CSDN</strong> 上的博客，在此不进行正确性证明，只描述一下我的实现方式：</p><p>首先以源点开始跑一遍 <strong>dijkstra</strong> 算法，能够得到图上所有点到源点的最短路的值。在跑最短路的过程中记录每个点和其父节点，最终我们可以得到一颗以源点为祖节点的生成树：</p><p><img src="https://pic2.imgdb.cn/item/646491260d2dde577788937d.jpg" alt="树图"></p><p>然后我们在树中尝试添加一条边来构造最短环。这条边的两个顶点不能处于同一颗子树下，否则生成的环路中不包含源点。</p><p>设源点为 <strong>o</strong>。于是对于树中的每一个定点 <strong>i</strong>，选择的边的另一个顶点 <strong>j</strong> 有两种情况：</p><ol><li><strong>j</strong> 是源点且 <strong>i</strong> 的父节点不是源点（若是源点则无环）。</li><li><strong>j</strong> 是其他子树上的定点。</li></ol><p><img src="https://pic2.imgdb.cn/item/646493f90d2dde57778d679f.jpg" alt="树图2"></p><p>对于第一种情况，得到的环值为 $Dijkstra_{o,i}+u_{o,i}$。对于第二种情况，得到的环值为 $Dijkstra_{o,i}+Dijkstra_{o,j}+u_{i,j}$。</p><p>遍历所有树上的顶点即可得到最短环值。</p><p>在实现过程中，为快速判断两个顶点是否是同一颗子树下，可以使用并查集。这部分可以复用以前的并查集代码。在实现 <strong>dijkstra</strong> 的过程中可以利用 <strong>Java</strong> 的优先队列进行优化。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>这里给出我实现 <strong>qlm</strong> 的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> id;                             <span class="comment">// 源点id</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; nodes;    <span class="comment">// 存储点到源点的距离</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; preId;    <span class="comment">// 存储每个点的父节点</span></span><br><span class="line">DisjointSet diffTree;               <span class="comment">// 存储不同子树的并查集</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;                       <span class="comment">// 存储答案</span></span><br><span class="line">dijkstra(id, nodes, preId);</span><br><span class="line">preIds.forEach((nowId, preId) -&gt; &#123;  <span class="comment">// 存储子树</span></span><br><span class="line">            <span class="keyword">if</span> (preId != id) &#123;</span><br><span class="line">                diffTree.merge(nowId, preId);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Person person: people.values()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (person.hasPath() &amp;&amp; person.id != id) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: person.getAcquaintance().keyset()) &#123; <span class="comment">// 所有与当前 person 直接相连的人的 id</span></span><br><span class="line">            <span class="keyword">if</span> (i == id) &#123;</span><br><span class="line">                <span class="comment">// 判断对应条件，更新 ans</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 判断对应条件，更新 ans</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// throw sth</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure><h2 id="OKTest"><a href="#OKTest" class="headerlink" title="OKTest"></a>OKTest</h2><p>本次作业的 <strong>OKTest</strong> 要求我们对 <strong>deleteColdEmoji</strong> 方法进行 <strong>OKTest</strong> 测试。</p><p>难点主要在于理解晦涩的 <strong>JML</strong>。</p><h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><p>本次作业没有遇上什么让我值得一记的 <strong>bug</strong>，强测和互测都顺利通过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次作业难度主要体现在 <strong>qlm</strong> 还有课程组飘忽不定的 <strong>JML</strong> 上。不得不吐槽的是 <strong>OKTest</strong> 的 <strong>JML</strong> 的可读性真的巨差，我时常怀疑是否是我的理解能力出现了问题还是说 <strong>JML</strong> 的可读性就是这么差劲。后来我用自然语言翻译了一遍 <strong>OKTest</strong> 的 <strong>JML</strong>，发现自然语言真是好用多了，帮同学 <strong>debug</strong> 也不用读 <strong>JML</strong> 了，主打的叫一个舒服。</p><h2 id="黑箱测试与白箱测试"><a href="#黑箱测试与白箱测试" class="headerlink" title="黑箱测试与白箱测试"></a>黑箱测试与白箱测试</h2><p>黑箱测试是从软件外部对软件进行测试，只关注输入和输出，不考虑软件是如何实现的。黑箱测试也称为功能测试或数据驱动测试，它主要根据功能需求设计测试用例，检验软件是否能按照规格说明书的要求正常工作。黑箱测试的优点是与软件具体实现无关，如果软件实现发生了变化，测试用例仍可用；缺点是可能遗漏一些内部错误或逻辑缺陷。黑箱测试常用的方法有等价类划分、边界值分析、因果图、决策表分析等。</p><p>黑箱测试的优点：</p><ul><li>独立性：黑盒测试相对于开发团队是相对独立的，测试人员可以独立进行测试，减少了开发者对测试过程的干扰。</li><li>用户导向：黑盒测试从用户的角度出发，关注系统是否满足用户需求和规格要求，能够更好地验证系统的功能和用户体验。</li><li>代码无关：黑盒测试不需要了解系统的内部实现细节和代码逻辑，测试人员只需关注输入和输出之间的关系。</li></ul><p>黑箱测试的缺点:</p><ul><li>遗漏内部错误：由于黑盒测试不考虑系统的内部结构和代码逻辑，可能无法发现由于内部错误或代码缺陷引起的问题。</li><li>覆盖范围有限：黑盒测试通常基于需求和规格说明，因此测试用例的设计可能受到这些文档的限制，导致无法覆盖所有可能的情况。</li><li>效率低下：由于黑盒测试无法直接访问系统的内部，测试人员需要通过用户界面或其他接口来进行测试，这可能导致测试过程效率较低。</li></ul><p>白箱测试的优点：</p><ul><li>内部错误发现：白盒测试可以深入系统的内部，检查代码的执行路径、逻辑错误、边界条件等，有助于发现由于代码缺陷引起的问题。</li><li>覆盖全面：通过访问系统的内部结构和代码，白盒测试可以设计更全面的测试用例，覆盖不同的代码路径和分支情况。</li><li>性能优化：白盒测试可以评估系统的性能瓶颈和资源利用情况，帮助开发团队进行性能优化和调优。</li></ul><p>白箱测试的缺点：</p><ul><li>依赖开发者技能：白盒测试需要测试人员具备一定的编程和调试技能，以理解代码逻辑并编写相应的测试用例。</li><li>开发团队的参与：由于白盒测试通常由开发团队的一部分执行，可能存在开发者对自己代码的偏见，导致测试过程缺乏独立性。</li><li>时间和资源消耗：白盒测试需要深入理解系统的内部结构和代码，因此可能需要更多的时间和资源来进行测试和分析。</li></ul><h2 id="数据构造策略"><a href="#数据构造策略" class="headerlink" title="数据构造策略"></a>数据构造策略</h2><p>本单元在做测试时我主要是针对自己的代码做的白箱测试。通过构造特定的图以及相应的指令来满足覆盖率的要求。这样做测试的针对性较高，基本不到十个数据点即可满足覆盖率的要求。相应的是编写测试点需要耗费较多的精力。</p><h2 id="规格与实现相分离"><a href="#规格与实现相分离" class="headerlink" title="规格与实现相分离"></a>规格与实现相分离</h2><p>规格与实现分离是一种软件设计的原则，它要求在编写软件需求规格说明时，只描述软件的功能和性能，而不描述软件的内部结构和实现方法。这样可以使软件需求更清晰、更稳定、更容易验证，也可以使软件设计和开发更灵活、更自由、更有创新。</p><p>规格是对系统功能、行为和性能的描述，通常以需求规格说明、设计规范或用户文档的形式存在。它们是开发团队与客户、用户之间的合同和共享理解的基础。规格的目的是定义系统应该做什么，而不是如何实现它。</p><p>实现是指将规格转化为实际的软件代码和系统组件的过程。它涉及开发者根据规格进行编码、调试、测试和部署的工作。实现的目的是将规格转化为具体的可执行代码，以实现系统的功能和要求。</p><p>这个原则实际上我们经常接触；打比方，在做题时题目只给出了要求完成的功能，没有限制实现的方法。我认为这也是一种规格与实现相分离（出题者和做题者之间）。</p><h2 id="OKTest-的理解"><a href="#OKTest-的理解" class="headerlink" title="OKTest 的理解"></a>OKTest 的理解</h2><p>本单元的 <strong>OKTest</strong> 要我们对于某些方法的正确性以及副作用按照规格进行检测。实际上是写了一个小型的评测机。</p><p>本单元中，我认为 <strong>OKTest</strong> 的输入输出接口设计得不算太好。虽然课程组使用的 <strong>HashMap</strong> 能在一定程度上方便代码的编写，但是我认为按照 <strong>JML</strong> 规格要求的 <strong>people-person-(acquaintanceId, value)</strong> 来传入数据或许是一个更好的选择。即在第九、十次作业中传入 <strong>Person[] people</strong> 而非 <strong>Hashmap</strong>，在第十一次作业中传入 <strong>Message[] messages, int[] emojiIdList, int[] emojiHeatList</strong>。这样是更容易让人理解，至于建图这种事情，我认为应当交给我们自己做。</p><h2 id="单元总结"><a href="#单元总结" class="headerlink" title="单元总结"></a>单元总结</h2><p>本单元接触了 <strong>JML</strong> 语言，让我深深体会到了这种语言的不足与局限性。我来细数一下我在本单元中对 <strong>JML</strong> 语言体会到的不便：</p><ol><li>同一个意思使用 <strong>JML</strong> 语言可能会有不同的表达方式，在较大的工程中不同的表达方式会给阅读者带来理解上的困难。比方说，<em>“对于所有 <strong>i</strong>，都满足条件 <strong>cond</strong>”</em> 这句话，我们既可以使用 <code>ensures (\forall i; 0 &lt;= i &amp;&amp; i &lt;= max; cond)</code>，也可以使用 <code>ensures !(\exist i; 0 &lt;= i &amp;&amp; i &lt;= max; !cond)</code>。不同的规格编写者有可能会写出不同的 <strong>JML</strong> 代码。阅读者在阅读 <strong>JML</strong> 时，一旦习惯了某一种表述方式，突然更换表述方式则会带来理解上的不便。</li><li><strong>JML</strong> 代码的正确性依赖于编写者。一旦 <strong>JML</strong> 代码出现了正确性问题，会带给阅读者深深的烦恼，而且越大的工程在迭代时维护 <strong>JML</strong> 会带来更大的困难。本单元的 <strong>JML</strong> 代码可以说是经常出现问题，每次作业都会出现规格上的错误，包括本单元的实验。这给同学们带来了不小的麻烦。</li><li><strong>JML</strong> 不易描述过于复杂的算法。或者说使用 <strong>JML</strong> 语言描述过于复杂的算法会让 <strong>JML</strong> 的体积过于庞大，让阅读者很难提起阅读的兴趣。使用自然语言几句话便可以解释清楚，使用 <strong>JML</strong> 语言则动辄数十行。这一问题在第十一次作业中的 <strong>queryLeastMoments</strong> 方法和 <strong>sendMessage</strong> 中体现的尤为明显。前者由于描述了一个相对比较复杂的算法，在 <strong>ensures</strong> 中不停地嵌套语句导致可读性降低；后者是由于方法要处理的情况稍稍有些复杂导致 <strong>JML</strong> 代码的行数足足有六十行。我的做法是读一句翻译一句，将 <strong>JML</strong> 语言翻译成我能看懂的自然语言，但是这样一来就体会不到 <strong>JML</strong> 语言的优越性了。</li><li>如果使用自然语言描述方法，那么时隔多日再次回看依然能够快速理解方法要干什么；但是如果使用 <strong>JML</strong> 语言描述方法，别说时隔多日了，我一边写代码一边都要搞不懂 <strong>JML</strong> 在说些什么。这个问题在同第三点的两个方法中体现得淋漓尽致。</li><li>阅读和编写 <strong>JML</strong> 都需要花费额外的学习精力。单单阅读的话还好，编写出好的 <strong>JML</strong> 则非常需要透彻理解方法并且将方法前后方方面面考虑得仔细透彻才能够写出一个相对合格的 <strong>JML</strong> 代码。代价未免有些太大了。</li></ol><p>此外写第十一次作业的时候给我一种强烈的写算法题的感觉。这个感觉主要来源于最短环算法的复杂性。如果完全按照课程组的数据范围，则一般的算法难以满足课程组的要求。我们不敢赌课程组的数据强度，也不敢赌到底怎样的时间复杂度能够满足课程组的要求。在这种情况下，我们只好尽可能卷算法。感觉本单元对算法的考察远大于前两个单元（第二单元最复杂的是最短路，远比最短环简单），不知道课程组在单元初说的 <em>“本单元对算法的考察有所减弱，希望大家不要卷错方向~”</em> 体现在哪里。</p><h2 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h2><p>在本单元中大量使用了 <strong>HashMap</strong>，在第十一次作业中还使用了 <strong>PriorityQueue</strong>，让我对 <strong>Java</strong> 对这两种数据结构的支持有了更深入的理解。同时也学会了使用迭代器遍历数组等，以及使用 <strong>removeIf()</strong> 等简化循环的小技巧。通过一些课外的扩展对 <strong>Java</strong> 的一些语言特性有了更深入了认知，可以说这段日子我对 <strong>Java</strong> 的理解更加深入了。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> JML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW10</title>
      <link href="/2023/05/17/OO-hw10/"/>
      <url>/2023/05/17/OO-hw10/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次作业增加了 <strong>Message</strong>，<strong>Group</strong> 两个类。 <strong>NetWork</strong> 中增加了配套的一系列方法。并在原有的关系上增加了 <strong>modifyRelation</strong> 方法。</p><h2 id="第十次作业设计"><a href="#第十次作业设计" class="headerlink" title="第十次作业设计"></a>第十次作业设计</h2><p><strong>Message</strong> 没什么好说的，按着规格写就可以了。</p><p><strong>Group</strong> 类涉及到了 <strong>ageVar</strong> 的查询操作，采取动态维护策略即可。</p><p>要提一提的是 <strong>modifyRelation</strong> 方法。这个方法的作用是更改一对关系的值。如果更改后的值小于等于 <strong>0</strong>，则删除此对关系。</p><p>删除操作对于第九次作业中影响比较大的地方有并查集的维护和三角关系数量的维护。</p><p>对于并查集的维护：</p><p>朴素的思想是每次删边都重建并查集。但是考虑到每次建立并查集的复杂度为 <strong>O(\nlog(n))</strong>，每次删边都重建并查集是有很大概率会 <strong>t</strong> 的。于是我引入了一个 <strong>dirty</strong> 位。当发生了删边操作时，将 <strong>dirty</strong> 位置真。当涉及到查询并查集的操作时（即 <strong>isCircle</strong> 和 <strong>queryBlockSum</strong>），若 <strong>dirty</strong> 位为真，则重建并查集，否则直接查询。</p><p>对于三角关系的维护：</p><p>我的做法是将每一组三元关系保存下来（手写了一个 <strong>Tuple</strong> 类），当删边操作发生时，遍历所有三元关系，若三元对中包含了删边的两个点，则将此三元关系移除，并将 <strong>cntTriple</strong> 减一。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> disjoinSetDirty;        <span class="comment">// 脏位</span></span><br><span class="line"></span><br><span class="line">modifyRelation() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ... do sth</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*cond*/</span>) &#123;             <span class="comment">// 发生了删边操作</span></span><br><span class="line">        delCircle();            <span class="comment">// 维护三角形边数</span></span><br><span class="line">        disjoinSetDirty = <span class="literal">true</span>; <span class="comment">// 维护脏位</span></span><br><span class="line">        <span class="comment">//  do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isCircle() &#123;</span><br><span class="line">    <span class="keyword">if</span> (disjoinSetDirty) &#123;</span><br><span class="line">        rebuildDisjointSet();   <span class="comment">// 重建并查集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queryBlockSum() &#123;</span><br><span class="line">    <span class="keyword">if</span> (disjoinSetDirty) &#123;</span><br><span class="line">        rebuildDisjointSet();   <span class="comment">// 重建并查集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OKTest"><a href="#OKTest" class="headerlink" title="OKTest"></a>OKTest</h2><p>本次作业要求对 <strong>modifyRelation</strong> 方法进行 <strong>OKTest</strong> 测试。总共需要对输入输出进行 <strong>21</strong> 条规格测试。测试量比较大，写起来的难度相对也比较大。需要十分的仔细以及对 <strong>OKTest</strong> 进行充分的测试才能够保证没有 <strong>bug</strong>。</p><h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><p>本次作业在写 <strong>OKTest</strong> 的时候因为疏忽写出了几个 <strong>bug</strong>，所幸都通过做测试找到了，因此在强测和互测中没有被刀到。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次作业的难度有所增加，但由于正巧遇上了五一假期，所以时间比较充裕，进行写代码和测试的时间都比较充足。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> JML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW9</title>
      <link href="/2023/05/16/OO-hw9/"/>
      <url>/2023/05/16/OO-hw9/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本单元主要做的事情是读 <strong>JML</strong> 并且按照 <strong>JML</strong> 描述的规格编写对应的代码。在代码难度上较前两个单元有所下降，但是耗费的时间不一定比前两个单元少…</p><h2 id="第九次作业设计"><a href="#第九次作业设计" class="headerlink" title="第九次作业设计"></a>第九次作业设计</h2><p>虽然是按着 <strong>JML</strong> 写代码，但是具体的实现方式完全由自己决定，<strong>JML</strong> 只是规定了你要实现什么，没有说你要怎么做。</p><p>第九次作业中实现了以下几个类：</p><ul><li>NetWork：社交网络类</li><li>Person：人员类</li></ul><p>人们处于同一个社交网络中，人和人之间可能有 “好友” 关系。本次作业中主要要实现的 <strong>NetWork</strong> 功能有：</p><ul><li>addPerson：向社交网络中添加一个人</li><li>addRelation：建立两个人之间的关系</li><li>queryValue：查询两个人的关系值</li><li>isCircle：查询两个人之间是否有好友链</li><li>queryBlockSum：查询有几个不同的好友链</li><li>queryTripleSum：查询有几对三角关系（三个人之间相互认识）</li></ul><p>在 <strong>Person</strong> 中要实现 <strong>id-value</strong> 的映射，在 <strong>NetWork</strong> 中要实现 <strong>id-person</strong> 的映射。很自然地使用 <strong>HashMap</strong> 来存储这两组键值关系。</p><p>此外实现了一个并查集来存储人员之间的关系。当两个人建立关系时，将此二人塞到同一颗树下。这样查询两个人直接是否有好友链和查询有几个不同的好友链时都可以直接查询，无需额外的时间开销。</p><p>针对三角关系的查询，采取了动态维护的策略。比如说，当建立 $A$ 与 $B$ 的关系时，遍历 $A$ 的所有熟人 $C_i$，若 $C_i$ 与 $B$ 之间有关系则让计数加一。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集</span></span><br><span class="line">DisjoinSet:</span><br><span class="line">merge();        <span class="comment">// 合并</span></span><br><span class="line">addPerson();    <span class="comment">// 添加人</span></span><br><span class="line">find();         <span class="comment">// 以上均为并查集内函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> blockSum;   <span class="comment">// 好友链数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merge: blockSum--;</span><br><span class="line"><span class="keyword">if</span> addPerson: blockSum++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 社交网络</span></span><br><span class="line">NetWork:</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cntTriple;</span><br><span class="line"></span><br><span class="line">addPerson(person1, person2):</span><br><span class="line">    <span class="keyword">for</span> person in person1.acquaintance</span><br><span class="line">        <span class="keyword">if</span> <span class="title function_">isCircle</span><span class="params">(person2, person)</span> </span><br><span class="line">            cntRtiple++;</span><br></pre></td></tr></table></figure><h2 id="OKTest"><a href="#OKTest" class="headerlink" title="OKTest"></a>OKTest</h2><p>本次作业的 <strong>OKTest</strong> 是对 <strong>queryTripleSum</strong> 进行 <strong>OKTest</strong>。由于只需要判断结果是否正确，因此在保证自己代码正确的前提下，可以直接将输入输出塞到自己的 <strong>netWork</strong> ，输出出来做比较。</p><h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><p>本次作业完成的比较顺利，没有遇到什么 <strong>bug</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次作业作为第三单元的初次作业，难度并不大。主要难点在于理解 <strong>JML</strong> 上。由于指导书写的过于扑朔迷离，所以不得不仔细阅读 <strong>JML</strong> 才能写完代码。但是官方 <strong>JML</strong> 存在一些问题，对同学们造成了一些困扰。造成了不太良好的写题体验。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> JML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW7</title>
      <link href="/2023/04/13/OO-hw7/"/>
      <url>/2023/04/13/OO-hw7/</url>
      
        <content type="html"><![CDATA[<p>本次作业新增了以下两个约束：</p><ol><li>新增的电梯有可达性要求，即只能在特定的楼层停靠。</li><li>限制了在同一层开门的电梯数量。</li></ol><p>本次作业主要的难点在于当停掉所有的全能电梯（即初始的六部电梯）后需要对乘客规划路径。本次作业中动态规划路径 + 加权最短路取得了非常优秀的成绩（我的大佬同学）。</p><p>本次作业中我重新考虑了以下电梯的移动逻辑、添加了搜索路径算法与电梯开门数量控制。</p><h2 id="运行策略"><a href="#运行策略" class="headerlink" title="运行策略"></a>运行策略</h2><p><strong>hw5</strong> 与 <strong>hw6</strong> 的策略相似，但是策略不是很能适应 <strong>hw7</strong> 的需求。</p><p>本次作业中，电梯采取了类似 <strong>look</strong> 策略的掉头逻辑。当前方没有任务请求且电梯乘客队列为空时则掉头。这样设计带来的好处是电梯可以接受不同方向的乘客请求。</p><h2 id="分配乘客策略"><a href="#分配乘客策略" class="headerlink" title="分配乘客策略"></a>分配乘客策略</h2><p>首先尝试直接分配乘客。接下来若乘客已被规划过路径且路径中的电梯没有维护则乘客按照既定的路径。否则给乘客规划新的路径。</p><p>存储路径的方式：使用一个二位数组 <strong>path[][2]</strong>。<strong>path[i][0]</strong> 的含义是要乘坐第 <strong>i</strong> 部电梯的 <strong>id</strong>。<strong>path[i][1]</strong> 的含义是要乘坐该部电梯所到达的楼层。</p><h2 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h2><p>采取类似最小生成树的方式寻找路径。每次尝试添加一部电梯，若尝试添加的电梯的可达楼层与当前可达楼层没有交集或是当前可达楼层的子集，则不添加这个电梯；否则加入这个电梯，直到当前可达楼层包含乘客目的地时，代表我们找到了一个路径。之后就是把路径提取出来。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>AllRequest.AllRequest(ArrayList\<Request\>)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.getRequest()</td><td>4.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>AllRequest.getRequests()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.isEmpty()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.isEnd()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.run()</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Building.addPassenger(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Building.addService(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Building.Building(AllRequest, ArrayList\<Request\>)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Building.delService(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Building.directlyAlloc(Passenger)</td><td>13.0</td><td>4.0</td><td>6.0</td><td>10.0</td></tr><tr><td>Building.elevatorEnd()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.findPath(Passenger)</td><td>25.0</td><td>7.0</td><td>9.0</td><td>13.0</td></tr><tr><td>Building.handleFindPath(Information, Passenger, ArrayList\<int\[]\[]\>)</td><td>27.0</td><td>1.0</td><td>13.0</td><td>15.0</td></tr><tr><td>Building.handleRequest()</td><td>12.0</td><td>7.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Building.isEnd()</td><td>1.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Building.openAble(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Building.pasAlloc(Passenger)</td><td>12.0</td><td>7.0</td><td>8.0</td><td>9.0</td></tr><tr><td>Building.run()</td><td>3.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.step()</td><td>13.0</td><td>1.0</td><td>8.0</td><td>8.0</td></tr><tr><td>Elevator.capacityAlloc()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.carry(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.Elevator(int, int, double, int, int, int, Building)</td><td>6.0</td><td>1.0</td><td>1.0</td><td>4.0</td></tr><tr><td>Elevator.findBottom()</td><td>4.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Elevator.findTop()</td><td>4.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Elevator.getAccess()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getId()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getState()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.goDie()</td><td>13.0</td><td>4.0</td><td>11.0</td><td>11.0</td></tr><tr><td>Elevator.hasPassenger()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Elevator.ifDirectly(Passenger)</td><td>2.0</td><td>3.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Elevator.ifOff()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Elevator.ifOff(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.ifTake()</td><td>4.0</td><td>4.0</td><td>2.0</td><td>4.0</td></tr><tr><td>Elevator.ifTake(Passenger)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isDie()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEmpty()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEnd()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isFree()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.move()</td><td>15.0</td><td>3.0</td><td>6.0</td><td>12.0</td></tr><tr><td>Elevator.setDie(boolean)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.step()</td><td>22.0</td><td>8.0</td><td>16.0</td><td>19.0</td></tr><tr><td>Elevator.takeOff()</td><td>7.0</td><td>2.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Elevator.takeOff(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.takeOn()</td><td>5.0</td><td>2.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Elevator.takeOn(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.tryClose()</td><td>1.0</td><td>2.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Elevator.tryOpen()</td><td>5.0</td><td>2.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Information.add(int, int, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.getAccess(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.getAccessById(int)</td><td>3.0</td><td>3.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Information.getId(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.getNow(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.getPathLen(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.growPathLen(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.setNow(int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Information.size()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>MainClass.main(String[])</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.addPath(int[])</td><td>3.0</td><td>1.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Passenger.clearPath()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getDirection()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getFinish()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getFistPath()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getId()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getPath()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getStart()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.Passenger(int, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.removePathHead()</td><td>3.0</td><td>1.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Passenger.setPath(int[][])</td><td>4.0</td><td>3.0</td><td>2.0</td><td>4.0</td></tr><tr><td>Passenger.takeOff(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.getValue()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isClosing()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isDie()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isOpen()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isOpening()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isRunning()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isWait()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setClosing()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setDie()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setOpen()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setOpening()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setRunning()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setWait()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.State(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>225.0</td><td>141.0</td><td>193.0</td><td>235.0</td></tr><tr><td>Average</td><td>2.616279069767442</td><td>1.6395348837209303</td><td>2.244186046511628</td><td>2.7325581395348837</td></tr></tbody></table></div><p>本次作业复杂度中搜索路径的两个方法复杂度较高。这部分我写的这部分太面向过程了。</p><h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><p>本次作业由于把分配乘客的间隔设置为 <strong>1s</strong> 而寄了五个点…要不本来只会寄一个点，只能说是弄巧成拙了。后来检查的时候发现是乘客分配的锅，但是我也没有找到到底是哪里有问题…于是最后在电梯步进的时候对任务队列做了一个强检查，要是不能达到乘客需求的楼层就把他弹回楼里。</p><h2 id="协作关系"><a href="#协作关系" class="headerlink" title="协作关系"></a>协作关系</h2><p>由于本单元均为状态机逻辑，故没有线程之间的协作关系</p><h2 id="Dbug技巧"><a href="#Dbug技巧" class="headerlink" title="Dbug技巧"></a>Dbug技巧</h2><p>单线程的状态机 <strong>dbug</strong> 还是比较简单的，出了问题之后感觉哪里有问题在哪里添加 <strong>println</strong> 打印状态就可以了。而且所有 <strong>bug</strong> 都能够稳定复现，我在本单元基本没有为 <strong>dbug</strong> 苦恼过。</p><h2 id="本单元收获"><a href="#本单元收获" class="headerlink" title="本单元收获"></a>本单元收获</h2><p>遗憾的是，本单元并没有怎么学习到多线程的精髓…收获最大的大概是和同学一起搭的评测机。本单元由于测试一个点的时间过长，于是评测机需要是多进程的，于是乎在这个过程中学习了一些多进程的写法，也算是学到了一些新东西。此外前两次的数据生成也是由我负责的，从自己生成的数据与课程组强测的数据对比我也学习到了一些数据生成的要领。事实上，单纯由程序随机生成的数据总是有缺陷的。最优解是通过随机跑出来一些数据之后通过手动微调数据，或者直接手搓一些特殊的测试点。第六次作业我自己生成的数据强度还是比较认可的，就是因为太强了而不满足互测标准从而没法在互测里直接用…不过那个评测机 <strong>d</strong> 出来的 <strong>bug</strong> 是真不少。</p><p>在学习的过程中也感受到了不同科目之间的交叉性。比如 <strong>OO</strong> 课内讲到的概念在 <strong>OS</strong> 上也会有提及。另外 <strong>CO</strong> 的状态机设计也助我通过了本次作业。事实上貌似只要设计的好，电梯这单元无论如何使用状态机都是有出路的。来年或许可以想一个办法 <strong>ban</strong> 掉状态机（如果当上了助教的话）。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 电梯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW6</title>
      <link href="/2023/04/04/OO-hw6/"/>
      <url>/2023/04/04/OO-hw6/</url>
      
        <content type="html"><![CDATA[<p>本次作业在第五次作业的基础上新增了两个功能：</p><ol><li>允许新增自定义电梯。</li><li>允许电梯进入维护状态（即从系统中移除此电梯）</li></ol><p>自定义电梯里可自定义的参数：运行速度、载客数量、起始楼层</p><h2 id="新增电梯与维护电梯"><a href="#新增电梯与维护电梯" class="headerlink" title="新增电梯与维护电梯"></a>新增电梯与维护电梯</h2><p>新增电梯没什么特别好说的，获取电梯的各个参数然后直接 <strong>add</strong> 进 <strong>building</strong> 的电梯数组里就可以。</p><p>维护电梯事实上就是给电梯发出一个死亡信号，让这个电梯立刻停下手中的工作，然后让其去世，最后将其从 <strong>building</strong> 的电梯数组中删除。</p><p>在死亡过程中，首先释放电梯尚未接到的任务。然后让电梯立刻转到开门状态（如果已经处于开门状态则不开门），释放内部乘客后将其置为死亡状态。</p><h2 id="重构部分"><a href="#重构部分" class="headerlink" title="重构部分"></a>重构部分</h2><p>在 <strong>Hw6</strong> 的过程中小小的重构了一下自己的代码。</p><p>主要内容包括：将时钟周期置为 <strong>0.1s</strong>。为新的请求类型添加了解析方法。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>AllRequest.AllRequest(ArrayList\<Request>)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.getRequest()</td><td>4.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>AllRequest.getRequests()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.isEmpty()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.isEnd()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>AllRequest.run()</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Building.Building(AllRequest, ArrayList\<Request>)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Building.elevatorDie(Elevator)</td><td>15.0</td><td>6.0</td><td>14.0</td><td>14.0</td></tr><tr><td>Building.elevatorEnd()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.findNearEmpty(int)</td><td>6.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Building.handleRequest()</td><td>12.0</td><td>7.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Building.isEnd()</td><td>1.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Building.pasAlloc(Passenger)</td><td>9.0</td><td>6.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Building.run()</td><td>3.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.step()</td><td>11.0</td><td>1.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Elevator.capacityAllow(Passenger)</td><td>12.0</td><td>6.0</td><td>1.0</td><td>6.0</td></tr><tr><td>Elevator.carry(Passenger)</td><td>6.0</td><td>1.0</td><td>1.0</td><td>4.0</td></tr><tr><td>Elevator.checkBegin()</td><td>5.0</td><td>2.0</td><td>4.0</td><td>6.0</td></tr><tr><td>Elevator.Elevator(int, int, double, int, int, int, int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Elevator.findBottom()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.findTop()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.getFloor()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getId()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getPassengers()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getState()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.getTasks()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.ifOff()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Elevator.ifOff(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.ifPassingly(Passenger)</td><td>11.0</td><td>7.0</td><td>4.0</td><td>7.0</td></tr><tr><td>Elevator.ifTake()</td><td>6.0</td><td>3.0</td><td>2.0</td><td>4.0</td></tr><tr><td>Elevator.ifTake(Passenger)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isDie()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEmpty()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEnd()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isFree()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.move()</td><td>20.0</td><td>2.0</td><td>6.0</td><td>9.0</td></tr><tr><td>Elevator.setDie(boolean)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.step()</td><td>21.0</td><td>3.0</td><td>14.0</td><td>16.0</td></tr><tr><td>Elevator.takeOff()</td><td>4.0</td><td>2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Elevator.takeOff(Passenger)</td><td>6.0</td><td>1.0</td><td>1.0</td><td>4.0</td></tr><tr><td>Elevator.takeOffAll()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.takeOn()</td><td>4.0</td><td>2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Elevator.takeOn(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.tryClose()</td><td>4.0</td><td>3.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Elevator.tryOpen()</td><td>7.0</td><td>4.0</td><td>6.0</td><td>7.0</td></tr><tr><td>MainClass.main(String[])</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getDirection()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getFinish()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getId()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getStart()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.Passenger(int, int, int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Passenger.takeOff(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.getValue()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isClosing()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isOpen()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isOpening()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isRunning()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.isWait()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setClosing()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setOpen()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setOpening()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setRunning()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.setWait()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>State.State(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>187.0</td><td>113.0</td><td>152.0</td><td>185.0</td></tr><tr><td>Average</td><td>2.8333333333333335</td><td>1.7121212121212122</td><td>2.303030303030303</td><td>2.803030303030303</td></tr></tbody></table></div><p>本次作业的复杂度依然控制在一个可以接受的程度。事后发现了一些架构上的优化方法，可以进一步优化复杂度。</p><h2 id="bug-分析"><a href="#bug-分析" class="headerlink" title="bug 分析"></a>bug 分析</h2><p>本次作业没有出现 <strong>bug</strong>，并在强测中拿到了 <strong>96.5</strong> 的成绩。由于状态机本质上是单线程逻辑，所以所有 <strong>bug</strong> 都可以稳定复现，在 <strong>dbug</strong> 的时候也相对方便（在需要观察的地方添加 <strong>println</strong>）。</p><p>在本次作业中由于将时钟周期设置为 <strong>0.1s</strong>，导致整体刷新速度过于频繁，反而导致了更久的 <strong>CPU</strong> 时长。经过综合考虑，我决定在下次作业里将时钟周期重设为更合理的 <strong>0.2s</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 电梯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW5</title>
      <link href="/2023/03/25/OO-hw5/"/>
      <url>/2023/03/25/OO-hw5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>电梯月来咯~</p><p>虽然本单元理论上应该写多线程，但是我却采用了状态机逻辑…虽然这可能与训练目标不太一样，不过是正确的就好辣~</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>经过仔细地评估、设计后，我的代码中除了 <code>MainClass</code> 外只包含四个类。类图如下所示：</p><p><img src="https://pic.imgdb.cn/item/64200f56a682492fccac5c58.jpg" alt="类图"></p><ul><li><strong>Request</strong>：请求</li><li><strong>Building</strong>：楼</li><li><strong>Elevator</strong>：电梯</li><li><strong>Passenger</strong>：乘客</li></ul><h2 id="对各类的分析与评估"><a href="#对各类的分析与评估" class="headerlink" title="对各类的分析与评估"></a>对各类的分析与评估</h2><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>本类占据一个线程，负责拉取乘客的请求。</p><p>评价：没啥好说的。</p><h3 id="Building"><a href="#Building" class="headerlink" title="Building"></a>Building</h3><p>本类占据一个线程，负责六部电梯的运行以及分配乘客请求给电梯。</p><p>方法介绍：</p><h4 id="step"><a href="#step" class="headerlink" title="step"></a>step</h4><p>使状态机前进一个周期。</p><h4 id="isEnd"><a href="#isEnd" class="headerlink" title="isEnd"></a>isEnd</h4><p>判断状态机整体是否运行完毕。</p><h4 id="elevatorEnd"><a href="#elevatorEnd" class="headerlink" title="elevatorEnd"></a>elevatorEnd</h4><p>判断各个电梯是否运行完毕。</p><h4 id="pasAlloc"><a href="#pasAlloc" class="headerlink" title="pasAlloc"></a>pasAlloc</h4><p>尝试将乘客分配给电梯，分配失败返回 <strong>false</strong>。</p><h4 id="findNearEmpty"><a href="#findNearEmpty" class="headerlink" title="findNearEmpty"></a>findNearEmpty</h4><p>寻找与目标楼层最近的空电梯。</p><h4 id="Building评价"><a href="#Building评价" class="headerlink" title="Building评价"></a>Building评价</h4><p>本类是状态机的核心类。有关状态机的逻辑都包含在本类之中。</p><h3 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h3><p>电梯类。负责电梯的具体行为。</p><p>对于电梯，我具有两个乘客队列：<strong>tasks</strong> 队列中的乘客未入梯但是已被分配给这个电梯；<strong>passengers</strong> 队列中的乘客则已经进入了这个电梯。</p><p>在判断能否接客时，采用一个桶子（即属性 <strong>cnt</strong>）记载电梯的占用情况。</p><p>方法介绍：</p><h4 id="tryOpen"><a href="#tryOpen" class="headerlink" title="tryOpen"></a>tryOpen</h4><p>尝试开门操作。</p><h4 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h4><p>尝试进行关门、开门操作。</p><h4 id="move"><a href="#move" class="headerlink" title="move"></a>move</h4><p>尝试进行移动操作。</p><h4 id="ifCarry"><a href="#ifCarry" class="headerlink" title="ifCarry"></a>ifCarry</h4><p>判断电梯是否可以接受该乘客。（主要从容量方面考虑该乘客是否能买到“票”）</p><h4 id="ifPassingly"><a href="#ifPassingly" class="headerlink" title="ifPassingly"></a>ifPassingly</h4><p>判断电梯是否可以捎带该乘客。</p><h4 id="Elevator评价"><a href="#Elevator评价" class="headerlink" title="Elevator评价"></a>Elevator评价</h4><p>本类是电梯类，承载了电梯的所有行为逻辑。</p><h3 id="Passenger"><a href="#Passenger" class="headerlink" title="Passenger"></a>Passenger</h3><p>本类是乘客类，记录了一个乘客所包含的所有信息。</p><p>对于乘客的 <strong>state</strong>（状态）定义如下：</p><ul><li><strong>0</strong>：乘客尚未进入电梯</li><li><strong>1</strong>：乘客已经进入电梯</li></ul><p>没啥好评价的，普普通通的乘客类。</p><h2 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a>运行逻辑</h2><p>电梯的忙碌状态定义：</p><ul><li><strong>free</strong>：电梯中没有乘客且任务队列为空。</li><li><strong>empty</strong>：电梯中没有乘客但任务队列非空。</li><li><strong>busy</strong>：电梯中存在乘客。</li></ul><p>电梯的运行状态（<strong>action</strong>）定义：</p><ul><li><strong>true</strong>：本轮时钟周期可以进行行动。</li><li><strong>false</strong>：本轮时钟周期已经行动过了，不能进行行动。</li></ul><p><strong>Building</strong> 在初始化时会创建六个电梯。</p><p>一个时钟周期设置为 <strong>400ms</strong>。</p><p>每轮时钟周期首先尝试给电梯分配任务。分配完任务后电梯的运行逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Elevator elevator: elevators) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!elevator.isFree() || elevator.isOpen()) &#123;</span><br><span class="line">        elevator.init(); <span class="comment">// 将 action 置为 true</span></span><br><span class="line">        elevator.operator();</span><br><span class="line">        elevator.move();</span><br><span class="line">        elevator.tryOpen(); <span class="comment">// 到了一层后可以尝试开门</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>始终步进直至达到停止条件。</p><h2 id="移动策略"><a href="#移动策略" class="headerlink" title="移动策略"></a>移动策略</h2><p>首先需要保证每时每刻都保证电梯的乘客队列和任务队列中所有请求的方向（下文简称为请求方向）是一致的（由调度保证）。</p><p>电梯在运行共分为三个状态：</p><p><strong>FREE</strong>：保持不动</p><p><strong>EMPTY</strong>：前往最底部的请求所处的楼层（如果请求方向是上则要尽可能去更低的楼层开始接人，反之同理）。</p><p><strong>BUSY</strong>：保持当前运行方向直至所有乘客都到达了目的地。</p><h2 id="乘客分配策略"><a href="#乘客分配策略" class="headerlink" title="乘客分配策略"></a>乘客分配策略</h2><p>首先尝试将乘客分配给电梯捎带。</p><p>这里的捎带分为两种情况：</p><ul><li>对于 <strong>empty</strong> 的电梯：<ul><li>乘客与电梯运行方向一致时：待分配的乘客与电梯当前运行方向相同，且电梯尚未运行到乘客起始楼层，且电梯容量足够，则判断为可捎带。</li><li>乘客与电梯运行方向不一致时：待分配的乘客与电梯任务队列中的乘客的请求方向一致，且电梯容量足够，则判断为可捎带。</li></ul></li><li>对于 <strong>busy</strong> 的电梯：待分配的乘客与电梯当前运行方向相同，且电梯尚未运行到乘客起始楼层，且电梯容量足够，则判断为可捎带。</li></ul><p>若无法捎带，则分配给最近的<strong>空电梯</strong>。这里的空电梯指电梯处于 <strong>free</strong> 状态，即乘客队列与任务队列均为空。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Building.Building(int, ArrayList\<Passenger>, Request)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Building.elevatorEnd()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.findNearEmpty(int)</td><td>6.0</td><td>1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Building.isEnd()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Building.pasAlloc(Passenger)</td><td>4.0</td><td>4.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Building.run()</td><td>3.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Building.step()</td><td>7.0</td><td>1.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Elevator.carry(Passenger)</td><td>6.0</td><td>1.0</td><td>1.0</td><td>4.0</td></tr><tr><td>Elevator.checkBegin()</td><td>5.0</td><td>2.0</td><td>4.0</td><td>6.0</td></tr><tr><td>Elevator.checkTop()</td><td>2.0</td><td>1.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Elevator.close()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.closeDoor()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.Elevator(int, int, int, int, int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Elevator.findBottom()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.findTop()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.getFloor()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.ifCarry(Passenger)</td><td>12.0</td><td>6.0</td><td>1.0</td><td>6.0</td></tr><tr><td>Elevator.ifOut()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Elevator.ifOut(Passenger)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.ifPassingly(Passenger)</td><td>6.0</td><td>5.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Elevator.ifTake()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Elevator.ifTake(Passenger)</td><td>1.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.init()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEmpty()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.isEnd()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isFree()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Elevator.isOpen()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.move()</td><td>13.0</td><td>2.0</td><td>4.0</td><td>7.0</td></tr><tr><td>Elevator.open()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.operator()</td><td>7.0</td><td>2.0</td><td>5.0</td><td>6.0</td></tr><tr><td>Elevator.takeOn()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.takeOn(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.takeOut()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Elevator.takeOut(Passenger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Elevator.tryOpen()</td><td>3.0</td><td>2.0</td><td>2.0</td><td>4.0</td></tr><tr><td>MainClass.main(String[])</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getDirection()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getFinish()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getId()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.getStart()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.isTake()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.Passenger(int, int, int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Passenger.takeOn()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Passenger.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Request.getRequest()</td><td>4.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Request.isEnd()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Request.Request(ArrayList\<Passenger>)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Request.run()</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Total</td><td>111.0</td><td>73.0</td><td>95.0</td><td>122.0</td></tr><tr><td>Average</td><td>2.3125</td><td>1.5208333333333333</td><td>1.9791666666666667</td><td>2.5416666666666665</td></tr></tbody></table></div><p>本次作业类之间关系比较简单，总体上有高内聚，低耦合的特点。</p><h2 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h2><p>本次作业出了一个很离谱的 <strong>bug</strong>。我竟然忘记在下客人的时候维护桶子了。太悲伤了……</p><p>最后寄了三个点，都是 <strong>tle</strong>。因为这个 <strong>bug</strong> 会极大的影响我的性能，但是不会影响正确性。（最后就会变成只有空电梯才能接客，而不能捎带客人，从而 <strong>tle</strong> 掉。）</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 电梯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW3</title>
      <link href="/2023/03/08/OO-hw3/"/>
      <url>/2023/03/08/OO-hw3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是面向对象课程的第三次作业总结博客。在第二次作业上进行了一定的迭代开发。工作量相比第二次作业而言并不大。</p><p>相较于第二次作业，本次作业实现的功能有：实现求导算子。</p><p>因为只需要实现一个功能，从任务量和难度来讲都是三次作业中最简单的一次。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>经过迭代后第三次作业的类图如下所示：</p><p><img src="https://pic.imgdb.cn/item/64113ff7ebf10e5d538ed335.jpg" alt="类图"></p><p>本次迭代中涉及的工作有：</p><ul><li><strong>Expr</strong>、<strong>Term</strong>、<strong>Var</strong> 新增了求导方法（<strong>Expr</strong> 的求导方法处于 <strong>Tool</strong> 类中）。</li><li><strong>Parser</strong> 新增了求导算子语法分析方法。</li><li>对自定义函数的构造方法进行了一定的调整。</li><li>对预处理函数进行了一些调整</li></ul><h2 id="对预处理的调整"><a href="#对预处理的调整" class="headerlink" title="对预处理的调整"></a>对预处理的调整</h2><p>主要调整是将 <strong>dx</strong> 替换为了 <strong>1*dx</strong>，这样可以保证解析到求导算子时处在 <strong>Term</strong> 的解析过程中。</p><h2 id="求导实现思路"><a href="#求导实现思路" class="headerlink" title="求导实现思路"></a>求导实现思路</h2><p>在遇到求导算子 <strong>dx/y/z</strong> 时，对其管辖的表达式进行语法分析。分析结束后对得到的表达式调用表达式求导函数得到求导后的表达式，后续处理与括号解析相同。</p><p>对于出现在自定义函数中的求导算子，我的处理是对自定义函数的表达式调用表达式语法分析，对表达式进行展开、化简操作，再进行形参替换。</p><h3 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h3><p>对于 <strong>Expr</strong> 就是对其中每个 <strong>Term</strong> 都进行求导。采取循环即可，在循环过程中对每一项都进行求导。此3方法位于工具类 <strong>Tool</strong> 中。</p><h3 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h3><p>对于 <strong>Term</strong> 的求导主要考虑乘法法则。考虑到 <strong>(f(x)*g(x)*h(x))’=f(x)’*(g(x)*h(x))+f(x)*(g(x)*h(x))’=…</strong>，采用递归的方法解析。伪代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Term&gt; termDerivative</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">terms</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.vars.size == <span class="number">1</span>                  <span class="comment">// 当只剩下一项的时候</span></span><br><span class="line">        add vars[<span class="number">0</span>].derivative to terms     <span class="comment">// 返回原子项的求导结果</span></span><br><span class="line">        <span class="keyword">return</span> terms</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        add <span class="title function_">mul</span><span class="params">(<span class="built_in">this</span>.vars[<span class="number">0</span>].derivative, <span class="built_in">this</span>.vars[<span class="number">1</span>,])</span> to terms <span class="comment">// 前导后不导</span></span><br><span class="line">        add <span class="title function_">mul</span><span class="params">(<span class="built_in">this</span>.vars[<span class="number">0</span>], <span class="built_in">this</span>.vars[<span class="number">1</span>,].derivative)</span> to terms <span class="comment">// 前不导后导</span></span><br><span class="line">        <span class="keyword">return</span> terms </span><br></pre></td></tr></table></figure><h3 id="Var"><a href="#Var" class="headerlink" title="Var"></a>Var</h3><p>对于 <strong>Var</strong> 的求导，分为三种情况：</p><ol><li>常数求导返回零</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.442ex" height="1.553ex" role="img" focusable="false" viewBox="0 -675.5 1079.3 686.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(605,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container> 返回 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="7.981ex" height="1.912ex" role="img" focusable="false" viewBox="0 -833.9 3527.4 844.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="msup" transform="translate(1544.4,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="TeXAtom" transform="translate(605,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></g></svg></mjx-container></li><li>三角函数返回三角函数求导后的值。</li></ol><p>其中对三角函数的求导举例：</p><script type="math/tex; mode=display">(sin^n(Expr))'=n*sin^{n-1}(Expr)*cos(Expr)*(Expr)'</script><h2 id="类复杂度分析"><a href="#类复杂度分析" class="headerlink" title="类复杂度分析"></a>类复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CgoC</th><th>ev</th><th>iv</th><th>v</th></tr></thead><tbody><tr><td>Expr.equals(Expr)</td><td>16</td><td>5</td><td>5</td><td>9</td></tr><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.Expr(ArrayList)</td><td>2</td><td>2</td><td>2</td><td>3</td></tr><tr><td>Expr.getTerms()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.toString()</td><td>6</td><td>3</td><td>5</td><td>5</td></tr><tr><td>Function.call(String)</td><td>9</td><td>1</td><td>6</td><td>7</td></tr><tr><td>Function.Function(String, ArrayList)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Function.getState()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Function.toString()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getFunction()</td><td>5</td><td>1</td><td>2</td><td>4</td></tr><tr><td>Lexer.getNumber()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.next()</td><td>9</td><td>2</td><td>6</td><td>8</td></tr><tr><td>Lexer.peek()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MainClass.main(String[])</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Parser.cket(ArrayList)</td><td>4</td><td>2</td><td>3</td><td>3</td></tr><tr><td>Parser.parseDerivation(ArrayList)</td><td>4</td><td>2</td><td>3</td><td>3</td></tr><tr><td>Parser.parseExpr()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Parser.parseFunction(ArrayList, String)</td><td>7</td><td>4</td><td>5</td><td>5</td></tr><tr><td>Parser.Parser(Lexer, ArrayList)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.parseTerm()</td><td>14</td><td>1</td><td>11</td><td>11</td></tr><tr><td>Parser.parseVar()</td><td>23</td><td>7</td><td>11</td><td>15</td></tr><tr><td>Term.add(Term)</td><td>9</td><td>3</td><td>5</td><td>7</td></tr><tr><td>Term.addVar(Var)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Term.addVars(Term)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Term.copy()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.equals(Term)</td><td>17</td><td>6</td><td>5</td><td>10</td></tr><tr><td>Term.getConstant()</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>Term.getSymbol()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.setSymbol()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Term.setSymbol(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.similar(Term)</td><td>39</td><td>13</td><td>15</td><td>21</td></tr><tr><td>Term.simplify()</td><td>23</td><td>5</td><td>13</td><td>14</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.Term(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.Term(Var)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.termDerivative(Character)</td><td>6</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Term.toString()</td><td>6</td><td>3</td><td>3</td><td>6</td></tr><tr><td>Tool.afterTreat(String)</td><td>3</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Tool.exprDerivative(ArrayList, Character)</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Tool.exprSimplify(ArrayList)</td><td>8</td><td>2</td><td>5</td><td>6</td></tr><tr><td>Tool.mul(ArrayList, ArrayList)</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Tool.mul(ArrayList, Term)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Tool.mul(Term, Term)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Tool.preTreat(String)</td><td>2</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Tool.removeSpace(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.addAbs(Var)</td><td>2</td><td>2</td><td>1</td><td>3</td></tr><tr><td>Var.copy()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.equals(Var)</td><td>5</td><td>4</td><td>3</td><td>6</td></tr><tr><td>Var.getCharacter()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.getExpr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.getIndex()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.getNum()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Var.getSymbol()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.getType()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.setSymbol(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.simplify()</td><td>8</td><td>4</td><td>5</td><td>8</td></tr><tr><td>Var.subAbs(Var)</td><td>2</td><td>2</td><td>1</td><td>3</td></tr><tr><td>Var.toString()</td><td>11</td><td>6</td><td>7</td><td>10</td></tr><tr><td>Var.Var(int)</td><td>1</td><td>1</td><td>1</td><td>2</td></tr><tr><td>Var.Var(int, BigInteger, Character, int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.Var(int, BigInteger, Character, int, int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.Var(int, BigInteger, Character, int, int, ArrayList)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.Var(int, BigInteger, int, int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.Var(int, Character, int, int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.Var(int, int, int, ArrayList)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.varDerivative(Character)</td><td>15</td><td>3</td><td>6</td><td>8</td></tr><tr><td>Total</td><td>276</td><td>131</td><td>201</td><td>249</td></tr><tr><td>Average</td><td>4.119402985</td><td>1.955223881</td><td>3</td><td>3.71641791</td></tr></tbody></table></div><p><img src="https://pic.imgdb.cn/item/6411fa49ebf10e5d5330ecbe.png" alt="复杂度分析"></p><p>本次迭代后复杂度并没有额外的增加。整体上基本与第二次作业相同。</p><h2 id="bug-分析"><a href="#bug-分析" class="headerlink" title="bug 分析"></a>bug 分析</h2><p>本次作业并没有发现 <strong>bug</strong>。</p><h2 id="hack-策略"><a href="#hack-策略" class="headerlink" title="hack 策略"></a>hack 策略</h2><p>整体上 <strong>hack</strong> 以跑评测机为主，手动构造数据为辅。</p><p>值得一提的是在互测过程中成功刀到了 <strong>TLE</strong> 与 <strong>MLE</strong>。出刀的过程中包含了各种卡着代价上限的微调…结果是成功爆了一个人的时间与另一个人的堆，给我留下了珍贵的回忆。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>拜整体还算是优良的架构所赐，第三次作业的难度可谓是三次作业中最简单的。经验是在编程过程中，优良的架构设计是很重要的。在写出屎山代码时要勇于重构，不要尝试在屎山上添砖加瓦。</p><p>因为没有参加 <strong>OOpre</strong>，所以在写第一次作业的过程中遇到了莫大的困难，当时的心态也受到了莫大的影响。很希望课程组以后会改进这一点，要么不要取消寒假的 <strong>OOpre</strong>，要么把 <strong>OOpre</strong> 课程变成大二上的必修课。</p><p>另外是互测刀的很爽（逃），但是个人感觉代价的设定有点太严苛了，过于严苛的代价设定让本来是比较合理的 <strong>hack</strong> 都无法通过合法性检验，比较影响刀人体验。</p><p>第一单元的学习还是很有遗憾的，比如第一次作业强测直接寄的经历呜呜呜。</p><p>特别感谢 <strong>Toby</strong> 和 <strong>sheep</strong> 对我学习的帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 计算器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW2</title>
      <link href="/2023/03/04/OO-hw2/"/>
      <url>/2023/03/04/OO-hw2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相较于第一次作业，第二次作业进行迭代开发主要完成的功能有：</p><ol><li>支持三角函数</li><li>支持自定义函数</li></ol><p>括号嵌套在第一次作业中就已经实现。</p><hr><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><strong>hw2</strong> 的类图如下所示：</p><p><img src="https://pic.imgdb.cn/item/64023415f144a0100761b22e.jpg" alt="类图"></p><p>本次迭代中主要涉及到的工作有：</p><ul><li>新增了 <strong>Function</strong> 类，用于存储自定义函数的定义并作为 <strong>Parser</strong> 的属性参与解析过程。</li><li>在 <strong>Var</strong> 类中新增了属性 <strong>exprs</strong>，用于存储三角函数的表达式。</li><li>对 <strong>Expr</strong>、<strong>Term</strong>、<strong>Var</strong> 三个类新增了 <strong>equals()</strong> 方法。</li><li>对 <strong>Parser</strong> 类新增了 <strong>parseBracket()</strong> 用于专门解析括号，<strong>parseFunction()</strong> 用于专门解析函数。</li><li>对 <strong>Lexer</strong> 类增加了识别 <strong>Function</strong> 的方法：<strong>getFunction()</strong>。</li><li>对预处理函数进行了若干调整。</li></ul><h2 id="迭代思路"><a href="#迭代思路" class="headerlink" title="迭代思路"></a>迭代思路</h2><h3 id="处理三角函数"><a href="#处理三角函数" class="headerlink" title="处理三角函数"></a>处理三角函数</h3><p>首先，将三角函数作为一项新的属性添加到了原子项当中。</p><p>在视图中，三角函数内部包含一个表达式。判断两个三角函数是否相等即等价于判断其内部的表达式是否相等。于是对 <strong>Expr</strong>、<strong>Term</strong>、<strong>Var</strong> 三个类中添加了 <strong>equals()</strong> 方法。</p><p>解析三角函数等价于解析括号内部表达式。将解析得到的表达式添加至三角函数内即可。</p><p>并没有对三角函数作出很强的优化。仅做了类似 <strong>sin(0)</strong> 等于 <strong>0</strong> 这样的简单化简。</p><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>本类是第二次作业中新增的类，用于处理、解析、调用函数。</p><p>本类主要包含构造函数和调用函数。</p><p>在构造过程中，将函数表达式进行格式化处理。举例而言：<code>f(x,y)=sin(x**2)+y</code> 经处理后，解析得到 <code>sin(($0)**2)+($1)</code> 存储进 <strong>function</strong> 的 <strong>expr</strong> 中。</p><p>在调用方法，调用流程如下：</p><ol><li>识别实参列表。</li><li>将 <strong>$n</strong> 替换成对应的实参。</li><li>传回替换实参后的字符串。</li></ol><h3 id="自定义函数解析"><a href="#自定义函数解析" class="headerlink" title="自定义函数解析"></a>自定义函数解析</h3><p>在 <strong>Parser</strong> 类中新增了 <strong>parseFunction()</strong> 方法用于解析表达式中的函数。</p><p>在解析过程中，首先进行函数的调用得到替换实参后的字符串，之后对字符串进行表达式解析，再传回解析得到的表达式。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>对预处理函数的主要处理有：将 <strong>cos1*(</strong> 、<strong>sin1*(</strong>、<strong>f1*(</strong> 等替换成 <strong>cos(</strong>、<strong>sin(</strong>、<strong>1*f(</strong>。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Expr.addTerm(Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.addTerms(ArrayList\<Term>)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.equals(Expr)</td><td>16.0</td><td>5.0</td><td>5.0</td><td>9.0</td></tr><tr><td>Expr.Expr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.Expr(ArrayList\<Term>)</td><td>2.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Expr.getTerms()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.toString()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Function.call(String)</td><td>9.0</td><td>1.0</td><td>6.0</td><td>7.0</td></tr><tr><td>Function.Function(String)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Function.getExpr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Function.getState()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Function.toString()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.getFunction()</td><td>5.0</td><td>1.0</td><td>2.0</td><td>4.0</td></tr><tr><td>Lexer.getNumber()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Lexer.Lexer(String)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.next()</td><td>8.0</td><td>2.0</td><td>5.0</td><td>7.0</td></tr><tr><td>Lexer.peek()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>MainClass.main(String[])</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseBracket(ArrayList\<Term>)</td><td>4.0</td><td>2.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Parser.parseExpr()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Parser.parseFunction(ArrayList\<Term>, String)</td><td>7.0</td><td>4.0</td><td>5.0</td><td>5.0</td></tr><tr><td>Parser.Parser(Lexer, ArrayList\<Function>)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseTerm()</td><td>13.0</td><td>1.0</td><td>10.0</td><td>10.0</td></tr><tr><td>Parser.parseVar()</td><td>23.0</td><td>7.0</td><td>11.0</td><td>15.0</td></tr><tr><td>Term.add(Term)</td><td>9.0</td><td>3.0</td><td>5.0</td><td>7.0</td></tr><tr><td>Term.addVar(Var)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.addVars(ArrayList\<Var>)</td><td>2.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Term.addVars(Term)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.copy()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.equals(Term)</td><td>17.0</td><td>6.0</td><td>5.0</td><td>10.0</td></tr><tr><td>Term.getConstant()</td><td>3.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Term.getSymbol()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.setSymbol()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.setSymbol(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.similar(Term)</td><td>39.0</td><td>13.0</td><td>15.0</td><td>21.0</td></tr><tr><td>Term.simplify()</td><td>23.0</td><td>5.0</td><td>13.0</td><td>14.0</td></tr><tr><td>Term.Term()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term(Var)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.toString()</td><td>6.0</td><td>3.0</td><td>3.0</td><td>6.0</td></tr><tr><td>Tool.afterTreat(String)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Tool.exprSimplify(ArrayList\<Term>)</td><td>8.0</td><td>2.0</td><td>5.0</td><td>6.0</td></tr><tr><td>Tool.mul(ArrayList\<Term>, ArrayList\<Term>)</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Tool.mul(Term, Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Tool.preTreat(String)</td><td>2.0</td><td>1.0</td><td>5.0</td><td>5.0</td></tr><tr><td>Tool.removeSpace(String)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.addAbs(Var)</td><td>2.0</td><td>2.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Var.copy()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.equals(Var)</td><td>5.0</td><td>4.0</td><td>3.0</td><td>6.0</td></tr><tr><td>Var.getCharacter()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getExpr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getIndex()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getNum()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Var.getSymbol()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getType()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.setSymbol(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.simplify()</td><td>8.0</td><td>4.0</td><td>5.0</td><td>8.0</td></tr><tr><td>Var.subAbs(Var)</td><td>2.0</td><td>2.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Var.toString()</td><td>9.0</td><td>4.0</td><td>7.0</td><td>9.0</td></tr><tr><td>Var.Var(int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Var.Var(int, BigInteger, Character, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, BigInteger, Character, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, BigInteger, Character, int, int, ArrayList\<Term>)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, BigInteger, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, Character, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>239.0</td><td>121.0</td><td>179.0</td><td>225.0</td></tr><tr><td>Average</td><td>3.6769230769230767</td><td>1.8615384615384616</td><td>2.753846153846154</td><td>3.4615384615384617</td></tr></tbody></table></div><p><img src="https://pic.imgdb.cn/item/6411e83debf10e5d530c5265.png" alt="复杂度分析"></p><p>可以看到在添加了三角函数后 <strong>Term</strong> 类的 <strong>similar</strong> 方法复杂度直接爆炸了…这主要是因为对三角函数的判断逻辑比较复杂。此外对原子项的语法解析也因为三角函数的加入而变得稍显臃肿。考虑改进的话可以将对三角函数的语法解析提取到单独的类中。</p><h2 id="bug-分析"><a href="#bug-分析" class="headerlink" title="bug 分析"></a>bug 分析</h2><p>第二次作业的构建过程中没有遇到什么特别的 <strong>bug</strong>。强测互测也都顺利通过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第二周的压力比第一周小了很多，仿佛一切都在步上正轨，令人欣慰。虽然一度为弱智 <strong>bug</strong> 所苦恼，不过跟第一周的坐牢比起来已经幸福太多了。并且由于第一周架构比较合理（貌似是），我在本次的迭代开发的过程中并未遇到什么困难，整体架构也几乎没有变动。唯一最大的困难就是我本人捉急的码力（悲）</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 计算器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW1</title>
      <link href="/2023/02/28/OO-hw1/"/>
      <url>/2023/02/28/OO-hw1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次 <strong>OO</strong> 作业经历过一次重构，而且重构的完成时间是在提交截止之后（哭）。所以强测寄的很惨，呜呜呜。（不过在房里刀的也很爽）</p><p>不过这份重构我个人是十分满意的。</p><p>特别感谢 <strong>sheep</strong> 和 <strong>toby</strong> 的帮助！</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>类图如下所示：</p><p><img src="https://pic.imgdb.cn/item/63fdb4d7f144a01007c743f6.jpg" alt="类图"></p><ul><li><strong>Expr</strong>：表达式</li><li><strong>Term</strong>：项</li><li><strong>Var</strong>：原子项</li><li><strong>Lexer</strong>：词法分析器</li><li><strong>Parser</strong>：语法分析器</li><li><strong>Tool</strong>：工具类</li></ul><p>注：图中省略了若干构造函数和获取类属性的接口。</p><h2 id="对各类的分析"><a href="#对各类的分析" class="headerlink" title="对各类的分析"></a>对各类的分析</h2><h3 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h3><p>本类作为词法解析器。<strong>peek()</strong> 方法可以取得当前解析得到的词汇。<strong>next()</strong> 方法会继续取得下一个词汇。当读取到句末时，继续使用 <strong>next()</strong> 将会读取到一个空格。</p><p>评价：中规中矩的词法解释器，基本是抄课程组的。</p><h3 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h3><p>本类是表达式。我对表达式的定义如下：</p><ul><li>表达式由至少一个项连接而成。</li><li>表达式本身不含符号，由各个项决定各自的符号。</li></ul><p>只有一个属性：<strong>ArrayList\<Term\></strong>，存储表达式内部的各个项。</p><p>具有 <strong>toString()</strong> 方法将表达式转换为字符串。</p><p>评价：或许应该将表达式乘法添加到其中。不过这样在运算过程中会涉及到一层额外的包装，可能有损性能。此外可以对表达式内部项进行排序，但是考虑到递归时可能带来的性能开销也作罢。</p><h3 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h3><p>本类是项。我对项的定义如下：</p><ul><li>项由至少一个原子项相乘得到。</li><li>项本身默认的符号为正。在化简过程中符号根据项内部原子项符号改变。</li><li>输出项时会输出项本身的符号。</li></ul><p>项包含两个属性：<strong>ArrayList\<Var\></strong> 和 <strong>symbol</strong>。<strong>arraylist</strong> 内存储实际的内容，<strong>symbol</strong> 内存储项本身的符号。</p><p>具有化简方法、设置符号方法、深拷贝方法、取得常数方法、判断是否相似方法。</p><p>评价：项的方法普遍比较复杂，这个类也是逻辑上最复杂的类。项的化简方法的复杂度相对也比较高。</p><h3 id="Var"><a href="#Var" class="headerlink" title="Var"></a>Var</h3><p>本类是原子项。我对原子项的定义如下：</p><ul><li>原子项要么是常数，要么是变量。</li><li>原子项含有幂次和符号。</li></ul><p>原子项包含的属性：<strong>type</strong> 用于决定原子项的类型（常数或变量），<strong>num</strong> 存储常数，<strong>character</strong> 存储变量，<strong>index</strong> 存储幂次，<strong>symbol</strong> 存储符号。</p><p>原子项具有加减的方法。（仅限于常数运算）</p><p>评价：写的时候脑子一抽写了很多不必要的重载构造方法。实际上第一次作业中只需要两个构造方法就够用了。本类在第一次作业中复杂度较低。</p><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>本类是语法分析类。进行语法分析工作。</p><ul><li><strong>parseExpr</strong>：对表达式进行语法分析。</li><li><strong>parseTerm</strong>：对项进行语法分析。括号的解析也将在这一层中进行。</li><li><strong>parseVar</strong>：分析原子项。</li></ul><p>其中对表达式和项的语法分析都会返回一个项的集合。对表达式的分析返回项的集合的原因不言而喻。对项的语法分析返回一个项的集合的原因如下：</p><ol><li>对括号的解析处在项这一级。</li><li>解析到括号时，由于括号内部是表达式，解析项会将这个括号展开，于是会得到一个项的集合。</li><li>在解析项的过程中各个项之间都是相乘的关系。</li></ol><p>评价：核心解析、化简流程皆在本类中进行。对括号的解析和对基本项的解析都可以新增方法以降低原有方法的复杂度。</p><h3 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h3><p>本类是工具类。包含了一些通用的工具：</p><ul><li>包含预处理和事后处理。</li><li>包含对乘法方法的重载。</li><li>包含表达式的化简方法。</li></ul><p>之所以将乘法的重载和表达式的化简方法置于 <strong>Tool</strong> 内部是考虑到在 <strong>Parser</strong> 类中主要通过 <strong>ArrayList\<Term\></strong> 的形式计算化简，所以需要在工具类中定义静态方法操作数组。</p><p>其中表达式化简的时机是在已经解析了表达式，返回表达式之前时。</p><p>评价：本类的方法全部是静态方法，供全局调用。重载了表达式与表达式、表达式与项之间的乘法。还做了必要的预处理和事后处理。预处理也可以说是化简流程中的一个精髓了。经过预处理后，无需考虑空格、连续符号的问题，对括号的解析流程也符合我自己定义的标准。</p><h2 id="化简流程"><a href="#化简流程" class="headerlink" title="化简流程"></a>化简流程</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理的流程：</p><ol><li>去除所有空字符</li><li>将 “(” 替换成 “1*(”</li><li>将所有连续的正负号化简成一个符号</li><li>将 “*+” 化简成 “*”</li><li>将 “**” 化简成 “^”</li></ol><p>经过预处理后，我们得到的字符串中没有任何的空白与连续的符号，并且乘方使用 “^” 表示后更加易于处理。</p><p>将括号前面添加 <strong>1*</strong> 是为了保证解析到括号时处于项的解析流程中。</p><p>使用 <strong>replaceAll()</strong> 正则替换就可以实现预处理。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将表达式视作 <strong>表达式->项->原子项</strong> 的结构。即：</p><ul><li>Expr = Term + Term</li><li>Term = Var * Var</li></ul><p>对于符号，解析时首先将符号读取至原子项中，在化简过程中将符号归一到其所属的项中。</p><p>对于括号，整个解析过程是边解析边化简的。具体而言，在读取到括号时我会将括号内部视作一个表达式进行解析，返回经过化简后的 <strong>ArrayList\<Term\></strong>（<strong>ArrayList\<Term\></strong> 与表达式在逻辑上是等价的）。</p><p>由于 <strong>ArrayList\<Term\></strong> 与表达式在逻辑上是等价的，故 <strong>parseExpr()</strong> 与 <strong>parseTerm()</strong> 的返回值都是 <strong>ArrayList\<Term\></strong>。后者之所以返回数组是为了支持括号的解析。</p><h3 id="处理括号"><a href="#处理括号" class="headerlink" title="处理括号"></a>处理括号</h3><p>遇到括号时，在 <strong>praseTerm()</strong> 中递归调用 <strong>praseExpr()</strong>。在 <strong>praseExpr()</strong> 中将括号内的表达式分析、化简完毕再回溯到 <strong>praseTerm()</strong>（此时 <strong>parseTerm()</strong> 就会返回多个 <strong>Term</strong>）。</p><p>举例而言：对于 <code>1+(x**2-1)*3</code>，经过预处理后：<code>1+1*(x**2-1)*3</code>，在读取到 “<strong>(</strong>” 时处于 <strong>parseTerm()</strong> 的调用中。经调用 <strong>parseExpr()</strong> 后得到一个 <strong>ArrayList\<Term\></strong>。之后接着读取处理后面的 <code>*3</code>，最后返回的 <strong>Term</strong> 数组中包含 <strong>3*x**2</strong>，<strong>-3</strong>。</p><h3 id="处理乘方"><a href="#处理乘方" class="headerlink" title="处理乘方"></a>处理乘方</h3><p>“^” 可能出现在 “xyz)” 的后面。于是在 <strong>praseVar()</strong> 中和 <strong>praseTerm()</strong> 中相应的位置直接进行分析、展开（暴力循环即可）。我使用 <strong>Var</strong> 中的一个属性 <strong>index</strong> 来存储原子项（<strong>xyz</strong> 与数字，不过数字的乘方采取直接计算的方法）的乘方。</p><h3 id="事后处理"><a href="#事后处理" class="headerlink" title="事后处理"></a>事后处理</h3><p>事后处理（ <strong>afterTreat</strong> ）的时候使用正则替换进行简单的优化。包括：</p><ol><li>将 “^” 展开为 “**”</li><li>将 “+1*” 化简为 “+”</li><li>将 “-1*” 化简为 “-”</li><li>去除首位的正号</li></ol><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Expr.addTerm(Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.addTerms(ArrayList\<Term\>)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.Expr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.Expr(ArrayList\<Term\>)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.toString()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Lexer.getNumber()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Lexer.Lexer(String)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.next()</td><td>3.0</td><td>2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Lexer.peek()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>MainClass.main(String[])</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseExpr()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseTerm()</td><td>19.0</td><td>1.0</td><td>9.0</td><td>9.0</td></tr><tr><td>Parser.parseVar()</td><td>8.0</td><td>3.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Term.add(Term)</td><td>7.0</td><td>1.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Term.addVar(Var)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.addVars(ArrayList\<Var\>)</td><td>2.0</td><td>2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Term.addVars(Term)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.copy()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.getConstant()</td><td>3.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Term.getSymbol()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.setSymbol()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.setSymbol(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.similar(Term)</td><td>9.0</td><td>3.0</td><td>5.0</td><td>7.0</td></tr><tr><td>Term.simplify()</td><td>8.0</td><td>2.0</td><td>5.0</td><td>6.0</td></tr><tr><td>Term.Term()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term(Var)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.toString()</td><td>3.0</td><td>2.0</td><td>2.0</td><td>4.0</td></tr><tr><td>Tool.afterTreat(String)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Tool.exprSimplify(ArrayList\<Term>)</td><td>7.0</td><td>2.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Tool.mul(ArrayList\<Term>, ArrayList\<Term>)</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Tool.mul(Term, Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Tool.preTreat(String)</td><td>2.0</td><td>1.0</td><td>5.0</td><td>5.0</td></tr><tr><td>Var.addAbs(Var)</td><td>2.0</td><td>2.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Var.copy()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.equals(Var)</td><td>3.0</td><td>2.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Var.getCharacter()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getIndex()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getNum()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Var.getSymbol()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.getType()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.setSymbol(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.similar(Var)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Var.simplify()</td><td>6.0</td><td>4.0</td><td>4.0</td><td>6.0</td></tr><tr><td>Var.subAbs(Var)</td><td>2.0</td><td>2.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Var.toString()</td><td>7.0</td><td>3.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Var.Var(int)</td><td>1.0</td><td>1.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Var.Var(int, BigInteger, Character, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, BigInteger, Character, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, BigInteger, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Var.Var(int, Character, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>108.0</td><td>71.0</td><td>113.0</td><td>132.0</td></tr><tr><td>Average</td><td>2.076923076923077</td><td>1.3653846153846154</td><td>2.173076923076923</td><td>2.5384615384615383</td></tr></tbody></table></div><p><img src="https://pic.imgdb.cn/item/6411cb26ebf10e5d53c62e1f.png" alt="复杂度分析"></p><p>第一次作业类之间的耦合度不高，方法的复杂度也较低。其中对项的语法解析方法的复杂度较高。这是因为其中蕴含了对括号的分析。在之后的迭代过程中我将括号的解析拿到了新的方法中，降低了这一方法的复杂度。</p><h2 id="bug-分析"><a href="#bug-分析" class="headerlink" title="bug 分析"></a>bug 分析</h2><p>重构前的代码有一个 <strong>bug</strong>，是会将 <strong>-x**0</strong> 解析成 <strong>+1</strong>。但是在交完中测之后直接把第一版代码抛弃了，故没有具体分析 <strong>bug</strong> 出现的原因（本文也没有对初版代码进行分析）。重构后的代码（即当前分析的代码）没有遇到 <strong>bug</strong>。此后的迭代工作也都是基于这版代码进行的。</p><h2 id="hack-经验"><a href="#hack-经验" class="headerlink" title="hack 经验"></a>hack 经验</h2><p>因为交的代码比较寄所以去了 <strong>B</strong> 房…前两天还在忙着重构，最后只刀了一下午 <strong>+</strong> 一晚上。不过战绩还是可以的，总共中了 <strong>12</strong> 刀，经过修复后也拿了六分多的样子。</p><p><strong>hack</strong> 的时候可以先手动构造一些易错的数据。跑评测机测出大量错误数据后要精缩数据到代价范围内，并且也方便同学修复 <strong>bug</strong>。此外要把刀过的数据记录下来，防止刀同质数据。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 计算器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P7 回顾</title>
      <link href="/2023/01/05/BUAA-CO-P7/"/>
      <url>/2023/01/05/BUAA-CO-P7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做完前六 <strong>P</strong> 之后，我们已经做出来一个相当厉害的流水线了。在 <strong>P7</strong> 中，我们的任务是增加外部中断响应和异常处理。</p><p>本篇博客中我将结合我做 <strong>P7</strong> 的方法，按照我的搭建过程逐个讲解 <strong>P7</strong> 中所要完成的工作。</p><p>注：本篇博客记录的是 <strong>21</strong> 级的 <strong>P7</strong> 搭建过程。计组课程组每年都可能会对细节有一些改动。因此建议自行甄别内容。最终实现细节还请以教程为准。</p><h1 id="调整模块架构"><a href="#调整模块架构" class="headerlink" title="调整模块架构"></a>调整模块架构</h1><p>在 <strong>P7</strong> 中，我们需要对流水线的架构做一些调整。我们需要添加<strong>系统桥</strong>和两个<strong>计时器</strong>，这三个组件和我们在 <strong>P6</strong> 中搭建的 <strong>CPU</strong> 在同一级别。也就是这样的：</p><p><img src="../picture/P7_mips.png" alt=""></p><h2 id="系统桥"><a href="#系统桥" class="headerlink" title="系统桥"></a>系统桥</h2><p>系统桥是 <strong>CPU</strong> 与外部组件进行通信的通道。我们的 <strong>CPU</strong> 与 <strong>DM</strong>、两个计时器、其他硬件之间的通信都需要经过系统桥进行。</p><p>在实现系统桥的过程中，主要有两个方向的信息流：<strong>CPU</strong> 到外部，以及外部到 <strong>CPU</strong>。</p><h3 id="CPU-到外部"><a href="#CPU-到外部" class="headerlink" title="CPU 到外部"></a><strong>CPU</strong> 到外部</h3><p>我们需要向外部传递的信息包括：</p><ul><li>读写的 <strong>DM</strong> 地址与使能信号。</li><li>读写的计时器地址与使能信号。</li><li>对于外部中断的响应信号。</li></ul><p>事实上这些信息的传播都是通过 <strong>store</strong> 类指令完成的。也就是说我们只将 <strong>P6</strong> 中 <strong>CPU</strong> 与 <strong>DM</strong> 通信的接口重新连接至系统桥内即可。</p><p>重点在于系统桥内部对于地址的选择。</p><p>对于常规读写 <strong>DM</strong>：不需要进行额外修改。</p><h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>需要判断 <strong>CPU</strong> 中给出的存储地址是否在两个计时器的地址范围内。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> timer1_sel = (m_data_addr_in &gt;= <span class="number">32&#x27;h7f00</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f0b</span>);</span><br><span class="line"><span class="keyword">wire</span> timer2_sel = (m_data_addr_in &gt;= <span class="number">32&#x27;h7f10</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f1b</span>);</span><br><span class="line"><span class="comment">// m_data_addr_in 是从CPU处拿到的存储地址信号</span></span><br></pre></td></tr></table></figure><p>若 <strong>store</strong> 的地址在这个范围内，说明我们要对计时器进行写入。将传给 <strong>timer</strong> 的信号进行相应的连接即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> timer1_WE = (&amp;m_data_byteen_in == <span class="number">1&#x27;b1</span>) &amp;&amp; (m_data_addr_in &gt;= <span class="number">32&#x27;h7f00</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f0b</span>);</span><br><span class="line"><span class="keyword">assign</span> timer2_WE = (&amp;m_data_byteen_in == <span class="number">1&#x27;b1</span>) &amp;&amp; (m_data_addr_in &gt;= <span class="number">32&#x27;h7f10</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f1b</span>);</span><br><span class="line"><span class="keyword">assign</span> timer1_addr = m_data_addr_in[<span class="number">31</span>:<span class="number">2</span>];</span><br><span class="line"><span class="keyword">assign</span> timer2_addr = m_data_addr_in[<span class="number">31</span>:<span class="number">2</span>];</span><br><span class="line"><span class="keyword">assign</span> timer1_Din = m_data_wdata_in;</span><br><span class="line"><span class="keyword">assign</span> timer2_Din = m_data_wdata_in;</span><br></pre></td></tr></table></figure><p>注：前两行代码中 <code>&amp;m_data_byteen_in == 1&#39;b1</code> 是因为对计时器写入必须按字写入。</p><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>课程组给出了中断响应时应写入的地址。注意，什么时候进行中断的响应是软件决定的事情，不需要硬件做决定。我们只需要在 <strong>写入 “中断响应对应的地址” 时将响应信号传出 CPU</strong> 即可。</p><p>在系统桥中的代码连接如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Int_sel = (m_data_addr_in &gt;= <span class="number">32&#x27;h7f20</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f23</span>) &amp;&amp; (|m_data_byteen_in == <span class="number">1&#x27;b1</span>);</span><br><span class="line"><span class="keyword">assign</span> m_int_addr = Int_sel == <span class="number">1&#x27;b1</span> ? m_data_addr_in : <span class="number">32&#x27;h0</span>;</span><br><span class="line"><span class="keyword">assign</span> m_int_byteen = Int_sel == <span class="number">1&#x27;b1</span> ? m_data_byteen_in : <span class="number">4&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="外部到-CPU"><a href="#外部到-CPU" class="headerlink" title="外部到 CPU"></a>外部到 <strong>CPU</strong></h3><p>外部至 <strong>CPU</strong> 的信号除了 <strong>load</strong> 类指令的相关信号外，还要增加 <strong>HWInt</strong> 信号来实现<strong>外部中断</strong>。</p><p>注意到 <strong>load</strong> 类指令可能从计时器中读取数据，因此我们在连接信号时要对来自计时器的信号做出相应的选择。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> m_data_rdata_out = timer1_sel == <span class="number">1&#x27;b1</span> ? timer1_Dout :</span><br><span class="line">  timer2_sel == <span class="number">1&#x27;b1</span> ? timer2_Dout :</span><br><span class="line">  m_data_rdata_in;</span><br></pre></td></tr></table></figure><p><strong>HWInt</strong> 共有六位，从低位开始依次是：<strong>timer1</strong> 的中断信号、<strong>timer2</strong> 的中断信号、外部中断信号与 <strong>3’b0</strong>。</p><p>即：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> HWInt = &#123;<span class="number">3&#x27;b0</span>, interrupt_in, timer2_IRQ, timer1_IRQ&#125;;</span><br></pre></td></tr></table></figure><p>其中 <strong>interrupt_in</strong> 是来自外部的中断信号。</p><h2 id="计时器-1"><a href="#计时器-1" class="headerlink" title="计时器"></a>计时器</h2><p>计时器这部分我们简单的阅读源码，理解后大致了解各个端口的连接方式即可。计时器的源码在教程中已经给出。</p><p>注意，由于教程未来可能会有版本更新，计时器的具体连接方式也可能有变化。笔者不保证我的连接方式一定是正确的。还请同学们依据实际情况自行定夺。</p><h1 id="宏观-PC"><a href="#宏观-PC" class="headerlink" title="宏观 PC"></a>宏观 <strong>PC</strong></h1><p>由于我们要封装流水线，即让流水线看上去像一个单周期 <strong>CPU</strong>，所以我们使用了宏观 <strong>PC</strong> 这一概念。宏观 <strong>PC</strong> 表达的是 <strong>CPU</strong> 当前正在运转哪一条指令。</p><p>宏观 <strong>PC</strong> 要和协处理器 <strong>CP0</strong> 处于同一流水级中。有关协处理器的设计后文详谈。依据实现方式的不同，<strong>CP0</strong> 放在 <strong>E</strong> 级和 <strong>M</strong> 级均可。一般而言放在 <strong>M</strong> 级的同学居多，所以我也放在了 <strong>M</strong> 级，以便于和同学（大佬）们进行对拍。所以我宏观 <strong>PC</strong> 也就是 <strong>PC_M</strong> 的值。</p><p>在异常发生时，我们要保证产生异常的那条指令不会对 <strong>CPU</strong> 的状态造成影响。并将发生异常的指令作为 <strong>受害指令</strong> 存入协处理器的 <strong>EPC</strong> 中。这部分之后再详谈。</p><h1 id="侦测异常"><a href="#侦测异常" class="headerlink" title="侦测异常"></a>侦测异常</h1><p>在 <strong>P7</strong> 中，最重要的任务是侦测程序运行过程中产生的 <strong>异常</strong>。</p><p>我们首先要侦测异常，然后根据异常的种类生成相应的 <strong>Exccode</strong> 码，并将 <strong>Exccode</strong> 码存入协处理器 <strong>CP0</strong> 中。</p><h2 id="异常的种类"><a href="#异常的种类" class="headerlink" title="异常的种类"></a>异常的种类</h2><p>我们要实现的异常分为以下几类：</p><ul><li><strong>AdEL</strong>（<strong>Exccode</strong> 码为 <strong>5’d4</strong>）<ul><li>取 <strong>pc</strong> 的值时地址不对齐。</li><li><strong>lw</strong> 未字对齐与 <strong>lh</strong> 未半字对齐。</li><li>尝试使用 <strong>lh</strong> 和 <strong>lb</strong> 取 <strong>timer</strong> 的寄存器中的值。</li><li>计算取数地址的过程中出现加法溢出情况。</li><li>取数地址不在允许的范围中。</li></ul></li><li><strong>AdES</strong>（<strong>Exccode</strong> 码为 <strong>5’d5</strong>）<ul><li><strong>sw</strong> 未字对齐与 <strong>lh</strong> 未半字对齐。</li><li>尝试使用 <strong>sh</strong> 和 <strong>sb</strong> 向 <strong>timer</strong> 的寄存器中存值，或尝试向 <strong>timer</strong> 中的 <strong>Count</strong> 寄存器存值。</li><li>计算存数地址的过程中出现加法溢出情况。</li><li>存数地址不在允许的范围中。</li></ul></li><li><strong>Syscall</strong>（<strong>Exccode</strong> 码为 5’d8）<ul><li>由指令 <strong>syscall</strong> 产生的系统调用异常。</li></ul></li><li><strong>RI</strong>（<strong>Exccode</strong> 码为 <strong>5’d10</strong>）<ul><li>未知的指令码。</li></ul></li><li><strong>Ov</strong>（<strong>Exccode</strong> 码为 <strong>5’d12</strong>）<ul><li>加减指令的计算过程中出现溢出情况。</li></ul></li></ul><h2 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h2><p>笔者使用 <strong>OverFlow</strong> 指示溢出的产生。对溢出的判读需要在 <strong>E</strong> 级的 <strong>ALU</strong> 中进行。其具体过程在指令集中已有说明。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">32</span>:<span class="number">0</span>]tempAdd = &#123;A[<span class="number">31</span>], A&#125; + &#123;B[<span class="number">31</span>], B&#125;;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">32</span>:<span class="number">0</span>]tempSub = &#123;A[<span class="number">31</span>], A&#125; - &#123;B[<span class="number">31</span>], B&#125;;</span><br><span class="line"><span class="keyword">assign</span> OverFlowE = (ALUOp == <span class="number">4&#x27;b0000</span> &amp;&amp; tempAdd[<span class="number">32</span>] ^ tempAdd[<span class="number">31</span>] == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> :</span><br><span class="line">                   (ALUOp == <span class="number">4&#x27;b0001</span> &amp;&amp; tempSub[<span class="number">32</span>] ^ tempSub[<span class="number">31</span>] == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><p>其中 <strong>ALUOp</strong> 是我的实现方式中添加的信号。这个信号指示 <strong>ALU</strong> 要进行哪种运算。<strong>ALUOp</strong> 为 <strong>4’b0000</strong> 代表当前进行加法运算；<strong>ALUOp</strong> 为 <strong>4’b0001</strong> 代表当前进行减法运算。</p><p><strong>A</strong> 和 <strong>B</strong> 分别是传入 <strong>ALU</strong> 的两个操作数。</p><p><strong>OverFlow</strong> 在 <strong>E</strong> 级产生，需要流水到 <strong>M</strong> 级才能判断具体出现了哪种异常。</p><h2 id="Exccode-信号的产生"><a href="#Exccode-信号的产生" class="headerlink" title="Exccode 信号的产生"></a><strong>Exccode</strong> 信号的产生</h2><p>我们可以创建一个模块来产生 <strong>Exccode</strong> 信号。这里我将其称为 <strong>ExccodeOccur</strong>。此模块最好和协处理器位于同一流水级。（设置在 <strong>M</strong> 级中）</p><p>在清楚了各个异常产生的条件后，依次产生各个异常即可。</p><h3 id="AdEL"><a href="#AdEL" class="headerlink" title="AdEL"></a><strong>AdEL</strong></h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> AdEL = pcErrorM == <span class="number">1&#x27;b1</span> ? <span class="number">1&#x27;b1</span> : <span class="comment">//pcError</span></span><br><span class="line">(Lw == <span class="number">1&#x27;b1</span> &amp;&amp; (ALUAnsM[<span class="number">0</span>] | ALUAnsM[<span class="number">1</span>])) ? <span class="number">1&#x27;b1</span> : <span class="comment">//lw未字对齐</span></span><br><span class="line">(Lh == <span class="number">1&#x27;b1</span> &amp;&amp; ALUAnsM[<span class="number">0</span>]) ? <span class="number">1&#x27;b1</span> : <span class="comment">//lh未半字对齐</span></span><br><span class="line">((Lh | Lb) &amp;&amp; (ALUAnsM &gt;= <span class="number">32&#x27;h00007f00</span> &amp;&amp; ALUAnsM &lt;= <span class="number">32&#x27;h00007f1b</span>)) ? <span class="number">1&#x27;b1</span> : <span class="comment">//取Timer寄存器的值</span></span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; OverFlowM == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> :<span class="comment">//计算地址时加法溢出</span></span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f23</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f0b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f10</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f1b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f20</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00002fff</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f00</span>)) ? <span class="number">1&#x27;b1</span> :<span class="number">1&#x27;b0</span>; <span class="comment">//取数地址超出上限</span></span><br><span class="line"><span class="comment">// 注：其实可以简化但是因为写完后感觉工工整整的看上去很帅气所以就没有改</span></span><br></pre></td></tr></table></figure><h3 id="AdES"><a href="#AdES" class="headerlink" title="AdES"></a><strong>AdES</strong></h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> AdES = (Sw == <span class="number">1&#x27;b1</span> &amp;&amp; (ALUAnsM[<span class="number">0</span>] | ALUAnsM[<span class="number">1</span>])) ? <span class="number">1&#x27;b1</span> :<span class="comment">//sw未字对齐</span></span><br><span class="line">            (Sh == <span class="number">1&#x27;b1</span> &amp;&amp; ALUAnsM[<span class="number">0</span>]) ? <span class="number">1&#x27;b1</span> :<span class="comment">//sh未半字对齐</span></span><br><span class="line">            ((Sh | Sb) &amp;&amp; (ALUAnsM &gt;= <span class="number">32&#x27;h00007f00</span> &amp;&amp; ALUAnsM &lt;= <span class="number">32&#x27;h00007f1b</span>)) ? <span class="number">1&#x27;b1</span> :<span class="comment">//存Timer寄存器的值</span></span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; OverFlowM == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> :<span class="comment">//计算地址时加法溢出</span></span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM == <span class="number">32&#x27;h00007f08</span> || ALUAnsM == <span class="number">32&#x27;h00007f18</span>)) ? <span class="number">1&#x27;b1</span> :<span class="comment">//向计时器的Count存值</span></span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f23</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f0b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f10</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f1b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f20</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00002fff</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f00</span>)) ? <span class="number">1&#x27;b1</span> :<span class="number">1&#x27;b0</span>;<span class="comment">//存数地址超出上限</span></span><br></pre></td></tr></table></figure><h3 id="Syscall"><a href="#Syscall" class="headerlink" title="Syscall"></a><strong>Syscall</strong></h3><p>直接识别指令是否是 <strong>syscall</strong> 就行。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Syscall = (func == <span class="number">6&#x27;b001100</span> &amp;&amp; R_R == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="RI"><a href="#RI" class="headerlink" title="RI"></a><strong>RI</strong></h3><p><strong>RI</strong> 信号在 <strong>Controller</strong> 中产生，然后流水到 <strong>ExccodeOccur</strong> 所在的流水级，参与 <strong>Exccode</strong> 的生成。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Controller中产生，也就是在D级产生。</span></span><br><span class="line"><span class="keyword">assign</span> RID = ~(Beq | Bgez| Bne | Addi| Andi| Ori | Lui | J   | </span><br><span class="line">               Jal | Sb  | Sh  | Sw  | Lb  | Lh  | Lw  | Add | </span><br><span class="line">               Sub | And | Or  | Sll | Srl | Jr  | Slt | Sltu| </span><br><span class="line">               Mult|Multu| Div | Divu| Mfhi| Mflo| Mthi| Mtlo| </span><br><span class="line">            Syscall| Mfc0| Mtc0| Eret);</span><br></pre></td></tr></table></figure><h3 id="Ov"><a href="#Ov" class="headerlink" title="Ov"></a><strong>Ov</strong></h3><p>注意是由加减法运算指令导致的溢出才会产生 <strong>Ov</strong> 信号。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Ov = ((Add | Addi | Sub) &amp;&amp; OverFlowM == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="Exccode"><a href="#Exccode" class="headerlink" title="Exccode"></a><strong>Exccode</strong></h3><p>在得到所需的各个信号后，进行判断、生成即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> ExcCodeM = AdEL == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d4</span> :</span><br><span class="line">                  AdES == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d5</span> :</span><br><span class="line">                  Syscall == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d8</span> :</span><br><span class="line">                  RIM  == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d10</span> :</span><br><span class="line">                  Ov   == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d12</span> : <span class="number">5&#x27;d0</span>;</span><br></pre></td></tr></table></figure><h1 id="协处理器-CP0-设计"><a href="#协处理器-CP0-设计" class="headerlink" title="协处理器 CP0 设计"></a>协处理器 <strong>CP0</strong> 设计</h1><p><strong>CP0</strong> 的设计是整个 <strong>P7</strong> 的关键所在。这里特别感谢 <strong>roief</strong> 佬及其博客。<strong>roief</strong> 的博客指路：<a href="https://roife.github.io/2021/01/02/buaa-co-lab-p7/">P7 MIPS 微体系</a></p><h2 id="CP0-的端口"><a href="#CP0-的端口" class="headerlink" title="CP0 的端口"></a><strong>CP0</strong> 的端口</h2><p>我个人的 <strong>CP0</strong> 端口完全按照教程所推荐的设计。即：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">moudle CP0(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> en,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] CP0Add,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] CP0In,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] CP0Out,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] VPC,</span><br><span class="line">    <span class="keyword">input</span> BDIn,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] ExcCodeIn,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">5</span>:<span class="number">0</span>] HWInt,</span><br><span class="line">    <span class="keyword">input</span> EXLClr,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] EPCOut,</span><br><span class="line">    <span class="keyword">output</span> Req</span><br><span class="line">    );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于各个输入端口的粗略解释：</p><p><strong>CP0Add</strong> 和 <strong>CP0In</strong> 都是在实现 <strong>mtc0</strong> 和 <strong>mfc0</strong> 中要用到的。<strong>VPC</strong> 是受害指令的宏观 <strong>PC</strong>，此处即为 <strong>M</strong> 级 <strong>PC</strong>。</p><p><strong>ExccodeIn</strong> 是我们在 <strong>ExccodeOccur</strong> 中产生的 <strong>Exccode</strong>。<strong>HWInt</strong> 是我们在系统桥中产生并传入 <strong>CPU</strong> 的，传入 <strong>CPU</strong> 后直接连接到 <strong>CP0</strong> 的端口上。</p><p><strong>EXLClr</strong> 由指令 <strong>eret</strong> 产生。</p><p><strong>BDIn</strong> 指示当前指令是不是延迟槽内部指令，这与 <strong>EPC</strong> 的产生有关。</p><h2 id="CP0-中寄存器的实现"><a href="#CP0-中寄存器的实现" class="headerlink" title="CP0 中寄存器的实现"></a><strong>CP0</strong> 中寄存器的实现</h2><p>在 <strong>CP0</strong> 中我们要实现三个寄存器：<strong>SR</strong>、<strong>Cause</strong>、<strong>EPC</strong>。</p><p>为了便于 <strong>mtc0</strong> 和 <strong>mfc0</strong> 的实现以及不知道这两个指令会不会存取我们尚未实现的寄存器，我的 <strong>CP0</strong> 设计中添加了一个寄存器堆：<code>reg [31:0]CP[0:31];</code>，并添加以下宏定义便于代码编写（注：下文的代码使用到的宏定义均位于此处）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> SR CP[12]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> Cause CP[13]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> EPC CP[14]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> IE CP[12][0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> EXL CP[12][1]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> IM CP[12][15:10]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> BD CP[13][31]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> IP CP[13][15:10]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> ExcCode CP[13][6:2]</span></span><br></pre></td></tr></table></figure><p>各个域的功能：</p><ul><li><strong>IE</strong>：是否允许中断。</li><li><strong>EXL</strong>：是否处于核心态（异常中断处理程序中）。</li><li><strong>IM</strong>：六个位分别指示是否允许发生对应的中断。</li><li><strong>BD</strong>：是否是延迟槽中指令</li><li><strong>IP</strong>：每周期更新，记录 <strong>HWInt</strong> 的值。</li><li><strong>ExcCode</strong>：发生异常时更新，记录异常码。</li></ul><p>事后得知貌似是不会存取我们没有实现的寄存器的……不过这么写实现 <strong>mtc0</strong> 和 <strong>mfc0</strong> 都很方便，所以也是有其优点的。实际上协处理器 <strong>CP0</strong> 中就是包含有 <strong>32</strong> 个寄存器，因此这样实现可以说是毫无毛病（乐）。</p><h2 id="BD-的产生"><a href="#BD-的产生" class="headerlink" title="BD 的产生"></a><strong>BD</strong> 的产生</h2><p><strong>BD</strong> 这个信号是在外部产生并传入 <strong>CP0</strong> 中，指示当前指令是否处于延迟槽内。这里有一处要注意的地方是：在产生 <strong>BD</strong> 时，不管跳转指令是否跳转，都要将其视为处于延迟槽内。</p><p>我在 <strong>F</strong> 级产生这一信号，从而满足 <strong>BD</strong> 的产生晚于跳转指令一周期的条件。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> BDF = JalD | JrD | BeqD | BneD | <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h2 id="CP0Out-和-EPCOut"><a href="#CP0Out-和-EPCOut" class="headerlink" title="CP0Out 和 EPCOut"></a><strong>CP0Out</strong> 和 <strong>EPCOut</strong></h2><p>很方便的，我的 <strong>CP0Out</strong> 的产生方式为：<code>assign CP0Out = CP[CP0Add];</code>，一行搞定。</p><p>相应的，<strong>EPCOut</strong> 的产生方式为：<code>assign EPCOut = `EPC;</code>。</p><h2 id="EPC-的产生"><a href="#EPC-的产生" class="headerlink" title="EPC 的产生"></a><strong>EPC</strong> 的产生</h2><p>对于 <strong>EPC</strong> 的产生，要注意：如果指令是延迟槽指令（即 <code>BDIn == 1&#39;b1</code>），那么我们记录的 <strong>EPC</strong> 应当是其所属的跳转指令（即受害指令的上一条指令，<code>VPC - 32&#39;d4</code>）。</p><h2 id="Req-的产生"><a href="#Req-的产生" class="headerlink" title="Req 的产生"></a><strong>Req</strong> 的产生</h2><p>注：这部分参照了 <strong>roief</strong> 佬的写法。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> IntReq = (|(HWInt &amp; `IM)) &amp; !`EXL &amp; `IE; <span class="comment">// 允许当前中断 且 不在中断异常中 且 允许中断发生</span></span><br><span class="line"><span class="keyword">wire</span> ExcReq = (|ExcCodeIn) &amp; !`EXL; <span class="comment">// 存在异常 且 不在中断中</span></span><br><span class="line"><span class="keyword">assign</span> Req  = IntReq | ExcReq;</span><br></pre></td></tr></table></figure><p><strong>Req</strong> 的产生就意味着我们要进入异常处理程序了。除了要在 <strong>CP0</strong> 中做出改变外，我们还需要在 <strong>CPU</strong> 中做出相应的操作。下文再说。</p><h2 id="CP0-的时序逻辑"><a href="#CP0-的时序逻辑" class="headerlink" title="CP0 的时序逻辑"></a><strong>CP0</strong> 的时序逻辑</h2><p>遵循设计即可。</p><p>结合注释观看效果更佳。</p><p>这里提一个要注意的点：当中断和异常同时发生时，要优先响应中断，即向 <strong>`ExcCode</strong> 存入的值应当是象征中断的 <strong>0</strong>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            CP[i] = <span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(en == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span> <span class="comment">// 使能信号为真时将数据写入对应的寄存器</span></span><br><span class="line">            CP[CP0Add] = CP0In;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(Req == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span> <span class="comment">// 当异常或中断发生时</span></span><br><span class="line">            `EXL &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            `ExcCode &lt;= IntReq == <span class="number">1&#x27;b1</span> ? <span class="number">0</span> : ExcCodeIn; <span class="comment">// 中断的优先级高于异常</span></span><br><span class="line">            `EPC &lt;= BDIn == <span class="number">1&#x27;b1</span> ? VPC - <span class="number">32&#x27;d4</span> : VPC; <span class="comment">// 结合BDIn生成EPC</span></span><br><span class="line">            `BD &lt;= BDIn;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(EXLClr == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">            `EXL &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>((en == <span class="number">1&#x27;b1</span> &amp;&amp; CP0Add == <span class="number">13</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 这里是为了防止mtc0的目标寄存器是Cause时会对IP域写入两次</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            `IP &lt;= HWInt; <span class="comment">//每周期更新IP的值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="REQ-发生时"><a href="#REQ-发生时" class="headerlink" title="REQ 发生时"></a><strong>REQ</strong> 发生时</h1><p>当 <strong>CP0</strong> 中的 <strong>Req</strong> 信号处于高位，即我们要进入异常处理程序时，我们要对流水线进行以下处理：</p><ul><li>清空 <strong>D, E, M, W</strong> 级流水线寄存器。实现上可以直接将 <strong>Req</strong> 信号接入 <strong>reset</strong> 中。</li><li>将 <strong>PC</strong> 的值强制修改到异常处理程序的入口：<code>32&#39;h00004180</code>。</li><li>保证异常发生时不会对 <strong>DM</strong> 等外部模块产生写信号（即 <code>m_data_byteen == 4&#39;h0</code>）。</li><li>正处于 <strong>E</strong> 级的指令不应修改乘除模块。</li></ul><h1 id="指令拓展"><a href="#指令拓展" class="headerlink" title="指令拓展"></a>指令拓展</h1><p>在 <strong>P7</strong> 中，我们要拓展以下几个指令：<code>syscall, mfc0, mtc0, eret</code></p><p>其中 <strong>syscall</strong> 没什么好说的，产生相应的异常码就行。</p><p><strong>mfc0</strong> 和 <strong>mtc0</strong> 的实现有些类似于 <strong>mfhi</strong>，<strong>mthi</strong> 。根据指令集进行拓展即可。此外根据个人实现的不同可能需要处理和 <strong>mfc0</strong> 与 <strong>mtc0</strong> 相关的转发（增加 <strong>W</strong> 级到 <strong>M</strong> 级的通路等），还请注意。</p><p><strong>eret</strong> 要修改 <strong>PC</strong> 的值，返回 <strong>EPC</strong> 处继续执行指令。此处要有一个数据冲突问题需要注意：</p><p>当 <strong>mfc0</strong> 要修改 <strong>CP0</strong> 中的 <strong>14</strong> 号寄存器（即 <strong>`EPC</strong>），且后面跟着 <strong>eret</strong> 时，要进行相应的阻塞。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> stall_eret = EretD &amp; ((Mtc0E &amp; (instrE[<span class="number">15</span>:<span class="number">11</span>] == <span class="number">5&#x27;d14</span>)) | (Mtc0M &amp; (instrM[<span class="number">15</span>:<span class="number">11</span>] == <span class="number">5&#x27;d14</span>)));</span><br></pre></td></tr></table></figure><p>此外，当 <strong>eret</strong> 流水至 <strong>M</strong> 级时要将 <strong>CP0</strong> 中的 <strong>`EXL</strong> 置 <strong>0</strong>。</p><h1 id="修改-PC-的信号优先级"><a href="#修改-PC-的信号优先级" class="headerlink" title="修改 PC 的信号优先级"></a>修改 <strong>PC</strong> 的信号优先级</h1><p>优先级为：<strong>reset &gt; REQ &gt; eret &gt; 其他</strong></p><p>自行体悟一下即可，不作过多解释。</p><h1 id="阻塞时中断产生的问题"><a href="#阻塞时中断产生的问题" class="headerlink" title="阻塞时中断产生的问题"></a>阻塞时中断产生的问题</h1><p>在 <strong>P6</strong> 的 <strong>CPU</strong> 中，当我们阻塞时插入 <strong>nop</strong>，<strong>nop</strong> 对应的 <strong>pc</strong> 值一般是 <strong>0</strong>。这个设计在 <strong>P7</strong> 中会招致问题：当处于阻塞时外部产生了中断信号，我们记录的 <strong>EPC</strong> 将会是 <strong>0</strong>。这会导致错误的产生。</p><p>正确的处理方法，是在阻塞时让 <strong>pc</strong> 和 <strong>BD</strong> 这两个信号依旧正常流水。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P7</strong> 的工程量还是很大的。往年 <strong>P7</strong> 也被称为是最玄学的一 <strong>P</strong>。今年我在搭建时据说教程大更新，因此实际上并没有感觉有那么的 “玄学”。计组课程在不断地改进啊（喜）。</p><p>今年因为 <strong>P8</strong> 和烤漆完全撞上的缘故（考完概统的当天晚上进行 <strong>P8</strong> 上机），为了复习期末，不得已放弃了做 <strong>P8</strong> 的想法，不得不说是一个计组学习中的遗憾。</p><p>计组回忆的这一系列到这就结束了。虽然过程艰辛又曲折，但是回顾已有的成果，还是会有一种 “我都已经做出来这么多东西了啊！” 的感叹。</p><p>不知读者在学习计组的过程中是否体会到了乐趣呢？</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P6 回顾</title>
      <link href="/2023/01/05/BUAA-CO-P6/"/>
      <url>/2023/01/05/BUAA-CO-P6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是 <strong>bluebean</strong> 的 <strong>P6</strong> 回忆录。</p><p>我认为 <strong>P6</strong> 的难度较 <strong>P5</strong> 降低了许多，因为在 <strong>P6</strong> 只需要在 <strong>P5</strong> 的流水线基础上进行增量开发即可。当然，若 <strong>P5</strong> 的架构不完善的话，在 <strong>P6</strong> 可能将要坐大牢。</p><p>按照课程组（<strong>2021</strong> 版，以后可能会有变化）的要求，在 <strong>P6</strong> 中主要需要完成一下任务：</p><ul><li><strong>IM</strong> 和 <strong>DM</strong> 的外置。</li><li>在 <strong>P5</strong> 的基础上对指令集进行增量拓展。</li><li>添加乘除法模块，实现和乘除法相关的指令。</li></ul><h1 id="外置-IM-与-DM-模块"><a href="#外置-IM-与-DM-模块" class="headerlink" title="外置 IM 与 DM 模块"></a>外置 <strong>IM</strong> 与 <strong>DM</strong> 模块</h1><p>在 <strong>P6</strong> 中，我们的 <strong>IM</strong> 与 <strong>DM</strong> 模块需要外置，外置的模块在课程组提供的 <strong>test bench</strong> 中。在 <strong>CPU</strong> 中需要提供相应的与 <strong>IM</strong> 和 <strong>DM</strong> 通信的端口。</p><p>与 <strong>IM</strong> 的通信没什么好说的，直接把原来 <strong>IM</strong> 的接口接出去就行。</p><p>课程组的 <strong>DM</strong> 模块采用了字节使能方法来支持按字节读写的功能。这部分可以阅读课程组的代码后自行思考相应的实现方式。</p><p>我在实现过程中，产生了一个新的信号 <strong>MemWrite</strong> 用于指示读写哪些字节。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]MemWriteD = Sw == <span class="number">1&#x27;b1</span> ? <span class="number">4&#x27;b1111</span> :</span><br><span class="line">                    Sh == <span class="number">1&#x27;b1</span> ? <span class="number">4&#x27;b0011</span> :</span><br><span class="line">                    Sb == <span class="number">1&#x27;b1</span> ? <span class="number">4&#x27;b0001</span> : <span class="number">4&#x27;b0000</span>;</span><br></pre></td></tr></table></figure><p>在连接 <strong>DM</strong> 的信号时，采用了如下方式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> m_data_wdata  = AD1M &lt;&lt; &#123;ALUAnsM[<span class="number">1</span>:<span class="number">0</span>], <span class="number">3&#x27;b000</span>&#125;;</span><br><span class="line"><span class="keyword">assign</span> m_data_byteen = MemWriteM &lt;&lt; ALUAnsM[<span class="number">1</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>其中 <strong>ALUAnsM</strong> 是 <strong>ALU</strong> 的计算结果（<strong>M</strong> 级），存储着要写入的地址信息。</p><p>另外在 <strong>DM</strong> 读出的数据要进行相应的数据扩展。这里写一个 <strong>DM_EXT</strong> 模块判断一下对应的指令再进行相应的符号扩展就可以了。</p><h1 id="指令集拓展"><a href="#指令集拓展" class="headerlink" title="指令集拓展"></a>指令集拓展</h1><p>在 <strong>P6</strong> 中一项重要的工作就是进行指令集拓展。在一个良好的 <strong>P5</strong> 基础上进行拓展并不是难事。</p><p>建议每拓展一个指令就进行相应的功能测试。不求数据点多强，至少基本的功能测试要做好。</p><p>例如在拓展了 <strong>bne</strong> 指令后，进行简单的功能测试：<br><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ori </span>$<span class="number">1</span> <span class="number">0xf0</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">2</span> <span class="number">0xf0</span></span><br><span class="line"><span class="keyword">bne </span>$<span class="number">1</span> $<span class="number">2</span> end</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">lui </span>$<span class="number">1</span> <span class="number">0xff</span> <span class="comment"># run this</span></span><br><span class="line"><span class="keyword">bne </span>$<span class="number">1</span> $<span class="number">2</span> end</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span> <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lui </span>$<span class="number">1</span> <span class="number">0xee</span> <span class="comment"># not run this</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="number">5</span> <span class="number">0xcc</span></span><br></pre></td></tr></table></figure></p><p>建议同学们在课下针对每一个指令都做好测试，减少后期 <strong>dbug</strong> 难度。</p><h1 id="乘除模块"><a href="#乘除模块" class="headerlink" title="乘除模块"></a>乘除模块</h1><p>关于乘除指令，我们要拓展的有 <code>mult, multu, div, divu, mfhi, mflo, mthi, mtlo</code>。</p><p>我们要模拟出 <code>hi, lo</code> 这两个寄存器。</p><p>在写乘法时可以采用写法：<code>&#123;HiTem, LoTem&#125; = $signed(A) * $signed(B);</code>。这里 <strong>HiTem</strong> 和 <strong>LoTem</strong> 是用来暂时存储计算的值，当模拟乘除延迟结束时将结果存入 <strong>hi, lo</strong> 寄存器。</p><p>此外要注意和乘除法指令相关的阻塞。当乘除模块正在运行时，遇到新的乘除指令是要阻塞流水线的。这里存在一定的优化空间，比如两条连续的乘法指令，我们就可以忽略掉前一条乘法指令，因为后一条指令会重新写 <strong>hi, lo</strong> 寄存器。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p>上机一般是两道简单题 <strong>+</strong> 一道难题。可能会涉及改动乘除模块。建议也是提前把课上可能用到的接口留出来。此外上机前可以提前想好添加一个功能时可能要改动哪些相应的信号。</p><p>这里给出一个我在上机时遇到的一个困难指令：<strong>shl</strong></p><p><strong>shl</strong> 的功能是交换乘除法模块中 <strong>hi</strong> 寄存器和 <strong>lo</strong> 寄存器中的值。乍看上去很简单，但是这里存在坑点。比如在乘除法之后紧跟一串 <strong>shl</strong> 指令，最优情况是不进行阻塞。</p><p>标准思路：交换两个寄存器的值，等价于交换两个寄存器的名字。使用一个 <strong>tag</strong> 标记，当 <strong>tag</strong> 为 <strong>1</strong> 时，<strong>hi</strong> 作为 <strong>lo</strong> 寄存器，<strong>lo</strong> 作为 <strong>hi</strong> 寄存器；<strong>tag</strong> 为 <strong>0</strong> ，情况照常。</p><p>这个题实际上是可难可易……如果不卡时间的话（允许乘除法后遇到 <strong>shl</strong> 时阻塞），本题毫无难度，否则难度暴增。（主要是没有考虑到这样阴间的阻塞情况。我在考前一直以为在乘除法后紧跟的是 <strong>mflo</strong> 或 <strong>mfhi</strong>，直到舍友告诉我那是“在乘除法<strong>结束</strong>后紧跟 <strong>mfhi</strong> 或 <strong>mflo</strong>”）</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P6</strong> 的工作基本上只有这些内容了。说实话我感觉 <strong>P5</strong> 做的更艰难一点（毕竟是从头开始搭流水线）。</p><p>有能力的同学也可以在课下空余时间拓展更多指令。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件信息流追踪与 RTL 代码安全性分析综述</title>
      <link href="/2023/01/04/RTL-security-IFT/"/>
      <url>/2023/01/04/RTL-security-IFT/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li><p>计算机安全的<strong>核心原则</strong> = 维护所计算信息的<strong>保密性</strong> +  维护所计算信息的<strong>完整性</strong></p><p>保密性 = 信息只开放给授权用户</p><p>完整性 = 维护信息的准确性 + 一致性</p></li><li><p>信息流跟踪（<strong>IFT</strong>）是一种模拟系统计算时信息传播方式的安全技术。</p><p>特点：拥有一些 <strong>tag</strong> 来表示安全类别，且这些 <strong>tag</strong> 可以更新。</p></li><li><p>本次调研主要介绍<strong>硬件 IFT 分类方法</strong>，用于调查、分类、比较不同的硬件 <strong>IFT</strong> 技术。</p></li></ul><h1 id="Information-Flow"><a href="#Information-Flow" class="headerlink" title="Information Flow"></a>Information Flow</h1><ul><li><strong>IFT</strong> 技术的工作原理 = 用安全类别标记存储对象，并在计算数据时跟踪这些标签</li></ul><h4 id="Storage-Objects-and-Processes"><a href="#Storage-Objects-and-Processes" class="headerlink" title="Storage Objects and Processes"></a>Storage Objects and Processes</h4><ul><li><p>存储对象是信息的容器，进程描述了对这些对象执行的计算。存储对象和进程因安全策略和抽象级别而异。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f38dbe43e0d30e814b86.png" alt="image-20230104101318676"></p><p><em>附：上图为安全语言结构示例。</em></p></li></ul><h4 id="Security-Classes-and-Flow-Relations"><a href="#Security-Classes-and-Flow-Relations" class="headerlink" title="Security Classes and Flow Relations"></a>Security Classes and Flow Relations</h4><ul><li>信息流策略定义了数据对象之间允许的关系。为此，<strong>IFT</strong> 将每个对象与一个安全类别相关联，即给对象一个安全标签或安全标记。</li><li>在实际中，大多数策略使用<img src="https://pic.imgdb.cn/item/63b4f38dbe43e0d30e814ba1.png" alt="image-20230104101707494" style="zoom: 50%;" /> 两元素网络，允许将保密性和完整性相关的安全属性建模为<img src="https://pic.imgdb.cn/item/63b4f40abe43e0d30e81f033.png" alt="image-20230104101833762" style="zoom:67%;" /></li></ul><h4 id="Noninterference"><a href="#Noninterference" class="headerlink" title="Noninterference"></a>Noninterference</h4><ul><li><p>Noninterference 通过将所有系统输入、输出和状态建模为 <strong>high</strong> 或 <strong>low</strong> 来创建信息流模型，指出 <strong>high</strong> 的任何变化不应该导致 <strong>low</strong> 的输出变化。一个主要的挑战是硬件中的对象数量通常比软件中的多得多。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f409be43e0d30e81ef4d.png" alt="image-20230104102613227"></p><p><em>附：上图是 explicit flow 的一个简单示例。</em></p></li></ul><h4 id="Types-of-Information-Flow-Relations"><a href="#Types-of-Information-Flow-Relations" class="headerlink" title="Types of Information Flow Relations"></a>Types of Information Flow Relations</h4><ul><li><p>虽然流关系提供了一种方式来指定与是否允许信息在对象之间传输相关的安全策略，但是它们没有严格定义确定是否存在信息流的方法。 信息可以通过许多不同的方式传播。 理解不同类型的信息流关系以及它们如何在硬件中表现出来，是精确测量所有信息流并进一步严格执行安全策略的重要的第一步。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f409be43e0d30e81ef6d.png" alt="image-20230104102742921"></p><p><em>附：上图是 implicit flow 的一个简单示例。</em></p></li></ul><h4 id="Covert-and-Side-Channels"><a href="#Covert-and-Side-Channels" class="headerlink" title="Covert and Side Channels"></a>Covert and Side Channels</h4><ul><li><p><strong>Covert Channel</strong> 是使用非预期来源的信息传输。</p><p>Covert Channels = storage channel + timing channel</p></li><li><p><strong>Side Channel</strong> 是通过非功能(通常是物理)特征(例如，执行时间、功耗、电磁辐射和声发射)的信息泄漏。</p></li></ul><h1 id="Operator-Precision"><a href="#Operator-Precision" class="headerlink" title="Operator Precision"></a>Operator Precision</h1><h4 id="Precision-of-IFT"><a href="#Precision-of-IFT" class="headerlink" title="Precision of IFT"></a>Precision of IFT</h4><ul><li><strong>IFT</strong> 技术的精度反映了它准确测量硬件设计中所有现有信息流的能力。精确的 <strong>IFT</strong> 技术将精确地模拟硬件设计的信息流行为，而不精确的技术可能指示不存在的信息流，即假阳性（<strong>false positives</strong>），或者错过实际的信息流，即假阴性（<strong>false negatives</strong>）。</li></ul><h4 id="Imprecise-IFT"><a href="#Imprecise-IFT" class="headerlink" title="Imprecise IFT"></a>Imprecise IFT</h4><ul><li>虽然不精确的 <strong>IFT</strong> 技术可能会导致保守的验证结果，但它们通常可以快速分析潜在的信息流安全漏洞， 这对于识别在罕见情况下发生的安全违规非常有用。</li></ul><h4 id="Precise-IFT"><a href="#Precise-IFT" class="headerlink" title="Precise IFT"></a>Precise IFT</h4><ul><li><p>精确 <strong>IFT</strong> 技术在确定流量关系时考虑了硬件组件的功能和输入值， 该标签传播策略可以被形式化为输入及其标签的函数。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f40abe43e0d30e81efba.png" alt="image-20230104104019463"></p><p><em>附：上图表示 flow relation 和 class combining operation的示例，显示了考虑和不考虑数据值的class combining operation的差异。</em></p><ul><li>（a）是与门；</li><li>（b）是不考虑数据值的 <strong>flow relation</strong> 和 <strong>class combining operation</strong>；</li><li>（c）是考虑数据值的 <strong>flow relation</strong> 和 <strong>class combining operation</strong>。</li></ul></li></ul><h4 id="Precision-and-Complexity-Tradeoffs"><a href="#Precision-and-Complexity-Tradeoffs" class="headerlink" title="Precision and Complexity Tradeoffs"></a>Precision and Complexity Tradeoffs</h4><ul><li><p>精确度和复杂性是评估硬件 <strong>IFT</strong> 技术的两个相互矛盾的因素，需要在两者之间进行权衡。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f40abe43e0d30e81f005.png" alt="image-20230104104755791"></p><p><em>附：上图为与门推导简化的硬件 IFT 逻辑，展现了一种有效的方法来推导不同版本的具有可变精度和复杂度的布尔门硬件IFT逻辑，通过逐渐忽略输入，来放松精确度。</em></p></li></ul><h1 id="Security-Properties"><a href="#Security-Properties" class="headerlink" title="Security Properties"></a>Security Properties</h1><ul><li><p>信息流属性被表示为对象上的 <strong>flow relations</strong>。 属性指定存储在硬件对象中的信息能否流向其他对象。</p><p><strong>IFT</strong> 属性是超属性（<strong>hyperproperties</strong>）的例子，因为它们表达了需要跨多个轨迹验证的预期行为。</p></li><li><p>硬件 <strong>IFT</strong> 工具使用存储安全相关信息的标签来模拟信息在硬件中的移动。标签指示对象是可信的还是不可信的，机密的还是公开的，是否包含时间变化等等。属性定义标签的初始条件，以及标签在执行过程中是否可以更改。</p></li></ul><h4 id="Confidentiality"><a href="#Confidentiality" class="headerlink" title="Confidentiality"></a>Confidentiality</h4><ul><li><p>保密性属性确保任何与敏感对象(标记为 <strong>high</strong>)相关的信息永远不会流向未分类的对象(标记为 <strong>low</strong>)。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f455be43e0d30e825002.png" alt="image-20230104110053926"></p><p><em>附：表1的前四行显示了各种硬件设计(如加密内核和算术单元)的保密性属性示例。使用assume语句将敏感对象的标签设置为high，并将公共可见对象的标签设置为low。</em></p></li></ul><h4 id="Integrity"><a href="#Integrity" class="headerlink" title="Integrity"></a>Integrity</h4><ul><li>完整性是保密性的双重含义，在这里我们用 <strong>high</strong> 标签标记不可信的硬件资源，并用 <strong>low</strong> 标签标记它们不会影响关键组件。</li><li><img src="https://pic.imgdb.cn/item/63b4f455be43e0d30e825002.png" alt="image-20230104110053926"><em>附：表1显示了为加密核心（crypto cores）、调试单元（debug units）、处理器（processors）和访问控制单元（ access control units)编写的四个完整性属性。</em></li></ul><h4 id="lsolation"><a href="#lsolation" class="headerlink" title="lsolation"></a>lsolation</h4><ul><li><strong>isolation</strong> 也可以作为信息流安全属性来实施。<strong>isolation</strong> 声明在具有不同信任级别的两个组件之间不应该有信息交换，是一种双向属性。</li></ul><h4 id="Constant-Time"><a href="#Constant-Time" class="headerlink" title="Constant Time"></a>Constant Time</h4><ul><li><p>信息流模型可用于捕获硬件设计中运行时变化产生的时序侧信道。 常数时间属性通过测量计算时间来评估是否可以检索敏感信息。 为了精确地捕获定时流，信息流模型需要区分逻辑流和定时流。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f455be43e0d30e825086.png" alt="image-20230104111258616"></p><p><em>附：表2总结了几种在验证不同硬件设计中的时序侧通道时所使用的特性。</em></p></li></ul><h4 id="Design-Integrity"><a href="#Design-Integrity" class="headerlink" title="Design Integrity"></a>Design Integrity</h4><ul><li><p><strong>IFT</strong> 可用于检测某些类型的未记录的设计修改，这些修改会泄漏敏感信息或通过在设计中插入恶意信息通道来覆盖关键内存位置。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f456be43e0d30e82510b.png" alt="image-20230104112205281"></p><p><em>附：表3总结了 Trust-HUB中GLIFT检测信息泄露的特性。</em></p></li></ul><h1 id="现有的IFT技术"><a href="#现有的IFT技术" class="headerlink" title="现有的IFT技术"></a>现有的IFT技术</h1><h2 id="基于状态机的IFT语言"><a href="#基于状态机的IFT语言" class="headerlink" title="基于状态机的IFT语言"></a>基于状态机的IFT语言</h2><p><strong>Caisson</strong> 和 <strong>Sapper</strong> 是增强了 <strong>IFT</strong> 能力的 <strong>HDL</strong> 语言，可以直接生成执行所需 <strong>IFT</strong> 属性的电路。这两种语言都使用状态机进行硬件设计，并可以防止产生非法流。</p><p><strong>Caisson</strong> 通过静态类型检查来执行。这迫使他保守地执行复制以限制信息流。这会带来很大的硬件区域开销。但也显著地提高逻辑能力。</p><p><strong>Sapper</strong> 添加了动态类型系统以减少逻辑复制的需求。它通过采用混合方法进行标签检查来改进 <strong>Caisson</strong>。它使用静态分析生成一组动态检查，这些检查被插入到硬件设计中，以实现动态跟踪。这样可以重用资源，从而降低区域开销。</p><h2 id="Coq"><a href="#Coq" class="headerlink" title="Coq"></a>Coq</h2><p><strong>Coq</strong> 是一个交互式定理证明器。它允许数学断言的表达式，机械性地检查这些假设的证明，帮助寻找形式化的证明，并从构建性的证明中输出一个关于它的形式化规范的被证明有效的程序。<strong>Coq</strong> 不是一个自动定理证明器，但是包括自动定理证明工具以及各种决策流程。</p><h2 id="VeriCoq-IFT"><a href="#VeriCoq-IFT" class="headerlink" title="VeriCoq-IFT"></a>VeriCoq-IFT</h2><p><strong>VeriCoq-IFT</strong> 自动将设计从 <strong>HDL</strong> 语言转换为 <strong>Coq</strong> 形式语言，无需重新设计硬件。</p><h2 id="SecVerilog"><a href="#SecVerilog" class="headerlink" title="SecVerilog"></a>SecVerilog</h2><p><strong>SecVerilog</strong> 使用表达型类型系统扩展了 <strong>Verilog</strong> 语言。其使用的是静态类型检查方法。<strong>SecVerilog</strong> 用户需要显式地为代码中的每个变量添加安全标签。它使用类型系统来确保支持指定的信息流策略。</p><h2 id="SecChisel"><a href="#SecChisel" class="headerlink" title="SecChisel"></a>SecChisel</h2><p><strong>ChiselFlow</strong> 是另一种类型强制 <strong>HDL</strong>，带有用于开发安全硬件架构的定时标签。它已被用于创建具有硬件级信息流控制的加密加速器，并正式验证这些实现的安全性。</p><h1 id="IFT验证技术"><a href="#IFT验证技术" class="headerlink" title="IFT验证技术"></a>IFT验证技术</h1><p><strong>IFT</strong> 验证技术可以以静态或是动态的方式运行。静态 <strong>IFT</strong> 技术在设计期间通过模拟、形式化方法、仿真等来检查设计是否符合所需的安全属性。验证完成后，<strong>IFT</strong> 模型将被删除。动态硬件 <strong>IFT</strong> 是一种运行时机制，它通过跟踪逻辑来增强原始硬件设计，监视信息流行为并防止有害的信息流。通常需要付出额外的代价，例如，额外的资源使用和性能开销。</p><h2 id="模拟（simulation）"><a href="#模拟（simulation）" class="headerlink" title="模拟（simulation）"></a>模拟（simulation）</h2><p>模拟是验证硬件设计行为的常用方法。硬件安全模拟在测试台输入电路设计，观察结果是否违反了安全策略。</p><h2 id="形式化方法验证"><a href="#形式化方法验证" class="headerlink" title="形式化方法验证"></a>形式化方法验证</h2><p>形式化验证工具可以通过等价性检验、<strong>SAT</strong> 求解、定理证明或类型检验等方式，对信息流模型的安全属性进行形式化(或半形式化)验证。形式化方法的好处是，对于已证明的属性，硬件保证是安全的。验证结果在很大程度上依赖于指定的安全属性的质量和完整性。</p><h2 id="仿真（emulation）"><a href="#仿真（emulation）" class="headerlink" title="仿真（emulation）"></a>仿真（emulation）</h2><p>随着 <strong>IC</strong> 验证平台的发展，领先的 <strong>EDA</strong> 公司也开发了工具来验证 <strong>FPGA</strong> 仿真服务器上硬件设计的信息流安全属性。硬件仿真通常比软件仿真的验证性能好 <strong>10</strong> 倍。仿真是一种很有前途的方法，它利用底层硬件的信息流测量功能来执行安全协同验证并检测利用硬件安全漏洞的软件攻击。</p><h1 id="RTLIFT"><a href="#RTLIFT" class="headerlink" title="RTLIFT"></a>RTLIFT</h1><p>一种 <strong>RTLIFT</strong> 的实现步骤如下所示：设计流程跟踪库；增强跟踪逻辑的组合电路；用跟踪隐式流所需的逻辑增强条件语句。</p><p><img src="https://pic.imgdb.cn/item/63b50acfbe43e0d30ea3607b.jpg" alt=""></p><h2 id="流跟踪库"><a href="#流跟踪库" class="headerlink" title="流跟踪库"></a>流跟踪库</h2><p>为了通过 <strong>RTL</strong> 代码跟踪信息流，每个操作都应该进行检测，以便它可以同时对操作数的布尔值和安全标签进行操作。对于每个操作 <strong>OP</strong>，即 <strong>Z = X OP Y</strong> 是 <strong>Verilog</strong> 中的有效语句，我们定义了一个模块 <strong>OP_IFT</strong>，它接收输入 <strong>X</strong> 和 <strong>Y</strong> 以及它们的安全标签 <strong>X_t</strong> 和 <strong>Y_t</strong>，并生成输出 <strong>Z</strong> 和它的安全标签 <strong>Z_t</strong>。这些模块被预定义，并作为一个称为“流跟踪库”的输入文件提供给 <strong>RTLIFT</strong> 软件。</p><h2 id="显式流跟踪"><a href="#显式流跟踪" class="headerlink" title="显式流跟踪"></a>显式流跟踪</h2><p>流跟踪首先要对每个数据位进行扩展，即在给定的 <strong>Verilog</strong> 代码中连接寄存器，使用标签承载关于数据安全属性的信息。</p><h2 id="隐式流跟踪"><a href="#隐式流跟踪" class="headerlink" title="隐式流跟踪"></a>隐式流跟踪</h2><p>仅仅跟踪显式流可能会因为忽略隐式流的存在而错误地报告条件语句中不存在流。为了跟踪这些流程，对于每个赋值操作，我们都会获得一个影响语句执行的变量列表。在这个列表中，我们生成跟踪隐式流所需的逻辑。</p><p>引用文献：<br><code>Register Transfer Level Information Flow Tracking for Provably Secure Hardware Design. Armaiti Ardeshiricham, Wei Hu, Joshua Marxen and Ryan Kastner Dept. of Computer Science and Engineering, University of California, San Diego</code></p><p><code>Hardware Information Flow Tracking. WEI HU, Northwestern Polytechnical University ARMAITI ARDESHIRICHAM and RYAN KASTNER, University of California, San Diego</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> IFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P5 回顾</title>
      <link href="/2023/01/02/BUAA-CO-P5/"/>
      <url>/2023/01/02/BUAA-CO-P5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是 <strong>bluebean</strong> 的 <strong>P5</strong> 回忆。</p><p>从 <strong>P5</strong> 开始，计组的难度暴增。课上的 <strong>P5</strong> 也是大量同学挂 <strong>P</strong> 的起点。</p><p><strong>P5</strong> 要求我们设计一个五级流水线，并带有完备的转发、阻塞逻辑。</p><p>注：本篇博客中给出的实现方法均为笔者自己的实现方法。实际上的细节实现方法不唯一，笔者的方法也不一定是最优解。</p><h1 id="流水线结构"><a href="#流水线结构" class="headerlink" title="流水线结构"></a>流水线结构</h1><p>五级流水线包含以下内容：</p><ul><li>F级：进行取指令工作。</li><li>D级：进行指令的译码，并取出 <strong>GRF</strong> 中的数据。</li><li>E级：进行 <strong>ALU</strong> 运算操作。</li><li>M级：进行 <strong>DM</strong> 存取操作。</li><li>W级：将数据写回 <strong>GRF</strong> 中。</li></ul><p>其中每两级之间都存在<strong>流水线寄存器</strong>进行级和级之间的数据交换。</p><p>借用 <strong>gxp</strong> 老师 <strong>ppt</strong> 中的图片，流水线结构如下所示：</p><p><img src="../picture/p5_cpu.png" alt=""></p><h1 id="数据冒险与转发"><a href="#数据冒险与转发" class="headerlink" title="数据冒险与转发"></a>数据冒险与转发</h1><p>考虑以下指令：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">I1:</span> <span class="keyword">add </span>$<span class="number">2</span> $<span class="number">0</span> $<span class="number">1</span></span><br><span class="line"><span class="symbol">I2:</span> <span class="keyword">add </span>$<span class="number">3</span> $<span class="number">0</span> $<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>I1</strong> 和 <strong>I2</strong> 的指令在流水线中的流水情况可表示如下（<strong>nop</strong> 表示空指令）：</p><div class="table-container"><table><thead><tr><th>F级</th><th>D级</th><th>E级</th><th>M级</th><th>W级</th></tr></thead><tbody><tr><td>I1</td><td>nop</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>I2</td><td>I1</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>I1</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>I2</td><td>I1</td><td>nop</td></tr></tbody></table></div><p>我们可以看到，当 <strong>I1</strong> 处在 <strong>M</strong> 级时， <strong>I2</strong> 处在 <strong>E</strong> 级。<strong>I1</strong> 的数据要在 <strong>W</strong> 级才能写回 <strong>GRF</strong>，但是 <strong>I2</strong> 指令在 <strong>E</strong> 级就要使用 <strong>I1</strong> 提供的数据（<code>$2</code> 的数据）。如果不采用转发逻辑，则 <strong>I2</strong> 在 <strong>E</strong> 级进行计算时将会使用错误的数据进行计算。</p><p>这就是一种常见的数据冒险。解决数据冒险的办法是增加从 <strong>M</strong> 级到 <strong>E</strong> 级的数据通路，如下图所示（蓝线为新增数据通路）：</p><p><img src="../picture/p5_cpu1.png" alt=""></p><p>在将数据传入 <strong>ALU</strong> 时判断是否产生数据冲突，若产生冲突则采用转发过来的数据。</p><p>除了上图所示的 <strong>M</strong> 级向 <strong>E</strong> 级转发，流水线中还应该包括 <strong>W</strong> 级向 <strong>E</strong> 级转发、<strong>W</strong> 级向 <strong>M</strong> 级转发、<strong>M</strong> 级向 <strong>D</strong> 级转发、<strong>W</strong> 级向 <strong>D</strong> 级转发以及寄存器堆的内部转发。</p><p>这里解释一下寄存器堆的内部转发：在同一时刻，我们可能对同一个寄存器既读又写。在这种情况，我们读出的数据应当是要写入的数据（写入的数据是更新的数据）。这就是寄存器堆的内部转发。</p><p>推荐将转发功能综合成一个模块。拿我的实现举例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> AD1E = A1useE == <span class="number">1&#x27;b0</span> ? RD1E  :</span><br><span class="line"> A1E == <span class="number">1&#x27;b0</span> ? <span class="number">32&#x27;b0</span> :</span><br><span class="line"> A1E == A3M  ? DataM :</span><br><span class="line"> A1E == A3W  ? DataW : RD1E;</span><br><span class="line"><span class="keyword">assign</span> AD2E = A2useE == <span class="number">1&#x27;b0</span> ? RD2E  :</span><br><span class="line"> A2E == <span class="number">1&#x27;b0</span> ? <span class="number">32&#x27;b0</span> :</span><br><span class="line"> A2E == A3M  ? DataM :</span><br><span class="line"> A2E == A3W  ? DataW : RD2E;</span><br></pre></td></tr></table></figure><p>解释一下各个 <strong>wire</strong> 的含义：</p><ul><li><strong>AD1E</strong> 与 <strong>AD2E</strong>：<strong>AD</strong> 是 <strong>Adventure_Data</strong> 的缩写，<strong>E</strong> 代表数据来自 <strong>E</strong> 级，<strong>1</strong> 和 <strong>2</strong> 分别是要传入 <strong>ALU</strong> 的两个操作数。</li><li><strong>A1useE</strong> 与 <strong>A2useE</strong>：<strong>A1</strong> 与 <strong>A2</strong> 分别是要使用到的两个寄存器编号，<strong>use</strong> 代表指令有没有用到寄存器。（如 <strong>addi</strong> 的 <strong>A1use</strong> 是 <strong>1</strong>， <strong>A2use</strong> 是 <strong>0</strong>，因为第二个操作数不来自寄存器堆）</li><li><strong>RD1E</strong> 与 <strong>RD2E</strong>：来自流水线寄存器的流水数据。</li><li><strong>A1E</strong> 与 <strong>A2E</strong>：要使用的寄存器编号。</li><li><strong>A3M</strong> 与 <strong>A3W</strong>：在 <strong>M</strong> 级和 <strong>W</strong> 级的指令各自的写入寄存器编号。</li><li><strong>DataM</strong> 与 <strong>DataW</strong>：分别来自 <strong>M</strong> 级和 <strong>W</strong> 级的数据。</li></ul><p>如此便实现了 <strong>M</strong> 级和 <strong>W</strong> 级向 <strong>E</strong> 级的转发逻辑。其余的转发逻辑类似。可以集成到一个模块里。</p><h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><p>有些时候，转发不能处理所有的数据冲突。</p><p>举例而言：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I1: lw $<span class="number">1</span> <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line">I2: add $<span class="number">2</span> $<span class="number">1</span> $<span class="number">0</span></span><br></pre></td></tr></table></figure><br>假如不增加阻塞逻辑的话，指令流水如下所示：</p><div class="table-container"><table><thead><tr><th>F级</th><th>D级</th><th>E级</th><th>M级</th><th>W级</th></tr></thead><tbody><tr><td>I1</td><td>nop</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>I2</td><td>I1</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>I1</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>I2</td><td>I1</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>nop</td><td>I2</td><td>I1</td></tr></tbody></table></div><p>乍看好像没有问题。但是要注意：<strong>lw</strong> 指令与其他通常的指令不同，要在 <strong>M</strong> 级才能产生新的数据。所以当 <strong>I1</strong> 处于 <strong>M</strong> 级时，<strong>E</strong> 级的 <strong>I2</strong> 是拿不到新数据的。 <strong>I1</strong> 必须要流水到 <strong>W</strong> 级才能够提供最新的数据。</p><p>于是转发处理不了这种数据冲突。所以我们添加<strong>阻塞</strong>逻辑。在解释阻塞之前，先看添加了阻塞逻辑之后的流水图：</p><div class="table-container"><table><thead><tr><th>F级</th><th>D级</th><th>E级</th><th>M级</th><th>W级</th></tr></thead><tbody><tr><td>I1</td><td>nop</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>I2</td><td>I1</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>I1</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>nop</td><td>I1</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>I2</td><td>nop</td><td>I1</td></tr></tbody></table></div><p>可以看到，我们在 <strong>I1</strong> 和 <strong>I2</strong> 之间插入了一条 <strong>nop</strong>，从而让 <strong>I2</strong> 阻塞在 <strong>D</strong> 级。这样当 <strong>I2</strong> 流水到 <strong>E</strong> 级时，就可以拿到 <strong>I1</strong> 提供的新数据了。</p><p>实现阻塞，具体而言，是在阻塞的时候冻结 <strong>F</strong> 级和 <strong>D</strong> 级，并且向 <strong>E</strong> 级传递 <strong>nop</strong> 指令（指令码全为 <strong>0</strong>）。</p><p>我们使用 <strong>AT</strong> 法判断是否需要阻塞。这部分教程讲的很详细。在实现的时候，可以在 <strong>D</strong> 级增加一个处理阻塞的模块，将各级指令产生数据的周期和需要使用数据的周期传入这个模块。模块内部使用寄存器记录处于 <strong>E</strong> 级和 <strong>W</strong> 级指令的 <strong>Tnew</strong>。在 <strong>D</strong> 级接收新的指令时，由这个模块判断新的指令与处于流水过程中的指令产生的数据冲突是否必须采用阻塞解决。若需要阻塞，则由这个模块产生阻塞信号（<strong>stall</strong>）。</p><p>关于 <strong>AT</strong> 法的更多细节可以参考教程。</p><h1 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h1><p>因为我们是在 <strong>D</strong> 级译码，所以跳转指令的判断最早只能在 <strong>D</strong> 级。于是我们就在 <strong>D</strong> 级进行跳转指令的判断。</p><p>要注意，<strong>beq</strong> 指令要使用寄存器的数据，因此也需要对其进行转发和阻塞的判断。并且由于 <strong>beq</strong> 的 <strong>Tuse</strong> 是 <strong>0</strong> （在 <strong>D</strong> 级马上就要使用数据），因此理论上 <strong>beq</strong> 经常需要阻塞的情况。</p><p>在实现跳转时，我们需要在 <strong>D</strong> 级增加一个模块 <strong>NPC</strong>，其向 <strong>F</strong> 级提供跳转使能信号和跳转的目的地址。</p><h1 id="延迟槽"><a href="#延迟槽" class="headerlink" title="延迟槽"></a>延迟槽</h1><p>当我们进行指令跳转时，由于是在 <strong>D</strong> 级做出的判断，按照单周期 <strong>CPU</strong> 的逻辑，处于 <strong>F</strong> 级中的指令（即跳转指令紧跟的下一条指令）理论上就需要作废。</p><p>所谓延迟槽，就是我们让这条<strong>按照单周期逻辑应该作废的指令不作废</strong>，从而提高指令的运行效率。</p><p>事实上，对于延迟槽我们不需要进行额外的操作。无为就可以了（乐）。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p><strong>P5</strong> 的上机难度暴增。许多同学都在 <strong>P5</strong> 献出了首挂。</p><p>上机前建议向流水线中增加额外的数据通路以供课上指令使用（在流水线寄存器中增加课上指令的通路）。</p><p>此外 <strong>P5</strong> 的课上数据点虽然也有课下的强测，但是分布不均，并且大多数测试点仍然是测试课上指令的，这一点与 <strong>P3</strong>、<strong>P4</strong> 不同。</p><p>在课上要认真读题，确保自己读懂了题目再开始写代码。在增加指令的时候一定要仔细地考虑，将每一条指令相关的信号都进行相应的判断。如涉及跳转指令除了要修改 <strong>Controller</strong> 外，还要修改 <strong>NPC</strong> 中的跳转使能信号和跳转地址。</p><p>在课上不要过于拘泥于流水线的结构。有些课上指令十分阴间。比如要在 <strong>M</strong> 级才能得知写入寄存器的编号此类。</p><p>此外就是在课上之前要好好休息，休养精神。笔者因为当天过于疲惫，在课上睡着以至于献出了首挂。大家不要学我啊呜呜呜。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P5</strong> 开始难度骤增。不过如果 <strong>P5</strong> 做的比较好，<strong>P6</strong> 就会简单很多。至于 <strong>P7</strong>，那就又是另一个故事了……</p><p>在这里特别感谢 <strong>yt</strong> 的帮助。没有 <strong>yt</strong>，就没有我的 <strong>p5</strong> （哭）。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P4 回顾</title>
      <link href="/2023/01/01/BUAA-CO-P4/"/>
      <url>/2023/01/01/BUAA-CO-P4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从 <strong>P4</strong> 开始，我们就告别 <strong>logisim</strong>，进入 <strong>verilog</strong> 的领域了。</p><p><strong>P4</strong> 要做的事情很简单，使用 <strong>verilog</strong> 实现单周期 <strong>CPU</strong>。<strong>P4</strong> 的任务实际上就是要把 <strong>P3</strong> 的 <strong>CPU</strong> 翻译到 <strong>verilog</strong> 语言。</p><p>根据不同的实现细节，在 <strong>P4</strong> 会需要数百行的码量。<strong>P4</strong> 的任务相对不难。在编写代码的时候要有良好的代码风格，遵循命名规范。</p><h1 id="CPU-设计"><a href="#CPU-设计" class="headerlink" title="CPU 设计"></a><strong>CPU</strong> 设计</h1><p>在设计上可以完全照搬 <strong>P3</strong> 中用 <strong>logisim</strong> 实现的 <strong>CPU</strong>。另外建议进行模块化设计。<strong>P3</strong> 的模块 <strong>P4</strong> 里最好都继承（或改编）过来，<strong>P3</strong> 中没有综合成模块的地方视情况也可以综合为模块。</p><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><p>在 <strong>verilog</strong> 中遵循一套自己的命名规范是很重要的。无论是驼峰法还是下划线法还是其他的规范，必须在整个代码中遵循同一套命名规范才能利于自己写代码。许多同学在大一的时候没有特意培养自己的代码风格。我的建议是可以在计组实验里开始初步培养代码风格，而不是等到下学期的 <strong>OO</strong>。</p><p>此外，能够让代码更美观的办法比如对齐等。举个例子：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> RegWrite = Add | Sub | And | Or  | Sll |</span><br><span class="line">                  Srl | Lw  | Lui | Ori | Jal |</span><br><span class="line">                  Andi| <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><p>如果将大量堆到一行里或者行之间不对齐都会导致代码的可读性降低。因此，培养良好的代码风格，从 <strong>P4</strong> 开始！</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>在有时序功能模块中记得将寄存器初始化。<strong>GRF</strong> 模块可以直接申请一个寄存器堆，在初始化的时候使用 <strong>for</strong> 循环初始化。要特别注意 <strong>GRF</strong> 中 <strong>0</strong> 号寄存器的值始终为1。</p><p>另外特殊的 <strong>IM</strong> 模块的初始化要使用 <code>$readmemh()</code>。</p><h1 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h1><p>关于 <strong>Controller</strong> 中信号的产生，可以使用宏定义的方式，或使用 <strong>wire</strong> 定义的方式。我个人采用了 <strong>wire</strong> 生成信号，距离如下：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Ori = op == <span class="number">6&#x27;b001101</span> ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> Lw  = op == <span class="number">6&#x27;b100011</span> ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> Sw  = op == <span class="number">6&#x27;b101011</span> ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><br>如此生成对应指令的信号。在使用的时候相当于直接将线接到对应的位置上。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p><strong>P4</strong> 的上机难度和 <strong>P3</strong> 相当，也不是很困难。</p><p>小提示：要提前留好给课上用的接口。这样会方便于通过课上。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>单周期 <strong>CPU</strong> 的绝大多数难点重点工作在 <strong>P3</strong> 中其实都已经设计完了。在 <strong>P4</strong> 中你所需要做的只有耐心的翻译代码。</p><p>话虽如此，<strong>P4</strong> 必须要认真搭建，<strong>P4</strong> 的单周期 <strong>CPU</strong> 是接下来几个 <strong>P</strong> 的起点，也是熟练 <strong>verilog</strong> 语法的机会。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 单周期CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P3 回顾</title>
      <link href="/2022/12/31/BUAA-CO-P3/"/>
      <url>/2022/12/31/BUAA-CO-P3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从 <strong>P3</strong> 开始，工作量暴增。<strong>P3</strong> 的任务是我们使用 <strong>logisim</strong> 搭建一个单周期 <strong>CPU</strong>。想搭好这个 <strong>CPU</strong>，既要充分地掌握 <strong>logisim</strong> 的语法，又得学习单周期 <strong>CPU</strong> 的架构。</p><p>以下我将结合自身搭建的过程举例，讲解 <strong>CPU</strong> 的搭建过程。</p><h1 id="CPU-的顶层模块"><a href="#CPU-的顶层模块" class="headerlink" title="CPU 的顶层模块"></a><strong>CPU</strong> 的顶层模块</h1><p>在搭建前，要对 <strong>CPU</strong> 的整体架构有一个大致的把握。</p><p>单周期 <strong>CPU</strong> 的顶层包含的模块：<strong>PC</strong>，<strong>IM</strong>，<strong>Splitter</strong>，<strong>Controller</strong>，<strong>GRF</strong>，<strong>ALU</strong>，<strong>DM</strong>。</p><p>除此之外也可以增加一些自定义模块，起到增加 <strong>CPU</strong> 集成度，简化布线等作用。</p><p>我自己在 <strong>P3</strong> 增加了两个模块：<strong>GRFChooser</strong> 和 <strong>ALUChooser</strong>，分别选择 <strong>GRF</strong> 和 <strong>ALU</strong> 的输入信号。</p><p>我的 <strong>CPU</strong> 顶层模块一览：</p><p><img src="https://pic.imgdb.cn/item/63b048632bbf0e79945cbd1a.png" alt=""></p><p>通过编辑模块外观做到了简洁布线，视觉效果整体较为美观。</p><h1 id="PC"><a href="#PC" class="headerlink" title="PC"></a><strong>PC</strong></h1><p><strong>PC</strong> 模块的输出端口需要提供当前的指令地址。其输入端口需要包含跳转地址与跳转使能信号。</p><p><strong>PC</strong> 模块在功能上要做到以下两点：</p><ol><li>在经过一个周期后 <strong>PC</strong> 值能自增 <strong>4</strong>。</li><li>在收到跳转类指令时能修改 <strong>PC</strong> 的值到目标地址。</li></ol><h1 id="IM"><a href="#IM" class="headerlink" title="IM"></a><strong>IM</strong></h1><p><strong>IM</strong> 使用 <strong>ROM</strong> 模块实现即可。</p><p>我们需要做的只是初始化 <strong>RAM</strong> 内部数据。将当前指令地址连接到 <strong>RAM</strong> 的地址端，数据端就是对应的 <strong>指令值</strong>。</p><h1 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a><strong>Splitter</strong></h1><p><strong>Splitter</strong> 需要将读到的指令进行拆分，拆分成不同信号传递给不同的模块以供使用。</p><p>其内部直接使用分线器实现即可。</p><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a><strong>Controller</strong></h1><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>在 <strong>Controller</strong> 我们要进行指令的译码工作。根据指令的内容生成相应的控制信号。</p><p>一般而言需包含以下控制信号：</p><ul><li><strong>ALUControl</strong>：控制 <strong>ALU</strong> 模块行为，根据不同指令 <strong>ALU</strong> 对输入需要实现不同的运算。</li><li><strong>MemWrite</strong>：控制 <strong>DM</strong> 模块的写入使能信号。</li><li><strong>GRFWrite</strong>：控制 <strong>GRF</strong> 模块的写入使能信号。</li></ul><p>此外根据个人实现的不同还需要生成跳转信号（<strong>Jal</strong> 和 <strong>Beq</strong>）以及 <strong>GRF</strong>、<strong>ALU</strong>、<strong>DM</strong> 的相应选择信号。</p><p>拿我个人举例，我生成了 <strong>RegChoose</strong> 信号传递给 <strong>REGChooser</strong> 模块来选择读取 <strong>GRF</strong> 的寄存器；生成 <strong>ALUChoose</strong> 模块来选择 <strong>ALU</strong> 模块的操作数；生成 <strong>MemtoReg</strong> 信号来控制写入 <strong>GRF</strong> 的信号是来自 <strong>ALU</strong> 还是 <strong>DM</strong>。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p><strong>Controller</strong> 只需要对指令中的 <strong>op</strong> 字段和 <strong>func</strong> 字段进行译码。因此实际上只需要传入这两个信号就可以。在内部生成信号时，采用与逻辑判断指令，或逻辑生成信号。举例而言：</p><p>采用与逻辑判断指令：<br><img src="../picture/Controller.png" alt=""></p><p>采用或逻辑生成控制信号：<br><img src="../picture/Controller2.png" alt=""></p><p>我的 <strong>Controller</strong> 内的控制信号基本上都是按照这样的逻辑生成的，仅供参考。</p><h1 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a><strong>GRF</strong></h1><p><strong>GRF</strong> 这个东西大家应该在 <strong>P0</strong> 做过了，直接拿过来用就行。这个模块没有什么技术含量，硬着头皮连线就行。</p><h1 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a><strong>ALU</strong></h1><p>运算的操作数都使用 <strong>32</strong> 位数。一般而言需要完成基本的加减乘除还有移位操作。</p><p>所有运算操作都可以使用 <strong>logisim</strong> 内置的运算器实现。</p><h1 id="DM"><a href="#DM" class="headerlink" title="DM"></a><strong>DM</strong></h1><p><strong>DM</strong> 使用 <strong>RAM</strong> 部件即可。<strong>Data Interface</strong> 可设置成 <strong>Separate load and store ports</strong></p><p>下图是 <strong>DM</strong> 的具体连线：</p><p><img src="../picture/DM.png" alt=""></p><p>其中 <strong>MemAddr</strong> 来自于 <strong>ALU</strong> 的运算结果，<strong>MemData</strong> 是写入 <strong>DM</strong> 的数据，来自于 <strong>GRF</strong>。</p><h1 id="ALU-和-GRF-的信号片选"><a href="#ALU-和-GRF-的信号片选" class="headerlink" title="ALU 和 GRF 的信号片选"></a><strong>ALU</strong> 和 <strong>GRF</strong> 的信号片选</h1><p>这部分可以按照自己的方式自行设计。</p><p>我在这部分的设计是这样的：</p><ol><li>传给 <strong>ALU</strong> 的第一个操作数默认来自 <strong>GRF</strong> 的 <strong>RD1</strong>，于是在 <strong>REGChooser</strong> 模块里要对传给 <strong>GRF</strong> 的第一个读数地址 <strong>A1</strong> 进行相应的选择。</li><li>传给 <strong>ALU</strong> 的第二个操作数从 <strong>GRF</strong> 的 <strong>RD2</strong>、指令的 <strong>shamt</strong> 字段（用于 <strong>sll</strong>  和 <strong>srl</strong> 指令的移位操作）、有符号扩展立即数和无符号扩展立即数（立即数来自于指令的立即数字段）。</li><li><strong>GRF</strong> 的写入数据来自于 <strong>DM</strong>、<strong>ALU</strong>、以及指令的 <strong>instr_index</strong> 字段（用于 <strong>Jal</strong> 指令）。</li><li>根据要实现的以上功能，依据不同的指令生成对应的控制信号。集成设计 <strong>Chooser</strong> 。</li></ol><p>关于我在这部分的连线可以参考上文的顶层模块图。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p>上机的时候会让你添加一些奇怪的指令。在课下建议扩展移位指令 <strong>sll</strong> 和 <strong>srl</strong> ，以及存取指令 <strong>sb</strong>、<strong>sh</strong>、<strong>lb</strong>、<strong>lh</strong>。此外对 <strong>logism</strong> 中一些基本但是不常用的运算器等也要好好掌握，比如 <strong>Bit Adder</strong>。</p><p>在课上扩展指令的时候要仔细判断控制信号的生成。建议在课下的 <strong>CPU</strong> 中预留接口。我在课上添加指令的时候基本都是采用对课上指令特判的方式。整体而言，<strong>P3</strong> 的课上是很简单的，只要课下做的足够认真，课上 <strong>AK</strong> 都不会有问题。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P3</strong> 是我搭建的第一个 <strong>CPU</strong>。当时是照着计组的大黑书生闷硬造的。从整体架构到细节都由自己设计，看着搭建完的 <strong>CPU</strong> 心中是成就感满满。</p><p>这或许也是学习计组的乐趣所在吧。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> logisim </tag>
            
            <tag> 单周期CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P0 到 P2 回顾</title>
      <link href="/2022/12/31/BUAA-CO-P0-P2/"/>
      <url>/2022/12/31/BUAA-CO-P0-P2/</url>
      
        <content type="html"><![CDATA[<p>在写下这篇博客的时候，<strong>CO</strong> 课程已经结束了。在此回忆并记录一下计组实验过程中那些难忘的经历。</p><h1 id="P0"><a href="#P0" class="headerlink" title="P0"></a><strong>P0</strong></h1><p><strong>P0</strong> 要求我们掌握 <strong>logisim</strong> 的基本用法，并且要会在 <strong>logisim</strong> 中实现摩尔型状态机和米莉型状态机。</p><p>关于 <strong>logisim</strong> 的基本部件，我在学习的时候主要参考查阅了以下博客：</p><p><a href="https://blog.csdn.net/Hi_KER/article/details/120928866">Logisim元件用法详解一：Wiring 线</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121044637">Logisim元件用法详解二：Gates 门</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121049347">Logisim元件用法详解四：Arithmetic 运算器</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121046215">Logisim元件用法详解三：Plexers 复用器</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121059937">Logisim元件用法详解五：Memory 储存库</a></p><p>这几篇博客对基本部件的基本功能叙述基本齐全，在学习 <strong>logisim</strong> 的时候给了我很大帮助。</p><p>在此补充一下关于 <strong>ROM</strong> 和 <strong>RAM</strong> 部件的使用方法：</p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a><strong>ROM</strong></h2><p><strong>ROM</strong> 是只读存储器。在我们的课程中主要用于 <strong>P3</strong> 中指令存储器的设计。</p><p>侧边栏功能介绍：</p><p><img src="../picture/RAM.png" alt=""></p><ul><li><strong>Address Bit Width</strong>：这是地址位数，决定 <strong>ROM</strong> 的容量。</li><li><strong>Data Bit Width</strong>：这是数据的位数。</li><li><strong>Contents</strong>：点击这里来编辑 <strong>ROM</strong> 中的内容。</li></ul><p>编辑 <strong>RAM</strong> 中的内容需要打开文本文件。点击 <strong>Contents</strong> 后页面如下所示：<br><img src="../picture/RAMContents.png" alt=""><br>点击 <strong>Open</strong> 可以选择载入 <strong>txt</strong> 中的内容。点击 <strong>Save</strong> 可以将 <strong>ROM</strong> 中的内容保存在本地文件中。</p><p><strong>logisim</strong> 对于载入 <strong>ROM</strong> 的文本有格式要求：首行必须是 <code>v2.0 raw</code>，并且以十六进制格式导入数据。</p><p>比如我上面那个 <strong>Contents</strong> 示例就是将以下内容导入到 <strong>ROM</strong> 之后的结果。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v2.0 raw</span><br><span class="line">3c1fff10</span><br><span class="line">37ff00ff</span><br><span class="line">0c000c00</span><br></pre></td></tr></table></figure><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a><strong>RAM</strong></h2><p><strong>RAM</strong> 是随机存储存储器。其 <strong>Address Bit Width</strong> 和 <strong>Data Bit Width</strong> 的意义和 <strong>ROM</strong> 相同。<strong>Data Interface</strong> 可以改变 <strong>RAM</strong> 的存取端口设置。</p><p>在 <strong>P3</strong> 中，一般采用 <strong>Separate load and store ports</strong> 设置（分离的加载和存储端口）。</p><p>此外我们可以右键 <strong>RAM</strong> 模块，来编辑或清空 <strong>RAM</strong> 模块的内容。编辑 <strong>RAM</strong> 模块内容的方法和 <strong>ROM</strong> 相同。</p><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>要好好理解摩尔型状态机和米莉型状态机的区别，明确实现方法。</p><h3 id="摩尔型状态机"><a href="#摩尔型状态机" class="headerlink" title="摩尔型状态机"></a>摩尔型状态机</h3><p>一言以蔽之，输出只取决于当前状态，次态由当前状态和输入共同决定，在时钟上升沿来临时更改状态。</p><h3 id="米莉型状态机"><a href="#米莉型状态机" class="headerlink" title="米莉型状态机"></a>米莉型状态机</h3><p>与摩尔型状态机不同的地方在于<strong>输出由当前状态和输入共同决定</strong>。这意味着，当输入改变时，即使时钟上升沿没有到来，输出也应该随着输入的改变而做出相应的变化。</p><h3 id="同步复位与异步复位"><a href="#同步复位与异步复位" class="headerlink" title="同步复位与异步复位"></a>同步复位与异步复位</h3><p>异步复位的做法十分简单，直接将复位信号连接到 <strong>register</strong> 的 <strong>reset</strong> 端口即可。</p><p>同步复位则稍微复杂一些。给出一个往届的方法：</p><p><img src="../picture/reset2.png" alt=""></p><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p>设计状态机的过程中最重要的一点是设计好状态转移的过程。 <strong>logisim</strong> 中可以根据真值表自动生成电路。这个方法在计组的教程中讲的已经十分详细了。在我们设计的状态机的状态位数和输入位数之和不太多的情况下，可以利用这一功能快速生成状态转移模块。</p><p>具体做法如下：</p><p><img src="../picture/Moore.png" alt=""></p><p>因为按照真值表生成的电路的输入输出端口只能是一位的，故我们要将状态转移模块的输入拆分开，输出合并起来。上图中 <strong>register</strong> 中存储现态， <strong>now</strong> 代表现态输出，<strong>in</strong> 代表输入，<strong>next</strong> 代表次态。这个电路中的 <strong>MUX</strong> 起到了同步复位的作用。</p><p>其中状态转移模块内部就是由 <strong>logisim</strong> 根据真值表自动生成的电路。我们不需要关心内部具体是什么样子的，只需要保证我们的转移逻辑和拆分、合并信号时连线没有错误就可以。</p><h2 id="编辑模块外观"><a href="#编辑模块外观" class="headerlink" title="编辑模块外观"></a>编辑模块外观</h2><p><strong>logisim</strong> 默认的模块外观总是比较丑陋的…我们可以点击这个摁钮来编辑模块的外观：</p><p><img src="../picture/logisim.png" alt=""></p><p>我们可以编辑模块的形状、端口位置、添加文字说明等等。通过编辑模块的外观我们可以大大美化电路，这在 <strong>P3</strong> 中尤为明显（或许不是十分的重要）。</p><h2 id="合理运用-Tunnel"><a href="#合理运用-Tunnel" class="headerlink" title="合理运用 Tunnel"></a>合理运用 <strong>Tunnel</strong></h2><p><strong>Tunnel</strong> 是尤为常用的一个部件。合理使用 <strong>Tunnel</strong> 能大大简化我们的布线，让模块整体更加美观。但是不建议滥用 <strong>Tunnel</strong>。滥用的缺点是让电路更难看懂（因为不能直观的看到连线情况）。</p><h2 id="一个-logisim-的-bug"><a href="#一个-logisim-的-bug" class="headerlink" title="一个 logisim 的 bug"></a>一个 <strong>logisim</strong> 的 <strong>bug</strong></h2><p>我在 <strong>P0</strong> 上机的时候遇到了一个 <strong>logisim</strong> 的 <strong>bug</strong>：所有的连线全部是蓝色 的。遇到这种情况首先要检查 <strong>Simulate</strong> 设置中的 <strong>Simulation Enable</strong> 选项，这个选项应该是打开的；然后在保存后直接重启 <strong>logisim</strong> 就可以恢复啦！</p><h1 id="P1"><a href="#P1" class="headerlink" title="P1"></a><strong>P1</strong></h1><p>在 <strong>P1</strong> 中我们要掌握 <strong>Verilog</strong> 的基本语法，学会组合逻辑和时序逻辑，并且要会在 <strong>Verilog</strong> 中写状态机。</p><h2 id="常数的写法"><a href="#常数的写法" class="headerlink" title="常数的写法"></a>常数的写法</h2><p><strong>verilog</strong> 中常数的写法是 <code>&lt;常数位数&gt;&#39;&lt;类型&gt;&lt;值&gt;</code>。教程里说的很详细，这里不再多说。</p><p>主要是想提醒大家在写代码的时候每一个数字都要遵循 <code>&lt;常数位数&gt;&#39;&lt;类型&gt;&lt;值&gt;</code> 的形式，不要没头没尾的写一个数字上去。一般而言，写 <strong>verilog</strong> 程序中我们接触二进制、十六进制数字的次数要比十进制数字的次数多得多。</p><h2 id="阻塞赋值与非阻塞赋值"><a href="#阻塞赋值与非阻塞赋值" class="headerlink" title="阻塞赋值与非阻塞赋值"></a>阻塞赋值与非阻塞赋值</h2><p>在初学 <strong>Verilog</strong> 时要区分阻塞赋值与非阻塞赋值。</p><h3 id="阻塞赋值"><a href="#阻塞赋值" class="headerlink" title="阻塞赋值"></a>阻塞赋值</h3><p>阻塞赋值使用 <code>=</code>。阻塞赋值可以理解为物理上的直接连线。当右边的值（驱动量）发生变化时，左侧值将立刻发生变化。建议只在组合逻辑中使用阻塞赋值。</p><p>阻塞赋值一般是赋值给 <strong>wire</strong> 型变量的。但是视情况也可以赋值给 <strong>reg</strong> 型变量和 <strong>integer</strong> 型变量。</p><h3 id="非阻塞赋值"><a href="#非阻塞赋值" class="headerlink" title="非阻塞赋值"></a>非阻塞赋值</h3><p>非阻塞赋值使用 <code>&lt;=</code>。非阻塞赋值会在一个块结束后统一赋值。比如下列代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">    b &lt;= a;</span><br><span class="line">    a &lt;= b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以上代码的结果是在每一个时钟上升沿到来时交换 <strong>a</strong> 和 <strong>b</strong> 的值。非阻塞赋值建议只在 <strong>always</strong> 块内给 <strong>reg</strong> 型变量赋值使用（时序逻辑）。</p><h2 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h2><p>组合逻辑有两种写法，一种是使用 <strong>wire</strong> 和阻塞赋值（下称连线），一种是使用 <strong>wire</strong> 和 <code>always@(*)</code> 块内使用非阻塞赋值。我个人比较喜欢使用第一种写法。在进行条件判断时，要嵌套三目运算符 <code>? :</code>。</p><p>使用第一种写法时注意 <strong>wire</strong> 型变量只能连线一次。此外可以在定义 <strong>wire</strong> 型变量时直接连线。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> judge = <span class="keyword">input</span> &amp; <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]ans = en == <span class="number">1&#x27;b0</span> ? <span class="number">2&#x27;b00</span> :</span><br><span class="line">                judge == <span class="number">1&#x27;b1</span> ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b10</span>;</span><br></pre></td></tr></table></figure><p>上述代码的功能：当使能信号 <strong>en</strong> 为 <strong>0</strong> 时，<strong>ans</strong> 保持为 <strong>0</strong>，当使能信号为 <strong>1</strong> 且输入为奇数时， <strong>ans</strong> 为 <strong>1</strong>，否则为 <strong>2</strong>。</p><h2 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h2><p>时序逻辑使用 <strong>always</strong> 块和非阻塞赋值。建议一个模块只使用一个 <strong>always</strong> 块，并且在一个 <strong>always</strong> 内要保证每个时钟上升沿来临时对使用到的每个 <strong>reg</strong> 变量都<strong>有且仅有</strong>一次赋值。</p><p>在时序逻辑中可以使用 <em>if-else</em> 语句和 <em>switch</em> 语句进行条件判断。不再多说。</p><h2 id="同步复位与异步复位-1"><a href="#同步复位与异步复位-1" class="headerlink" title="同步复位与异步复位"></a>同步复位与异步复位</h2><p>同步复位的写法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset == <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行复位操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行其他操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>异步复位的写法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset == <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行复位操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行其他操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这两种复位方法都要掌握，在上机时一般都会考到。</p><h2 id="状态机-1"><a href="#状态机-1" class="headerlink" title="状态机"></a>状态机</h2><p>在通过 <strong>P0</strong> 之后相信对两种状态机已经足够了解了。在 <strong>verilog</strong> 中实现两种状态机并不难。合理地将组合逻辑和时序逻辑组合使用便可以搭建两种状态机。在写状态机的时候最重要的还是设计状态和状态转移逻辑，编写代码只需要足够的细心即可。</p><p>在编写时序逻辑的时候要注意每一个 <strong>if</strong> 块都要有 <strong>else</strong> 作为结尾，在 <strong>else</strong> 内部编写 <strong>default</strong> 逻辑。</p><h1 id="P2"><a href="#P2" class="headerlink" title="P2"></a><strong>P2</strong></h1><p>在 <strong>P2</strong> 中，我们要掌握 <strong>Mars</strong> 的用法。<strong>Mars</strong> 的用法在教程里教的很详细，不再多说。这里主要是提几点建议和要注意的地方。</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>写 <strong>Mars</strong> 程序时要合理地使用宏（<code>.micro</code>）来简化代码。诸如读取数字、输出数字、数据的压栈、弹栈等都可以使用宏来编写。这里给两个压栈和弹栈的例子：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据压栈</span></span><br><span class="line"><span class="meta">.macro</span> stackPush(%num)</span><br><span class="line"><span class="keyword">sw </span>%num <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">sp</span> $<span class="built_in">sp</span> -<span class="number">4</span></span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据弹栈</span></span><br><span class="line"><span class="meta">.macro</span> stackPop(%num)</span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">sp</span> $<span class="built_in">sp</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">lw </span>%num <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>写递归的时候要注意数据的压栈和弹栈。在进入函数的时候压栈，在函数结束的时候弹栈。</p><p>一般使用 <strong>$a0-$a3</strong> 来进行函数的传参，使用 <strong>$v0-$v1</strong> 来接受函数的返回值。</p><h2 id="Mars-文档"><a href="#Mars-文档" class="headerlink" title="Mars 文档"></a><strong>Mars</strong> 文档</h2><p>在 <strong>Mars</strong> 中 <strong>F1</strong> 键可以调出 <strong>Mars</strong> 帮助文档。在写代码的时候可以提供莫大帮助。在上机前建议弄懂字符串的读写，我这届有许多同学因为不了解字符串的读写而在 <strong>P2</strong> 上机的时候翻车。</p><h2 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h2><p><strong>P2</strong> 上机写 <strong>Mars</strong> 代码个人感触最重要的还是细心。在 <strong>P2</strong> 中哪怕写错一个寄存器的名字也会寄。细心编写的代码能减少 $80$% 的 <strong>bug</strong>。我在上机时遇到的 <strong>bug</strong> 基本全都是因为粗心导致的。</p><p>在上机前可以提前在机房电脑上做一些准备，诸如调整机房里 <strong>Mars</strong> 的字体设置等；也可以背下来一些宏，提前敲进去。</p><p>一般而言 <strong>P2</strong> 的上机都是翻译 <strong>C</strong> 语言代码。如果他没有给出 <strong>C</strong> 代码，那就自己写一份 <strong>C</strong> 代码再翻译成 <strong>Mars</strong> 代码，能减少 <strong>bug</strong> 数量和 <strong>dbug</strong> 难度。在翻译代码的时候合理分配那几个寄存器的使用，个人翻译本身感觉难度不大。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大致回忆了一下 <strong>P0</strong> 到 <strong>P2</strong> 的知识点和坑点。这几个 <strong>P</strong> 都是在为后面搭 <strong>CPU</strong> 打基础，因此难度不是很大。</p><p>欢迎在评论区讨论交流。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> logisim </tag>
            
            <tag> verilog </tag>
            
            <tag> mips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客~</title>
      <link href="/2022/12/29/hello-world/"/>
      <url>/2022/12/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是 <strong>bluebean</strong> 的第一篇博客，记录一下搭建过程顺便测试测试各种功能~</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>搭建过程中真是参考了很多大佬的博客呀。</p><p>搭建过程中遇到了一些坑。本来想采用 <strong>Matery</strong> 主题的，但是实在是调不来配置了……接触 <strong>Butterfly</strong> 主题后我发现这个主题更加完善，<strong>bug</strong> 更少，风格也十分简洁，故最后选择了配置<strong>Butterfly</strong> 主题。</p><p>以下是对我帮助十分大的几篇博客：</p><p>从零开始，使用 <strong>butterfly</strong> 主题搭建博客：<a href="https://www.fomal.cn/posts/e593433d.html#8-%E5%88%9D%E5%A7%8B%E5%8C%96-Hexo-%E9%A1%B9%E7%9B%AE">Hexo博客搭建基础教程</a></p><p>另一篇从零开始的教程：<a href="https://www.cnblogs.com/huanhao/p/hexobase.html#%E5%9F%BA%E7%A1%80%E7%AF%87%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E4%B8%80">hexo博客搭建教程</a></p><p>这篇博客有对 <strong>butterfly</strong> 主题各项配置的详细说明：<a href="https://www.fomal.cn/posts/3451f874.html">Butterfly配置</a></p><p>这篇博客也作为参考：<a href="https://moonshuo.cn/posts/37568.html">Butterfly主题配置美化</a></p><h2 id="公式测试"><a href="#公式测试" class="headerlink" title="公式测试"></a>公式测试</h2><p>随便输点公式，测试一下对数学公式的支持。</p><p>整行公式：</p><script type="math/tex; mode=display">f(x)=\begin{cases} \frac{\beta^\alpha}{\Gamma(\alpha)},\quad x>0\\ 0,\quad x\leq0\end{cases}</script><script type="math/tex; mode=display">g(x,y)=x+y*2</script><p>行内公式：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.902ex;" xmlns="http://www.w3.org/2000/svg" width="17.725ex" height="3.058ex" role="img" focusable="false" viewBox="0 -952.7 7834.6 1351.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mo" transform="translate(0 0.5)"><path data-c="222B" d="M113 -244Q113 -246 119 -251T139 -263T167 -269Q186 -269 199 -260Q220 -247 232 -218T251 -133T262 -15T276 155T297 367Q300 390 305 438T314 512T325 580T340 647T361 703T390 751T428 784T479 804Q481 804 488 804T501 805Q552 802 581 769T610 695Q610 669 594 657T561 645Q542 645 527 658T512 694Q512 705 516 714T526 729T538 737T548 742L552 743Q552 745 545 751T525 762T498 768Q475 768 460 756T434 716T418 652T407 559T398 444T387 300T369 133Q349 -38 337 -102T303 -207Q256 -306 169 -306Q119 -306 87 -272T55 -196Q55 -170 71 -158T104 -146Q123 -146 138 -159T153 -195Q153 -206 149 -215T139 -230T127 -238T117 -242L113 -244Z"></path></g><g data-mml-node="TeXAtom" transform="translate(699.9,532.6) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(505,-340.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g></g><g data-mml-node="msup" transform="translate(2173.8,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(778,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g><g data-mml-node="mi" transform="translate(3986.1,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(4506.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(5355.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msqrt" transform="translate(6411.6,0)"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g><g data-mml-node="mo" transform="translate(0,-22.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="570" height="60" x="853" y="717.5"></rect></g></g></g></svg></mjx-container></p><h2 id="代码块测试"><a href="#代码块测试" class="headerlink" title="代码块测试"></a>代码块测试</h2><p>代码块测试：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>行内代码测试：<code>printf("hello world!\n");</code></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
