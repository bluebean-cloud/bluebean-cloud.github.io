<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面向对象课程 HW2</title>
      <link href="/2023/03/04/OO-hw2/"/>
      <url>/2023/03/04/OO-hw2/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象第二次作业"><a href="#面向对象第二次作业" class="headerlink" title="面向对象第二次作业"></a>面向对象第二次作业</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相较于第一次作业，第二次作业进行迭代开发主要完成的功能有：</p><ol><li>支持三角函数</li><li>支持自定义函数</li></ol><p>括号嵌套应当在第一次作业中就已经实现，故不多言。</p><hr><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>作为迭代开发，添加的新功能事实上并不多。<strong>hw2</strong> 的类图如下所示：</p><p><img src="https://pic.imgdb.cn/item/64023415f144a0100761b22e.jpg"></p><p>本次迭代中主要涉及到的工作有：</p><ul><li>新增了 <strong>Function</strong> 类，用于存储自定义函数的定义并作为 <strong>Parser</strong> 的属性参与解析过程。</li><li>在 <strong>Var</strong> 类中新增了属性 <strong>exprs</strong>，用于存储三角函数的表达式。</li><li>对 <strong>Expr</strong>、<strong>Term</strong>、<strong>Var</strong> 三个类新增了 <strong>equals()</strong> 方法。</li><li>对 <strong>Parser</strong> 类新增了 <strong>parseBracket()</strong> 用于专门解析括号，<strong>parseFunction()</strong> 用于专门解析函数。</li><li>对 <strong>Lexer</strong> 类增加了识别 <strong>Function</strong> 的方法：**getFunction()**。</li><li>对预处理函数进行了若干调整。</li></ul><h2 id="迭代思路"><a href="#迭代思路" class="headerlink" title="迭代思路"></a>迭代思路</h2><h3 id="处理三角函数"><a href="#处理三角函数" class="headerlink" title="处理三角函数"></a>处理三角函数</h3><p>由于我整体解析的结构遵循 <strong>表达式（Expr）-&gt;项（Term）-&gt;原子项（Var）</strong> 的顺序，因此我将三角函数作为一项新的属性添加到了原子项当中。</p><p>在我的视图中，三角函数等价于一个表达式。即 <strong>sin(Expr)~Expr</strong>。于是在判断两个三角函数是否相等时判断其内部的表达式是否相等即可。为此我在 <strong>Expr</strong>、<strong>Term</strong>、<strong>Var</strong> 三个类中都添加了 <strong>equals()</strong> 方法。</p><p>在读取到三角函数时，处理方式与处理括号类似：解析 <strong>sin(Expr)</strong> 中的 <strong>Expr</strong>，并作为一项属性添加到 <strong>Var</strong> 当中。</p><p>有关三角函数的化简，过于阴间的化简对于我的架构来说实现有些困难。于是只做了一些基础的处理，比如将 <strong>sin(0)</strong> 化作 <strong>0</strong>，<strong>cos(0)</strong> 化作 <strong>1</strong> 等。</p><h3 id="处理自定义函数"><a href="#处理自定义函数" class="headerlink" title="处理自定义函数"></a>处理自定义函数</h3><p>对于自定义函数，我新建了一个类 <strong>Function</strong>。这个类只有三个方法，一个 <strong>getState()</strong> 用于获取内部属性，一个 <strong>Function()</strong> 用于初始化函数，一个 <strong>call</strong> 用于函数的调用。</p><p>对于初始化，主要工作是将形式参数替换成我所规定的形式并将整个表达式作为字符串存储。举例而言：<br><code>f(x,y)=sin(x**2)+y</code> 经处理后，会变成 <strong>sin(($0)**2)+($1)</strong> 存储进 <strong>function</strong> 的 <strong>expr</strong> 中。</p><p>在自定义函数的调用过程中，流程如下：</p><ol><li>识别实参列表。</li><li>将 <strong>$n</strong> 替换成实参。</li><li>对替换后的字符串进行表达式解析。</li><li>传回解析结果。</li></ol><p>具体的处理与对括号的处理类似，能够支持函数间的嵌套调用。</p><p>值得一提的是，在获取实参时，我利用了一个栈来匹配实参列表中的实参。（当识别到 “,” 且处于最外层括号时，说明读取到了一个完整的实参）</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>对预处理函数的主要处理有：将 <strong>cos1*(</strong> 、<strong>sin1*(<strong>、</strong>f1*(</strong> 等替换回 **cos(<strong>、</strong>sin(<strong>、</strong>1*f(**。（记得吗，我之前将 <strong>(</strong> 预处理为 <strong>1*(</strong> ）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第二周的压力比第一周小了很多，仿佛一切都在步上正轨，令人欣慰。虽然一度为弱智 <strong>bug</strong> 所苦恼，不过跟第一周的坐牢比起来已经幸福太多了。并且由于第一周架构比较合理（貌似是），我在本次的迭代开发的过程中并未遇到什么困难，整体架构也几乎没有变动。唯一最大的困难就是我本人捉急的码力（悲）。</p>]]></content>
      
      
      <categories>
          
          <category> -面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 计算器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象课程 HW1</title>
      <link href="/2023/02/28/OO-hw1/"/>
      <url>/2023/02/28/OO-hw1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象第一次作业"><a href="#面向对象第一次作业" class="headerlink" title="面向对象第一次作业"></a>面向对象第一次作业</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次 <strong>OO</strong> 作业经历过一次重构，而且重构的完成时间是在提交截止之后（哭）。所以强测寄的很惨，呜呜呜。（不过在房里刀的也很爽）</p><p>不过这份重构我个人是十分满意的。</p><p>特别感谢 <strong>sheep</strong> 和 <strong>toby</strong> 的帮助！</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>类图如下所示：</p><p><img src="https://pic.imgdb.cn/item/63fdb4d7f144a01007c743f6.jpg"></p><ul><li><strong>Expr</strong>：表达式</li><li><strong>Term</strong>：项</li><li><strong>Var</strong>：原子项</li><li><strong>Lexer</strong>：词法分析器</li><li><strong>Parser</strong>：语法分析器</li><li><strong>Tool</strong>：工具类</li></ul><p>注：图中省略了若干构造函数和获取类属性的接口。</p><h2 id="化简流程"><a href="#化简流程" class="headerlink" title="化简流程"></a>化简流程</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>合适的预处理是必要的。这部分工作在 <strong>Tool.preTreat()</strong> 中进行。具体进行的工作有（按照操作顺序）：</p><ol><li>去除所有空字符</li><li>将 “(” 替换成 “1*(”</li><li>将所有连续的正负号化简成一个符号</li><li>将 “*+” 化简成 “*”</li><li>将 “**” 化简成 “^”</li></ol><p>经过预处理后，我们得到的字符串中没有任何的空白与连续的符号，并且乘方使用 “^” 表示后更加易于处理。其中步骤 2 的设计与我化简流程的逻辑有关。</p><p>使用 <strong>replaceAll()</strong> 正则替换就可以实现预处理。</p><h3 id="宏观视图"><a href="#宏观视图" class="headerlink" title="宏观视图"></a>宏观视图</h3><p>将表达式视作 <strong>表达式-&gt;项-&gt;原子项</strong> 的结构。即：</p><ul><li>Expr &#x3D; Term + Term</li><li>Term &#x3D; Var * Var</li></ul><p>对于符号，解析时首先将符号读取至原子项中，在化简过程中将符号归一到其所属的项中。</p><p>对于括号，整个解析过程是边解析边化简的。具体而言，在读取到括号时我会将括号内部视作一个表达式进行解析，返回经过化简后的 <strong>ArrayList&lt;Term&gt;<strong>（</strong>ArrayList&lt;Term&gt;</strong> 与表达式在逻辑上是等价的）。</p><p>由于 <strong>ArrayList&lt;Term&gt;</strong> 与表达式在逻辑上是等价的，故 <strong>parseExpr()</strong> 与 <strong>parseTerm()</strong> 的返回值都是 **ArrayList&lt;Term&gt;**。后者之所以返回数组是为了支持括号的解析。</p><h3 id="对括号的处理"><a href="#对括号的处理" class="headerlink" title="对括号的处理"></a>对括号的处理</h3><p>在预处理时，括号前一定是 “1*”，而分析乘法的过程是在 <strong>praseTerm()</strong> 中进行的，所以在遇到括号时一定处于调用 <strong>praseTerm()</strong> 的过程中。</p><p>遇到括号时，在 <strong>praseTerm()</strong> 中递归调用 **praseExpr()**。在 <strong>praseExpr()</strong> 中将括号内的表达式分析、化简完毕再回溯到 **praseTerm()**（此时 <strong>parseTerm()</strong> 就会返回多个 <strong>Term</strong>）。</p><p>举例而言：对于 <code>1+(x**2-1)*3</code>，经过预处理后：<code>1+1*(x**2-1)*3</code>，在读取到 “**(**” 时处于 <strong>parseTerm（）</strong> 的调用中。经调用 <strong>parseExpr（）</strong> 后得到一个 <strong>ArrayList&lt;Term&gt;<strong>。之后接着读取处理后面的 <code>*3</code>，最后返回的 <strong>Term</strong> 数组中包含 <strong>3*x**2</strong>，</strong>-3</strong>。</p><h3 id="对乘方的处理"><a href="#对乘方的处理" class="headerlink" title="对乘方的处理"></a>对乘方的处理</h3><p>“^” 可能出现在 “xyz)” 的后面。于是在 <strong>praseVar()</strong> 中和 <strong>praseTerm()</strong> 中相应的位置直接进行分析、展开（暴力循环即可）。我使用 <strong>Var</strong> 中的一个属性 <strong>index</strong> 来存储原子项（<strong>xyz</strong> 与数字，不过数字的乘方采取直接计算的方法）的乘方。</p><h3 id="另注"><a href="#另注" class="headerlink" title="另注"></a>另注</h3><p>所有的正负号最后都会归集到 <strong>praseVar()</strong> 中进行分析（ “-(” 的情况变成了 “-1*(” ）。</p><p>由于 <strong>exprSimplify</strong> 的化简需要返回一个 <strong>ArrayList</strong> 以方便进行进一步计算，我将这个函数放到了工具类当中。</p><h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><p>后处理（ <strong>afterTreat</strong> ）的时候使用正则替换进行简单的优化。步骤为：</p><ol><li>将 “^” 展开为 “**”</li><li>将 “+1*” 化简为 “+”</li><li>将 “-1*” 化简为 “-”</li><li>去除首位的正号</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面向对象课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
            <tag> Java </tag>
            
            <tag> 计算器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P7 回顾</title>
      <link href="/2023/01/05/BUAA-CO-P7/"/>
      <url>/2023/01/05/BUAA-CO-P7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做完前六 <strong>P</strong> 之后，我们已经做出来一个相当厉害的流水线了。在 <strong>P7</strong> 中，我们的任务是增加外部中断响应和异常处理。</p><p>本篇博客中我将结合我做 <strong>P7</strong> 的方法，按照我的搭建过程逐个讲解 <strong>P7</strong> 中所要完成的工作。</p><p>注：本篇博客记录的是 <strong>21</strong> 级的 <strong>P7</strong> 搭建过程。计组课程组每年都可能会对细节有一些改动。因此建议自行甄别内容。最终实现细节还请以教程为准。</p><h1 id="调整模块架构"><a href="#调整模块架构" class="headerlink" title="调整模块架构"></a>调整模块架构</h1><p>在 <strong>P7</strong> 中，我们需要对流水线的架构做一些调整。我们需要添加<strong>系统桥</strong>和两个<strong>计时器</strong>，这三个组件和我们在 <strong>P6</strong> 中搭建的 <strong>CPU</strong> 在同一级别。也就是这样的：</p><p><img src="/../picture/P7_mips.png"></p><h2 id="系统桥"><a href="#系统桥" class="headerlink" title="系统桥"></a>系统桥</h2><p>系统桥是 <strong>CPU</strong> 与外部组件进行通信的通道。我们的 <strong>CPU</strong> 与 <strong>DM</strong>、两个计时器、其他硬件之间的通信都需要经过系统桥进行。</p><p>在实现系统桥的过程中，主要有两个方向的信息流：<strong>CPU</strong> 到外部，以及外部到 <strong>CPU</strong>。</p><h3 id="CPU-到外部"><a href="#CPU-到外部" class="headerlink" title="CPU 到外部"></a><strong>CPU</strong> 到外部</h3><p>我们需要向外部传递的信息包括：</p><ul><li>读写的 <strong>DM</strong> 地址与使能信号。</li><li>读写的计时器地址与使能信号。</li><li>对于外部中断的响应信号。</li></ul><p>事实上这些信息的传播都是通过 <strong>store</strong> 类指令完成的。也就是说我们只将 <strong>P6</strong> 中 <strong>CPU</strong> 与 <strong>DM</strong> 通信的接口重新连接至系统桥内即可。</p><p>重点在于系统桥内部对于地址的选择。</p><p>对于常规读写 <strong>DM</strong>：不需要进行额外修改。</p><h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>需要判断 <strong>CPU</strong> 中给出的存储地址是否在两个计时器的地址范围内。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> timer1_sel = (m_data_addr_in &gt;= <span class="number">32&#x27;h7f00</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f0b</span>);</span><br><span class="line"><span class="keyword">wire</span> timer2_sel = (m_data_addr_in &gt;= <span class="number">32&#x27;h7f10</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f1b</span>);</span><br><span class="line"><span class="comment">// m_data_addr_in 是从CPU处拿到的存储地址信号</span></span><br></pre></td></tr></table></figure><p>若 <strong>store</strong> 的地址在这个范围内，说明我们要对计时器进行写入。将传给 <strong>timer</strong> 的信号进行相应的连接即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> timer1_WE = (&amp;m_data_byteen_in == <span class="number">1&#x27;b1</span>) &amp;&amp; (m_data_addr_in &gt;= <span class="number">32&#x27;h7f00</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f0b</span>);</span><br><span class="line"><span class="keyword">assign</span> timer2_WE = (&amp;m_data_byteen_in == <span class="number">1&#x27;b1</span>) &amp;&amp; (m_data_addr_in &gt;= <span class="number">32&#x27;h7f10</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f1b</span>);</span><br><span class="line"><span class="keyword">assign</span> timer1_addr = m_data_addr_in[<span class="number">31</span>:<span class="number">2</span>];</span><br><span class="line"><span class="keyword">assign</span> timer2_addr = m_data_addr_in[<span class="number">31</span>:<span class="number">2</span>];</span><br><span class="line"><span class="keyword">assign</span> timer1_Din = m_data_wdata_in;</span><br><span class="line"><span class="keyword">assign</span> timer2_Din = m_data_wdata_in;</span><br></pre></td></tr></table></figure><p>注：前两行代码中 <code>&amp;m_data_byteen_in == 1&#39;b1</code> 是因为对计时器写入必须按字写入。</p><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>课程组给出了中断响应时应写入的地址。注意，什么时候进行中断的响应是软件决定的事情，不需要硬件做决定。我们只需要在 <strong>写入 “中断响应对应的地址” 时将响应信号传出 CPU</strong> 即可。</p><p>在系统桥中的代码连接如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Int_sel = (m_data_addr_in &gt;= <span class="number">32&#x27;h7f20</span>) &amp;&amp; (m_data_addr_in &lt;= <span class="number">32&#x27;h7f23</span>) &amp;&amp; (|m_data_byteen_in == <span class="number">1&#x27;b1</span>);</span><br><span class="line"><span class="keyword">assign</span> m_int_addr = Int_sel == <span class="number">1&#x27;b1</span> ? m_data_addr_in : <span class="number">32&#x27;h0</span>;</span><br><span class="line"><span class="keyword">assign</span> m_int_byteen = Int_sel == <span class="number">1&#x27;b1</span> ? m_data_byteen_in : <span class="number">4&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="外部到-CPU"><a href="#外部到-CPU" class="headerlink" title="外部到 CPU"></a>外部到 <strong>CPU</strong></h3><p>外部至 <strong>CPU</strong> 的信号除了 <strong>load</strong> 类指令的相关信号外，还要增加 <strong>HWInt</strong> 信号来实现<strong>外部中断</strong>。</p><p>注意到 <strong>load</strong> 类指令可能从计时器中读取数据，因此我们在连接信号时要对来自计时器的信号做出相应的选择。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> m_data_rdata_out = timer1_sel == <span class="number">1&#x27;b1</span> ? timer1_Dout :</span><br><span class="line">  timer2_sel == <span class="number">1&#x27;b1</span> ? timer2_Dout :</span><br><span class="line">  m_data_rdata_in;</span><br></pre></td></tr></table></figure><p><strong>HWInt</strong> 共有六位，从低位开始依次是：<strong>timer1</strong> 的中断信号、<strong>timer2</strong> 的中断信号、外部中断信号与 <strong>3’b0</strong>。</p><p>即：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> HWInt = &#123;<span class="number">3&#x27;b0</span>, interrupt_in, timer2_IRQ, timer1_IRQ&#125;;</span><br></pre></td></tr></table></figure><p>其中 <strong>interrupt_in</strong> 是来自外部的中断信号。</p><h2 id="计时器-1"><a href="#计时器-1" class="headerlink" title="计时器"></a>计时器</h2><p>计时器这部分我们简单的阅读源码，理解后大致了解各个端口的连接方式即可。计时器的源码在教程中已经给出。</p><p>注意，由于教程未来可能会有版本更新，计时器的具体连接方式也可能有变化。笔者不保证我的连接方式一定是正确的。还请同学们依据实际情况自行定夺。</p><h1 id="宏观-PC"><a href="#宏观-PC" class="headerlink" title="宏观 PC"></a>宏观 <strong>PC</strong></h1><p>由于我们要封装流水线，即让流水线看上去像一个单周期 <strong>CPU</strong>，所以我们使用了宏观 <strong>PC</strong> 这一概念。宏观 <strong>PC</strong> 表达的是 <strong>CPU</strong> 当前正在运转哪一条指令。</p><p>宏观 <strong>PC</strong> 要和协处理器 <strong>CP0</strong> 处于同一流水级中。有关协处理器的设计后文详谈。依据实现方式的不同，<strong>CP0</strong> 放在 <strong>E</strong> 级和 <strong>M</strong> 级均可。一般而言放在 <strong>M</strong> 级的同学居多，所以我也放在了 <strong>M</strong> 级，以便于和同学（大佬）们进行对拍。所以我宏观 <strong>PC</strong> 也就是 <strong>PC_M</strong> 的值。</p><p>在异常发生时，我们要保证产生异常的那条指令不会对 <strong>CPU</strong> 的状态造成影响。并将发生异常的指令作为 <strong>受害指令</strong> 存入协处理器的 <strong>EPC</strong> 中。这部分之后再详谈。</p><h1 id="侦测异常"><a href="#侦测异常" class="headerlink" title="侦测异常"></a>侦测异常</h1><p>在 <strong>P7</strong> 中，最重要的任务是侦测程序运行过程中产生的 <strong>异常</strong>。</p><p>我们首先要侦测异常，然后根据异常的种类生成相应的 <strong>Exccode</strong> 码，并将 <strong>Exccode</strong> 码存入协处理器 <strong>CP0</strong> 中。</p><h2 id="异常的种类"><a href="#异常的种类" class="headerlink" title="异常的种类"></a>异常的种类</h2><p>我们要实现的异常分为以下几类：</p><ul><li><strong>AdEL</strong>（<strong>Exccode</strong> 码为 <strong>5’d4</strong>）<ul><li>取 <strong>pc</strong> 的值时地址不对齐。</li><li><strong>lw</strong> 未字对齐与 <strong>lh</strong> 未半字对齐。</li><li>尝试使用 <strong>lh</strong> 和 <strong>lb</strong> 取 <strong>timer</strong> 的寄存器中的值。</li><li>计算取数地址的过程中出现加法溢出情况。</li><li>取数地址不在允许的范围中。</li></ul></li><li><strong>AdES</strong>（<strong>Exccode</strong> 码为 <strong>5’d5</strong>）<ul><li><strong>sw</strong> 未字对齐与 <strong>lh</strong> 未半字对齐。</li><li>尝试使用 <strong>sh</strong> 和 <strong>sb</strong> 向 <strong>timer</strong> 的寄存器中存值，或尝试向 <strong>timer</strong> 中的 <strong>Count</strong> 寄存器存值。</li><li>计算存数地址的过程中出现加法溢出情况。</li><li>存数地址不在允许的范围中。</li></ul></li><li><strong>Syscall</strong>（<strong>Exccode</strong> 码为 5’d8）<ul><li>由指令 <strong>syscall</strong> 产生的系统调用异常。</li></ul></li><li><strong>RI</strong>（<strong>Exccode</strong> 码为 <strong>5’d10</strong>）<ul><li>未知的指令码。</li></ul></li><li><strong>Ov</strong>（<strong>Exccode</strong> 码为 <strong>5’d12</strong>）<ul><li>加减指令的计算过程中出现溢出情况。</li></ul></li></ul><h2 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h2><p>笔者使用 <strong>OverFlow</strong> 指示溢出的产生。对溢出的判读需要在 <strong>E</strong> 级的 <strong>ALU</strong> 中进行。其具体过程在指令集中已有说明。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">32</span>:<span class="number">0</span>]tempAdd = &#123;A[<span class="number">31</span>], A&#125; + &#123;B[<span class="number">31</span>], B&#125;;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">32</span>:<span class="number">0</span>]tempSub = &#123;A[<span class="number">31</span>], A&#125; - &#123;B[<span class="number">31</span>], B&#125;;</span><br><span class="line"><span class="keyword">assign</span> OverFlowE = (ALUOp == <span class="number">4&#x27;b0000</span> &amp;&amp; tempAdd[<span class="number">32</span>] ^ tempAdd[<span class="number">31</span>] == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> :</span><br><span class="line">                   (ALUOp == <span class="number">4&#x27;b0001</span> &amp;&amp; tempSub[<span class="number">32</span>] ^ tempSub[<span class="number">31</span>] == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><p>其中 <strong>ALUOp</strong> 是我的实现方式中添加的信号。这个信号指示 <strong>ALU</strong> 要进行哪种运算。<strong>ALUOp</strong> 为 <strong>4’b0000</strong> 代表当前进行加法运算；<strong>ALUOp</strong> 为 <strong>4’b0001</strong> 代表当前进行减法运算。</p><p><strong>A</strong> 和 <strong>B</strong> 分别是传入 <strong>ALU</strong> 的两个操作数。</p><p><strong>OverFlow</strong> 在 <strong>E</strong> 级产生，需要流水到 <strong>M</strong> 级才能判断具体出现了哪种异常。</p><h2 id="Exccode-信号的产生"><a href="#Exccode-信号的产生" class="headerlink" title="Exccode 信号的产生"></a><strong>Exccode</strong> 信号的产生</h2><p>我们可以创建一个模块来产生 <strong>Exccode</strong> 信号。这里我将其称为 <strong>ExccodeOccur</strong>。此模块最好和协处理器位于同一流水级。（设置在 <strong>M</strong> 级中）</p><p>在清楚了各个异常产生的条件后，依次产生各个异常即可。</p><h3 id="AdEL"><a href="#AdEL" class="headerlink" title="AdEL"></a><strong>AdEL</strong></h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> AdEL = pcErrorM == <span class="number">1&#x27;b1</span> ? <span class="number">1&#x27;b1</span> : <span class="comment">//pcError</span></span><br><span class="line">(Lw == <span class="number">1&#x27;b1</span> &amp;&amp; (ALUAnsM[<span class="number">0</span>] | ALUAnsM[<span class="number">1</span>])) ? <span class="number">1&#x27;b1</span> : <span class="comment">//lw未字对齐</span></span><br><span class="line">(Lh == <span class="number">1&#x27;b1</span> &amp;&amp; ALUAnsM[<span class="number">0</span>]) ? <span class="number">1&#x27;b1</span> : <span class="comment">//lh未半字对齐</span></span><br><span class="line">((Lh | Lb) &amp;&amp; (ALUAnsM &gt;= <span class="number">32&#x27;h00007f00</span> &amp;&amp; ALUAnsM &lt;= <span class="number">32&#x27;h00007f1b</span>)) ? <span class="number">1&#x27;b1</span> : <span class="comment">//取Timer寄存器的值</span></span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; OverFlowM == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> :<span class="comment">//计算地址时加法溢出</span></span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f23</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f0b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f10</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f1b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f20</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">((Lw | Lh | Lb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00002fff</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f00</span>)) ? <span class="number">1&#x27;b1</span> :<span class="number">1&#x27;b0</span>; <span class="comment">//取数地址超出上限</span></span><br><span class="line"><span class="comment">// 注：其实可以简化但是因为写完后感觉工工整整的看上去很帅气所以就没有改</span></span><br></pre></td></tr></table></figure><h3 id="AdES"><a href="#AdES" class="headerlink" title="AdES"></a><strong>AdES</strong></h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> AdES = (Sw == <span class="number">1&#x27;b1</span> &amp;&amp; (ALUAnsM[<span class="number">0</span>] | ALUAnsM[<span class="number">1</span>])) ? <span class="number">1&#x27;b1</span> :<span class="comment">//sw未字对齐</span></span><br><span class="line">            (Sh == <span class="number">1&#x27;b1</span> &amp;&amp; ALUAnsM[<span class="number">0</span>]) ? <span class="number">1&#x27;b1</span> :<span class="comment">//sh未半字对齐</span></span><br><span class="line">            ((Sh | Sb) &amp;&amp; (ALUAnsM &gt;= <span class="number">32&#x27;h00007f00</span> &amp;&amp; ALUAnsM &lt;= <span class="number">32&#x27;h00007f1b</span>)) ? <span class="number">1&#x27;b1</span> :<span class="comment">//存Timer寄存器的值</span></span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; OverFlowM == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> :<span class="comment">//计算地址时加法溢出</span></span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM == <span class="number">32&#x27;h00007f08</span> || ALUAnsM == <span class="number">32&#x27;h00007f18</span>)) ? <span class="number">1&#x27;b1</span> :<span class="comment">//向计时器的Count存值</span></span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f23</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f0b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f10</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00007f1b</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f20</span>)) ? <span class="number">1&#x27;b1</span> : </span><br><span class="line">            ((Sw | Sh | Sb) &amp;&amp; (ALUAnsM &gt; <span class="number">32&#x27;h00002fff</span> &amp;&amp; ALUAnsM &lt; <span class="number">32&#x27;h00007f00</span>)) ? <span class="number">1&#x27;b1</span> :<span class="number">1&#x27;b0</span>;<span class="comment">//存数地址超出上限</span></span><br></pre></td></tr></table></figure><h3 id="Syscall"><a href="#Syscall" class="headerlink" title="Syscall"></a><strong>Syscall</strong></h3><p>直接识别指令是否是 <strong>syscall</strong> 就行。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Syscall = (func == <span class="number">6&#x27;b001100</span> &amp;&amp; R_R == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="RI"><a href="#RI" class="headerlink" title="RI"></a><strong>RI</strong></h3><p><strong>RI</strong> 信号在 <strong>Controller</strong> 中产生，然后流水到 <strong>ExccodeOccur</strong> 所在的流水级，参与 <strong>Exccode</strong> 的生成。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Controller中产生，也就是在D级产生。</span></span><br><span class="line"><span class="keyword">assign</span> RID = ~(Beq | Bgez| Bne | Addi| Andi| Ori | Lui | J   | </span><br><span class="line">               Jal | Sb  | Sh  | Sw  | Lb  | Lh  | Lw  | Add | </span><br><span class="line">               Sub | And | Or  | Sll | Srl | Jr  | Slt | Sltu| </span><br><span class="line">               Mult|Multu| Div | Divu| Mfhi| Mflo| Mthi| Mtlo| </span><br><span class="line">            Syscall| Mfc0| Mtc0| Eret);</span><br></pre></td></tr></table></figure><h3 id="Ov"><a href="#Ov" class="headerlink" title="Ov"></a><strong>Ov</strong></h3><p>注意是由加减法运算指令导致的溢出才会产生 <strong>Ov</strong> 信号。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Ov = ((Add | Addi | Sub) &amp;&amp; OverFlowM == <span class="number">1&#x27;b1</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="Exccode"><a href="#Exccode" class="headerlink" title="Exccode"></a><strong>Exccode</strong></h3><p>在得到所需的各个信号后，进行判断、生成即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> ExcCodeM = AdEL == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d4</span> :</span><br><span class="line">                  AdES == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d5</span> :</span><br><span class="line">                  Syscall == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d8</span> :</span><br><span class="line">                  RIM  == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d10</span> :</span><br><span class="line">                  Ov   == <span class="number">1&#x27;b1</span> ? <span class="number">5&#x27;d12</span> : <span class="number">5&#x27;d0</span>;</span><br></pre></td></tr></table></figure><h1 id="协处理器-CP0-设计"><a href="#协处理器-CP0-设计" class="headerlink" title="协处理器 CP0 设计"></a>协处理器 <strong>CP0</strong> 设计</h1><p><strong>CP0</strong> 的设计是整个 <strong>P7</strong> 的关键所在。这里特别感谢 <strong>roief</strong> 佬及其博客。<strong>roief</strong> 的博客指路：<a href="https://roife.github.io/2021/01/02/buaa-co-lab-p7/">P7 MIPS 微体系</a></p><h2 id="CP0-的端口"><a href="#CP0-的端口" class="headerlink" title="CP0 的端口"></a><strong>CP0</strong> 的端口</h2><p>我个人的 <strong>CP0</strong> 端口完全按照教程所推荐的设计。即：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">moudle CP0(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> en,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] CP0Add,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] CP0In,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] CP0Out,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] VPC,</span><br><span class="line">    <span class="keyword">input</span> BDIn,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] ExcCodeIn,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">5</span>:<span class="number">0</span>] HWInt,</span><br><span class="line">    <span class="keyword">input</span> EXLClr,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] EPCOut,</span><br><span class="line">    <span class="keyword">output</span> Req</span><br><span class="line">    );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于各个输入端口的粗略解释：</p><p><strong>CP0Add</strong> 和 <strong>CP0In</strong> 都是在实现 <strong>mtc0</strong> 和 <strong>mfc0</strong> 中要用到的。<strong>VPC</strong> 是受害指令的宏观 <strong>PC</strong>，此处即为 <strong>M</strong> 级 <strong>PC</strong>。</p><p><strong>ExccodeIn</strong> 是我们在 <strong>ExccodeOccur</strong> 中产生的 <strong>Exccode</strong>。<strong>HWInt</strong> 是我们在系统桥中产生并传入 <strong>CPU</strong> 的，传入 <strong>CPU</strong> 后直接连接到 <strong>CP0</strong> 的端口上。</p><p><strong>EXLClr</strong> 由指令 <strong>eret</strong> 产生。</p><p><strong>BDIn</strong> 指示当前指令是不是延迟槽内部指令，这与 <strong>EPC</strong> 的产生有关。</p><h2 id="CP0-中寄存器的实现"><a href="#CP0-中寄存器的实现" class="headerlink" title="CP0 中寄存器的实现"></a><strong>CP0</strong> 中寄存器的实现</h2><p>在 <strong>CP0</strong> 中我们要实现三个寄存器：<strong>SR</strong>、<strong>Cause</strong>、<strong>EPC</strong>。</p><p>为了便于 <strong>mtc0</strong> 和 <strong>mfc0</strong> 的实现以及不知道这两个指令会不会存取我们尚未实现的寄存器，我的 <strong>CP0</strong> 设计中添加了一个寄存器堆：<code>reg [31:0]CP[0:31];</code>，并添加以下宏定义便于代码编写（注：下文的代码使用到的宏定义均位于此处）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> SR CP[12]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> Cause CP[13]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> EPC CP[14]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> IE CP[12][0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> EXL CP[12][1]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> IM CP[12][15:10]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> BD CP[13][31]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> IP CP[13][15:10]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> ExcCode CP[13][6:2]</span></span><br></pre></td></tr></table></figure><p>各个域的功能：</p><ul><li><strong>IE</strong>：是否允许中断。</li><li><strong>EXL</strong>：是否处于核心态（异常中断处理程序中）。</li><li><strong>IM</strong>：六个位分别指示是否允许发生对应的中断。</li><li><strong>BD</strong>：是否是延迟槽中指令</li><li><strong>IP</strong>：每周期更新，记录 <strong>HWInt</strong> 的值。</li><li><strong>ExcCode</strong>：发生异常时更新，记录异常码。</li></ul><p>事后得知貌似是不会存取我们没有实现的寄存器的……不过这么写实现 <strong>mtc0</strong> 和 <strong>mfc0</strong> 都很方便，所以也是有其优点的。实际上协处理器 <strong>CP0</strong> 中就是包含有 <strong>32</strong> 个寄存器，因此这样实现可以说是毫无毛病（乐）。</p><h2 id="BD-的产生"><a href="#BD-的产生" class="headerlink" title="BD 的产生"></a><strong>BD</strong> 的产生</h2><p><strong>BD</strong> 这个信号是在外部产生并传入 <strong>CP0</strong> 中，指示当前指令是否处于延迟槽内。这里有一处要注意的地方是：在产生 <strong>BD</strong> 时，不管跳转指令是否跳转，都要将其视为处于延迟槽内。</p><p>我在 <strong>F</strong> 级产生这一信号，从而满足 <strong>BD</strong> 的产生晚于跳转指令一周期的条件。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> BDF = JalD | JrD | BeqD | BneD | <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h2 id="CP0Out-和-EPCOut"><a href="#CP0Out-和-EPCOut" class="headerlink" title="CP0Out 和 EPCOut"></a><strong>CP0Out</strong> 和 <strong>EPCOut</strong></h2><p>很方便的，我的 <strong>CP0Out</strong> 的产生方式为：<code>assign CP0Out = CP[CP0Add];</code>，一行搞定。</p><p>相应的，<strong>EPCOut</strong> 的产生方式为：<code>assign EPCOut = `EPC;</code>。</p><h2 id="EPC-的产生"><a href="#EPC-的产生" class="headerlink" title="EPC 的产生"></a><strong>EPC</strong> 的产生</h2><p>对于 <strong>EPC</strong> 的产生，要注意：如果指令是延迟槽指令（即 <code>BDIn == 1&#39;b1</code>），那么我们记录的 <strong>EPC</strong> 应当是其所属的跳转指令（即受害指令的上一条指令，<code>VPC - 32&#39;d4</code>）。</p><h2 id="Req-的产生"><a href="#Req-的产生" class="headerlink" title="Req 的产生"></a><strong>Req</strong> 的产生</h2><p>注：这部分参照了 <strong>roief</strong> 佬的写法。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> IntReq = (|(HWInt &amp; `IM)) &amp; !`EXL &amp; `IE; <span class="comment">// 允许当前中断 且 不在中断异常中 且 允许中断发生</span></span><br><span class="line"><span class="keyword">wire</span> ExcReq = (|ExcCodeIn) &amp; !`EXL; <span class="comment">// 存在异常 且 不在中断中</span></span><br><span class="line"><span class="keyword">assign</span> Req  = IntReq | ExcReq;</span><br></pre></td></tr></table></figure><p><strong>Req</strong> 的产生就意味着我们要进入异常处理程序了。除了要在 <strong>CP0</strong> 中做出改变外，我们还需要在 <strong>CPU</strong> 中做出相应的操作。下文再说。</p><h2 id="CP0-的时序逻辑"><a href="#CP0-的时序逻辑" class="headerlink" title="CP0 的时序逻辑"></a><strong>CP0</strong> 的时序逻辑</h2><p>遵循设计即可。</p><p>结合注释观看效果更佳。</p><p>这里提一个要注意的点：当中断和异常同时发生时，要优先响应中断，即向 <strong>&#96;ExcCode</strong> 存入的值应当是象征中断的 <strong>0</strong>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            CP[i] = <span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(en == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span> <span class="comment">// 使能信号为真时将数据写入对应的寄存器</span></span><br><span class="line">            CP[CP0Add] = CP0In;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(Req == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span> <span class="comment">// 当异常或中断发生时</span></span><br><span class="line">            `EXL &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            `ExcCode &lt;= IntReq == <span class="number">1&#x27;b1</span> ? <span class="number">0</span> : ExcCodeIn; <span class="comment">// 中断的优先级高于异常</span></span><br><span class="line">            `EPC &lt;= BDIn == <span class="number">1&#x27;b1</span> ? VPC - <span class="number">32&#x27;d4</span> : VPC; <span class="comment">// 结合BDIn生成EPC</span></span><br><span class="line">            `BD &lt;= BDIn;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(EXLClr == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">            `EXL &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>((en == <span class="number">1&#x27;b1</span> &amp;&amp; CP0Add == <span class="number">13</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 这里是为了防止mtc0的目标寄存器是Cause时会对IP域写入两次</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            `IP &lt;= HWInt; <span class="comment">//每周期更新IP的值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="REQ-发生时"><a href="#REQ-发生时" class="headerlink" title="REQ 发生时"></a><strong>REQ</strong> 发生时</h1><p>当 <strong>CP0</strong> 中的 <strong>Req</strong> 信号处于高位，即我们要进入异常处理程序时，我们要对流水线进行以下处理：</p><ul><li>清空 <strong>D, E, M, W</strong> 级流水线寄存器。实现上可以直接将 <strong>Req</strong> 信号接入 <strong>reset</strong> 中。</li><li>将 <strong>PC</strong> 的值强制修改到异常处理程序的入口：<code>32&#39;h00004180</code>。</li><li>保证异常发生时不会对 <strong>DM</strong> 等外部模块产生写信号（即 <code>m_data_byteen == 4&#39;h0</code>）。</li><li>正处于 <strong>E</strong> 级的指令不应修改乘除模块。</li></ul><h1 id="指令拓展"><a href="#指令拓展" class="headerlink" title="指令拓展"></a>指令拓展</h1><p>在 <strong>P7</strong> 中，我们要拓展以下几个指令：<code>syscall, mfc0, mtc0, eret</code></p><p>其中 <strong>syscall</strong> 没什么好说的，产生相应的异常码就行。</p><p><strong>mfc0</strong> 和 <strong>mtc0</strong> 的实现有些类似于 <strong>mfhi</strong>，<strong>mthi</strong> 。根据指令集进行拓展即可。此外根据个人实现的不同可能需要处理和 <strong>mfc0</strong> 与 <strong>mtc0</strong> 相关的转发（增加 <strong>W</strong> 级到 <strong>M</strong> 级的通路等），还请注意。</p><p><strong>eret</strong> 要修改 <strong>PC</strong> 的值，返回 <strong>EPC</strong> 处继续执行指令。此处要有一个数据冲突问题需要注意：</p><p>当 <strong>mfc0</strong> 要修改 <strong>CP0</strong> 中的 <strong>14</strong> 号寄存器（即 <strong>&#96;EPC</strong>），且后面跟着 <strong>eret</strong> 时，要进行相应的阻塞。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> stall_eret = EretD &amp; ((Mtc0E &amp; (instrE[<span class="number">15</span>:<span class="number">11</span>] == <span class="number">5&#x27;d14</span>)) | (Mtc0M &amp; (instrM[<span class="number">15</span>:<span class="number">11</span>] == <span class="number">5&#x27;d14</span>)));</span><br></pre></td></tr></table></figure><p>此外，当 <strong>eret</strong> 流水至 <strong>M</strong> 级时要将 <strong>CP0</strong> 中的 <strong>&#96;EXL</strong> 置 <strong>0</strong>。</p><h1 id="修改-PC-的信号优先级"><a href="#修改-PC-的信号优先级" class="headerlink" title="修改 PC 的信号优先级"></a>修改 <strong>PC</strong> 的信号优先级</h1><p>优先级为：<strong>reset &gt; REQ &gt; eret &gt; 其他</strong></p><p>自行体悟一下即可，不作过多解释。</p><h1 id="阻塞时中断产生的问题"><a href="#阻塞时中断产生的问题" class="headerlink" title="阻塞时中断产生的问题"></a>阻塞时中断产生的问题</h1><p>在 <strong>P6</strong> 的 <strong>CPU</strong> 中，当我们阻塞时插入 <strong>nop</strong>，<strong>nop</strong> 对应的 <strong>pc</strong> 值一般是 <strong>0</strong>。这个设计在 <strong>P7</strong> 中会招致问题：当处于阻塞时外部产生了中断信号，我们记录的 <strong>EPC</strong> 将会是 <strong>0</strong>。这会导致错误的产生。</p><p>正确的处理方法，是在阻塞时让 <strong>pc</strong> 和 <strong>BD</strong> 这两个信号依旧正常流水。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P7</strong> 的工程量还是很大的。往年 <strong>P7</strong> 也被称为是最玄学的一 <strong>P</strong>。今年我在搭建时据说教程大更新，因此实际上并没有感觉有那么的 “玄学”。计组课程在不断地改进啊（喜）。</p><p>今年因为 <strong>P8</strong> 和烤漆完全撞上的缘故（考完概统的当天晚上进行 <strong>P8</strong> 上机），为了复习期末，不得已放弃了做 <strong>P8</strong> 的想法，不得不说是一个计组学习中的遗憾。</p><p>计组回忆的这一系列到这就结束了。虽然过程艰辛又曲折，但是回顾已有的成果，还是会有一种 “我都已经做出来这么多东西了啊！” 的感叹。</p><p>不知读者在学习计组的过程中是否体会到了乐趣呢？</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P6 回顾</title>
      <link href="/2023/01/05/BUAA-CO-P6/"/>
      <url>/2023/01/05/BUAA-CO-P6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是 <strong>bluebean</strong> 的 <strong>P6</strong> 回忆录。</p><p>我认为 <strong>P6</strong> 的难度较 <strong>P5</strong> 降低了许多，因为在 <strong>P6</strong> 只需要在 <strong>P5</strong> 的流水线基础上进行增量开发即可。当然，若 <strong>P5</strong> 的架构不完善的话，在 <strong>P6</strong> 可能将要坐大牢。</p><p>按照课程组（<strong>2021</strong> 版，以后可能会有变化）的要求，在 <strong>P6</strong> 中主要需要完成一下任务：</p><ul><li><strong>IM</strong> 和 <strong>DM</strong> 的外置。</li><li>在 <strong>P5</strong> 的基础上对指令集进行增量拓展。</li><li>添加乘除法模块，实现和乘除法相关的指令。</li></ul><h1 id="外置-IM-与-DM-模块"><a href="#外置-IM-与-DM-模块" class="headerlink" title="外置 IM 与 DM 模块"></a>外置 <strong>IM</strong> 与 <strong>DM</strong> 模块</h1><p>在 <strong>P6</strong> 中，我们的 <strong>IM</strong> 与 <strong>DM</strong> 模块需要外置，外置的模块在课程组提供的 <strong>test bench</strong> 中。在 <strong>CPU</strong> 中需要提供相应的与 <strong>IM</strong> 和 <strong>DM</strong> 通信的端口。</p><p>与 <strong>IM</strong> 的通信没什么好说的，直接把原来 <strong>IM</strong> 的接口接出去就行。</p><p>课程组的 <strong>DM</strong> 模块采用了字节使能方法来支持按字节读写的功能。这部分可以阅读课程组的代码后自行思考相应的实现方式。</p><p>我在实现过程中，产生了一个新的信号 <strong>MemWrite</strong> 用于指示读写哪些字节。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]MemWriteD = Sw == <span class="number">1&#x27;b1</span> ? <span class="number">4&#x27;b1111</span> :</span><br><span class="line">                    Sh == <span class="number">1&#x27;b1</span> ? <span class="number">4&#x27;b0011</span> :</span><br><span class="line">                    Sb == <span class="number">1&#x27;b1</span> ? <span class="number">4&#x27;b0001</span> : <span class="number">4&#x27;b0000</span>;</span><br></pre></td></tr></table></figure><p>在连接 <strong>DM</strong> 的信号时，采用了如下方式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> m_data_wdata  = AD1M &lt;&lt; &#123;ALUAnsM[<span class="number">1</span>:<span class="number">0</span>], <span class="number">3&#x27;b000</span>&#125;;</span><br><span class="line"><span class="keyword">assign</span> m_data_byteen = MemWriteM &lt;&lt; ALUAnsM[<span class="number">1</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>其中 <strong>ALUAnsM</strong> 是 <strong>ALU</strong> 的计算结果（<strong>M</strong> 级），存储着要写入的地址信息。</p><p>另外在 <strong>DM</strong> 读出的数据要进行相应的数据扩展。这里写一个 <strong>DM_EXT</strong> 模块判断一下对应的指令再进行相应的符号扩展就可以了。</p><h1 id="指令集拓展"><a href="#指令集拓展" class="headerlink" title="指令集拓展"></a>指令集拓展</h1><p>在 <strong>P6</strong> 中一项重要的工作就是进行指令集拓展。在一个良好的 <strong>P5</strong> 基础上进行拓展并不是难事。</p><p>建议每拓展一个指令就进行相应的功能测试。不求数据点多强，至少基本的功能测试要做好。</p><p>例如在拓展了 <strong>bne</strong> 指令后，进行简单的功能测试：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ori </span>$<span class="number">1</span> <span class="number">0xf0</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">2</span> <span class="number">0xf0</span></span><br><span class="line"><span class="keyword">bne </span>$<span class="number">1</span> $<span class="number">2</span> end</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">lui </span>$<span class="number">1</span> <span class="number">0xff</span> <span class="comment"># run this</span></span><br><span class="line"><span class="keyword">bne </span>$<span class="number">1</span> $<span class="number">2</span> end</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span> <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lui </span>$<span class="number">1</span> <span class="number">0xee</span> <span class="comment"># not run this</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="number">5</span> <span class="number">0xcc</span></span><br></pre></td></tr></table></figure><p>建议同学们在课下针对每一个指令都做好测试，减少后期 <strong>dbug</strong> 难度。</p><h1 id="乘除模块"><a href="#乘除模块" class="headerlink" title="乘除模块"></a>乘除模块</h1><p>关于乘除指令，我们要拓展的有 <code>mult, multu, div, divu, mfhi, mflo, mthi, mtlo</code>。</p><p>我们要模拟出 <code>hi, lo</code> 这两个寄存器。</p><p>在写乘法时可以采用写法：<code>&#123;HiTem, LoTem&#125; = $signed(A) * $signed(B);</code>。这里 <strong>HiTem</strong> 和 <strong>LoTem</strong> 是用来暂时存储计算的值，当模拟乘除延迟结束时将结果存入 <strong>hi, lo</strong> 寄存器。</p><p>此外要注意和乘除法指令相关的阻塞。当乘除模块正在运行时，遇到新的乘除指令是要阻塞流水线的。这里存在一定的优化空间，比如两条连续的乘法指令，我们就可以忽略掉前一条乘法指令，因为后一条指令会重新写 <strong>hi, lo</strong> 寄存器。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p>上机一般是两道简单题 <strong>+</strong> 一道难题。可能会涉及改动乘除模块。建议也是提前把课上可能用到的接口留出来。此外上机前可以提前想好添加一个功能时可能要改动哪些相应的信号。</p><p>这里给出一个我在上机时遇到的一个困难指令：<strong>shl</strong></p><p><strong>shl</strong> 的功能是交换乘除法模块中 <strong>hi</strong> 寄存器和 <strong>lo</strong> 寄存器中的值。乍看上去很简单，但是这里存在坑点。比如在乘除法之后紧跟一串 <strong>shl</strong> 指令，最优情况是不进行阻塞。</p><p>标准思路：交换两个寄存器的值，等价于交换两个寄存器的名字。使用一个 <strong>tag</strong> 标记，当 <strong>tag</strong> 为 <strong>1</strong> 时，<strong>hi</strong> 作为 <strong>lo</strong> 寄存器，<strong>lo</strong> 作为 <strong>hi</strong> 寄存器；<strong>tag</strong> 为 <strong>0</strong> ，情况照常。</p><p>这个题实际上是可难可易……如果不卡时间的话（允许乘除法后遇到 <strong>shl</strong> 时阻塞），本题毫无难度，否则难度暴增。（主要是没有考虑到这样阴间的阻塞情况。我在考前一直以为在乘除法后紧跟的是 <strong>mflo</strong> 或 <strong>mfhi</strong>，直到舍友告诉我那是“在乘除法<strong>结束</strong>后紧跟 <strong>mfhi</strong> 或 <strong>mflo</strong>”）</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P6</strong> 的工作基本上只有这些内容了。说实话我感觉 <strong>P5</strong> 做的更艰难一点（毕竟是从头开始搭流水线）。</p><p>有能力的同学也可以在课下空余时间拓展更多指令。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件信息流追踪与 RTL 代码安全性分析综述</title>
      <link href="/2023/01/04/RTL-security-IFT/"/>
      <url>/2023/01/04/RTL-security-IFT/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li><p>计算机安全的<strong>核心原则</strong> &#x3D; 维护所计算信息的<strong>保密性</strong> +  维护所计算信息的<strong>完整性</strong></p><p>保密性 &#x3D; 信息只开放给授权用户</p><p>完整性 &#x3D; 维护信息的准确性 + 一致性</p></li><li><p>信息流跟踪（<strong>IFT</strong>）是一种模拟系统计算时信息传播方式的安全技术。</p><p>特点：拥有一些 <strong>tag</strong> 来表示安全类别，且这些 <strong>tag</strong> 可以更新。</p></li><li><p>本次调研主要介绍<strong>硬件 IFT 分类方法</strong>，用于调查、分类、比较不同的硬件 <strong>IFT</strong> 技术。</p></li></ul><h1 id="Information-Flow"><a href="#Information-Flow" class="headerlink" title="Information Flow"></a>Information Flow</h1><ul><li><strong>IFT</strong> 技术的工作原理 &#x3D; 用安全类别标记存储对象，并在计算数据时跟踪这些标签</li></ul><h4 id="Storage-Objects-and-Processes"><a href="#Storage-Objects-and-Processes" class="headerlink" title="Storage Objects and Processes"></a>Storage Objects and Processes</h4><ul><li><p>存储对象是信息的容器，进程描述了对这些对象执行的计算。存储对象和进程因安全策略和抽象级别而异。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f38dbe43e0d30e814b86.png" alt="image-20230104101318676"></p><p><em>附：上图为安全语言结构示例。</em></p></li></ul><h4 id="Security-Classes-and-Flow-Relations"><a href="#Security-Classes-and-Flow-Relations" class="headerlink" title="Security Classes and Flow Relations"></a>Security Classes and Flow Relations</h4><ul><li>信息流策略定义了数据对象之间允许的关系。为此，<strong>IFT</strong> 将每个对象与一个安全类别相关联，即给对象一个安全标签或安全标记。</li><li>在实际中，大多数策略使用<img src="https://pic.imgdb.cn/item/63b4f38dbe43e0d30e814ba1.png" alt="image-20230104101707494" style="zoom: 50%;" /> 两元素网络，允许将保密性和完整性相关的安全属性建模为<img src="https://pic.imgdb.cn/item/63b4f40abe43e0d30e81f033.png" alt="image-20230104101833762" style="zoom:67%;" /></li></ul><h4 id="Noninterference"><a href="#Noninterference" class="headerlink" title="Noninterference"></a>Noninterference</h4><ul><li><p>Noninterference 通过将所有系统输入、输出和状态建模为 <strong>high</strong> 或 <strong>low</strong> 来创建信息流模型，指出 <strong>high</strong> 的任何变化不应该导致 <strong>low</strong> 的输出变化。一个主要的挑战是硬件中的对象数量通常比软件中的多得多。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f409be43e0d30e81ef4d.png" alt="image-20230104102613227"></p><p><em>附：上图是 explicit flow 的一个简单示例。</em></p></li></ul><h4 id="Types-of-Information-Flow-Relations"><a href="#Types-of-Information-Flow-Relations" class="headerlink" title="Types of Information Flow Relations"></a>Types of Information Flow Relations</h4><ul><li><p>虽然流关系提供了一种方式来指定与是否允许信息在对象之间传输相关的安全策略，但是它们没有严格定义确定是否存在信息流的方法。 信息可以通过许多不同的方式传播。 理解不同类型的信息流关系以及它们如何在硬件中表现出来，是精确测量所有信息流并进一步严格执行安全策略的重要的第一步。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f409be43e0d30e81ef6d.png" alt="image-20230104102742921"></p><p><em>附：上图是 implicit flow 的一个简单示例。</em></p></li></ul><h4 id="Covert-and-Side-Channels"><a href="#Covert-and-Side-Channels" class="headerlink" title="Covert and Side Channels"></a>Covert and Side Channels</h4><ul><li><p><strong>Covert Channel</strong> 是使用非预期来源的信息传输。</p><p>Covert Channels &#x3D; storage channel + timing channel</p></li><li><p><strong>Side Channel</strong> 是通过非功能(通常是物理)特征(例如，执行时间、功耗、电磁辐射和声发射)的信息泄漏。</p></li></ul><h1 id="Operator-Precision"><a href="#Operator-Precision" class="headerlink" title="Operator Precision"></a>Operator Precision</h1><h4 id="Precision-of-IFT"><a href="#Precision-of-IFT" class="headerlink" title="Precision of IFT"></a>Precision of IFT</h4><ul><li><strong>IFT</strong> 技术的精度反映了它准确测量硬件设计中所有现有信息流的能力。精确的 <strong>IFT</strong> 技术将精确地模拟硬件设计的信息流行为，而不精确的技术可能指示不存在的信息流，即假阳性（<strong>false positives</strong>），或者错过实际的信息流，即假阴性（<strong>false negatives</strong>）。</li></ul><h4 id="Imprecise-IFT"><a href="#Imprecise-IFT" class="headerlink" title="Imprecise IFT"></a>Imprecise IFT</h4><ul><li>虽然不精确的 <strong>IFT</strong> 技术可能会导致保守的验证结果，但它们通常可以快速分析潜在的信息流安全漏洞， 这对于识别在罕见情况下发生的安全违规非常有用。</li></ul><h4 id="Precise-IFT"><a href="#Precise-IFT" class="headerlink" title="Precise IFT"></a>Precise IFT</h4><ul><li><p>精确 <strong>IFT</strong> 技术在确定流量关系时考虑了硬件组件的功能和输入值， 该标签传播策略可以被形式化为输入及其标签的函数。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f40abe43e0d30e81efba.png" alt="image-20230104104019463"></p><p><em>附：上图表示 flow relation 和 class combining operation的示例，显示了考虑和不考虑数据值的class combining operation的差异。</em></p><ul><li>（a）是与门；</li><li>（b）是不考虑数据值的 <strong>flow relation</strong> 和 <strong>class combining operation</strong>；</li><li>（c）是考虑数据值的 <strong>flow relation</strong> 和 <strong>class combining operation</strong>。</li></ul></li></ul><h4 id="Precision-and-Complexity-Tradeoffs"><a href="#Precision-and-Complexity-Tradeoffs" class="headerlink" title="Precision and Complexity Tradeoffs"></a>Precision and Complexity Tradeoffs</h4><ul><li><p>精确度和复杂性是评估硬件 <strong>IFT</strong> 技术的两个相互矛盾的因素，需要在两者之间进行权衡。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f40abe43e0d30e81f005.png" alt="image-20230104104755791"></p><p><em>附：上图为与门推导简化的硬件 IFT 逻辑，展现了一种有效的方法来推导不同版本的具有可变精度和复杂度的布尔门硬件IFT逻辑，通过逐渐忽略输入，来放松精确度。</em></p></li></ul><h1 id="Security-Properties"><a href="#Security-Properties" class="headerlink" title="Security Properties"></a>Security Properties</h1><ul><li><p>信息流属性被表示为对象上的 <strong>flow relations</strong>。 属性指定存储在硬件对象中的信息能否流向其他对象。</p><p><strong>IFT</strong> 属性是超属性（<strong>hyperproperties</strong>）的例子，因为它们表达了需要跨多个轨迹验证的预期行为。</p></li><li><p>硬件 <strong>IFT</strong> 工具使用存储安全相关信息的标签来模拟信息在硬件中的移动。标签指示对象是可信的还是不可信的，机密的还是公开的，是否包含时间变化等等。属性定义标签的初始条件，以及标签在执行过程中是否可以更改。</p></li></ul><h4 id="Confidentiality"><a href="#Confidentiality" class="headerlink" title="Confidentiality"></a>Confidentiality</h4><ul><li><p>保密性属性确保任何与敏感对象(标记为 <strong>high</strong>)相关的信息永远不会流向未分类的对象(标记为 <strong>low</strong>)。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f455be43e0d30e825002.png" alt="image-20230104110053926"></p><p><em>附：表1的前四行显示了各种硬件设计(如加密内核和算术单元)的保密性属性示例。使用assume语句将敏感对象的标签设置为high，并将公共可见对象的标签设置为low。</em></p></li></ul><h4 id="Integrity"><a href="#Integrity" class="headerlink" title="Integrity"></a>Integrity</h4><ul><li>完整性是保密性的双重含义，在这里我们用 <strong>high</strong> 标签标记不可信的硬件资源，并用 <strong>low</strong> 标签标记它们不会影响关键组件。</li><li><img src="https://pic.imgdb.cn/item/63b4f455be43e0d30e825002.png" alt="image-20230104110053926"><em>附：表1显示了为加密核心（crypto cores）、调试单元（debug units）、处理器（processors）和访问控制单元（ access control units)编写的四个完整性属性。</em></li></ul><h4 id="lsolation"><a href="#lsolation" class="headerlink" title="lsolation"></a>lsolation</h4><ul><li><strong>isolation</strong> 也可以作为信息流安全属性来实施。<strong>isolation</strong> 声明在具有不同信任级别的两个组件之间不应该有信息交换，是一种双向属性。</li></ul><h4 id="Constant-Time"><a href="#Constant-Time" class="headerlink" title="Constant Time"></a>Constant Time</h4><ul><li><p>信息流模型可用于捕获硬件设计中运行时变化产生的时序侧信道。 常数时间属性通过测量计算时间来评估是否可以检索敏感信息。 为了精确地捕获定时流，信息流模型需要区分逻辑流和定时流。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f455be43e0d30e825086.png" alt="image-20230104111258616"></p><p><em>附：表2总结了几种在验证不同硬件设计中的时序侧通道时所使用的特性。</em></p></li></ul><h4 id="Design-Integrity"><a href="#Design-Integrity" class="headerlink" title="Design Integrity"></a>Design Integrity</h4><ul><li><p><strong>IFT</strong> 可用于检测某些类型的未记录的设计修改，这些修改会泄漏敏感信息或通过在设计中插入恶意信息通道来覆盖关键内存位置。</p></li><li><p><img src="https://pic.imgdb.cn/item/63b4f456be43e0d30e82510b.png" alt="image-20230104112205281"></p><p><em>附：表3总结了 Trust-HUB中GLIFT检测信息泄露的特性。</em></p></li></ul><h1 id="现有的IFT技术"><a href="#现有的IFT技术" class="headerlink" title="现有的IFT技术"></a>现有的IFT技术</h1><h2 id="基于状态机的IFT语言"><a href="#基于状态机的IFT语言" class="headerlink" title="基于状态机的IFT语言"></a>基于状态机的IFT语言</h2><p><strong>Caisson</strong> 和 <strong>Sapper</strong> 是增强了 <strong>IFT</strong> 能力的 <strong>HDL</strong> 语言，可以直接生成执行所需 <strong>IFT</strong> 属性的电路。这两种语言都使用状态机进行硬件设计，并可以防止产生非法流。</p><p><strong>Caisson</strong> 通过静态类型检查来执行。这迫使他保守地执行复制以限制信息流。这会带来很大的硬件区域开销。但也显著地提高逻辑能力。</p><p><strong>Sapper</strong> 添加了动态类型系统以减少逻辑复制的需求。它通过采用混合方法进行标签检查来改进 <strong>Caisson</strong>。它使用静态分析生成一组动态检查，这些检查被插入到硬件设计中，以实现动态跟踪。这样可以重用资源，从而降低区域开销。</p><h2 id="Coq"><a href="#Coq" class="headerlink" title="Coq"></a>Coq</h2><p><strong>Coq</strong> 是一个交互式定理证明器。它允许数学断言的表达式，机械性地检查这些假设的证明，帮助寻找形式化的证明，并从构建性的证明中输出一个关于它的形式化规范的被证明有效的程序。<strong>Coq</strong> 不是一个自动定理证明器，但是包括自动定理证明工具以及各种决策流程。</p><h2 id="VeriCoq-IFT"><a href="#VeriCoq-IFT" class="headerlink" title="VeriCoq-IFT"></a>VeriCoq-IFT</h2><p><strong>VeriCoq-IFT</strong> 自动将设计从 <strong>HDL</strong> 语言转换为 <strong>Coq</strong> 形式语言，无需重新设计硬件。</p><h2 id="SecVerilog"><a href="#SecVerilog" class="headerlink" title="SecVerilog"></a>SecVerilog</h2><p><strong>SecVerilog</strong> 使用表达型类型系统扩展了 <strong>Verilog</strong> 语言。其使用的是静态类型检查方法。<strong>SecVerilog</strong> 用户需要显式地为代码中的每个变量添加安全标签。它使用类型系统来确保支持指定的信息流策略。</p><h2 id="SecChisel"><a href="#SecChisel" class="headerlink" title="SecChisel"></a>SecChisel</h2><p><strong>ChiselFlow</strong> 是另一种类型强制 <strong>HDL</strong>，带有用于开发安全硬件架构的定时标签。它已被用于创建具有硬件级信息流控制的加密加速器，并正式验证这些实现的安全性。</p><h1 id="IFT验证技术"><a href="#IFT验证技术" class="headerlink" title="IFT验证技术"></a>IFT验证技术</h1><p><strong>IFT</strong> 验证技术可以以静态或是动态的方式运行。静态 <strong>IFT</strong> 技术在设计期间通过模拟、形式化方法、仿真等来检查设计是否符合所需的安全属性。验证完成后，<strong>IFT</strong> 模型将被删除。动态硬件 <strong>IFT</strong> 是一种运行时机制，它通过跟踪逻辑来增强原始硬件设计，监视信息流行为并防止有害的信息流。通常需要付出额外的代价，例如，额外的资源使用和性能开销。</p><h2 id="模拟（simulation）"><a href="#模拟（simulation）" class="headerlink" title="模拟（simulation）"></a>模拟（simulation）</h2><p>模拟是验证硬件设计行为的常用方法。硬件安全模拟在测试台输入电路设计，观察结果是否违反了安全策略。</p><h2 id="形式化方法验证"><a href="#形式化方法验证" class="headerlink" title="形式化方法验证"></a>形式化方法验证</h2><p>形式化验证工具可以通过等价性检验、<strong>SAT</strong> 求解、定理证明或类型检验等方式，对信息流模型的安全属性进行形式化(或半形式化)验证。形式化方法的好处是，对于已证明的属性，硬件保证是安全的。验证结果在很大程度上依赖于指定的安全属性的质量和完整性。</p><h2 id="仿真（emulation）"><a href="#仿真（emulation）" class="headerlink" title="仿真（emulation）"></a>仿真（emulation）</h2><p>随着 <strong>IC</strong> 验证平台的发展，领先的 <strong>EDA</strong> 公司也开发了工具来验证 <strong>FPGA</strong> 仿真服务器上硬件设计的信息流安全属性。硬件仿真通常比软件仿真的验证性能好 <strong>10</strong> 倍。仿真是一种很有前途的方法，它利用底层硬件的信息流测量功能来执行安全协同验证并检测利用硬件安全漏洞的软件攻击。</p><h1 id="RTLIFT"><a href="#RTLIFT" class="headerlink" title="RTLIFT"></a>RTLIFT</h1><p>一种 <strong>RTLIFT</strong> 的实现步骤如下所示：设计流程跟踪库；增强跟踪逻辑的组合电路；用跟踪隐式流所需的逻辑增强条件语句。</p><p><img src="https://pic.imgdb.cn/item/63b50acfbe43e0d30ea3607b.jpg"></p><h2 id="流跟踪库"><a href="#流跟踪库" class="headerlink" title="流跟踪库"></a>流跟踪库</h2><p>为了通过 <strong>RTL</strong> 代码跟踪信息流，每个操作都应该进行检测，以便它可以同时对操作数的布尔值和安全标签进行操作。对于每个操作 <strong>OP</strong>，即 <strong>Z &#x3D; X OP Y</strong> 是 <strong>Verilog</strong> 中的有效语句，我们定义了一个模块 <strong>OP_IFT</strong>，它接收输入 <strong>X</strong> 和 <strong>Y</strong> 以及它们的安全标签 <strong>X_t</strong> 和 <strong>Y_t</strong>，并生成输出 <strong>Z</strong> 和它的安全标签 <strong>Z_t</strong>。这些模块被预定义，并作为一个称为“流跟踪库”的输入文件提供给 <strong>RTLIFT</strong> 软件。</p><h2 id="显式流跟踪"><a href="#显式流跟踪" class="headerlink" title="显式流跟踪"></a>显式流跟踪</h2><p>流跟踪首先要对每个数据位进行扩展，即在给定的 <strong>Verilog</strong> 代码中连接寄存器，使用标签承载关于数据安全属性的信息。</p><h2 id="隐式流跟踪"><a href="#隐式流跟踪" class="headerlink" title="隐式流跟踪"></a>隐式流跟踪</h2><p>仅仅跟踪显式流可能会因为忽略隐式流的存在而错误地报告条件语句中不存在流。为了跟踪这些流程，对于每个赋值操作，我们都会获得一个影响语句执行的变量列表。在这个列表中，我们生成跟踪隐式流所需的逻辑。</p><p>引用文献：<br><code>Register Transfer Level Information Flow Tracking for Provably Secure Hardware Design. Armaiti Ardeshiricham, Wei Hu, Joshua Marxen and Ryan Kastner Dept. of Computer Science and Engineering, University of California, San Diego</code></p><p><code>Hardware Information Flow Tracking. WEI HU, Northwestern Polytechnical University ARMAITI ARDESHIRICHAM and RYAN KASTNER, University of California, San Diego</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> IFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P5 回顾</title>
      <link href="/2023/01/02/BUAA-CO-P5/"/>
      <url>/2023/01/02/BUAA-CO-P5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是 <strong>bluebean</strong> 的 <strong>P5</strong> 回忆。</p><p>从 <strong>P5</strong> 开始，计组的难度暴增。课上的 <strong>P5</strong> 也是大量同学挂 <strong>P</strong> 的起点。</p><p><strong>P5</strong> 要求我们设计一个五级流水线，并带有完备的转发、阻塞逻辑。</p><p>注：本篇博客中给出的实现方法均为笔者自己的实现方法。实际上的细节实现方法不唯一，笔者的方法也不一定是最优解。</p><h1 id="流水线结构"><a href="#流水线结构" class="headerlink" title="流水线结构"></a>流水线结构</h1><p>五级流水线包含以下内容：</p><ul><li>F级：进行取指令工作。</li><li>D级：进行指令的译码，并取出 <strong>GRF</strong> 中的数据。</li><li>E级：进行 <strong>ALU</strong> 运算操作。</li><li>M级：进行 <strong>DM</strong> 存取操作。</li><li>W级：将数据写回 <strong>GRF</strong> 中。</li></ul><p>其中每两级之间都存在<strong>流水线寄存器</strong>进行级和级之间的数据交换。</p><p>借用 <strong>gxp</strong> 老师 <strong>ppt</strong> 中的图片，流水线结构如下所示：</p><p><img src="/../picture/p5_cpu.png"></p><h1 id="数据冒险与转发"><a href="#数据冒险与转发" class="headerlink" title="数据冒险与转发"></a>数据冒险与转发</h1><p>考虑以下指令：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">I1:</span> <span class="keyword">add </span>$<span class="number">2</span> $<span class="number">0</span> $<span class="number">1</span></span><br><span class="line"><span class="symbol">I2:</span> <span class="keyword">add </span>$<span class="number">3</span> $<span class="number">0</span> $<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>I1</strong> 和 <strong>I2</strong> 的指令在流水线中的流水情况可表示如下（<strong>nop</strong> 表示空指令）：</p><table><thead><tr><th>F级</th><th>D级</th><th>E级</th><th>M级</th><th>W级</th></tr></thead><tbody><tr><td>I1</td><td>nop</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>I2</td><td>I1</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>I1</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>I2</td><td>I1</td><td>nop</td></tr></tbody></table><p>我们可以看到，当 <strong>I1</strong> 处在 <strong>M</strong> 级时， <strong>I2</strong> 处在 <strong>E</strong> 级。<strong>I1</strong> 的数据要在 <strong>W</strong> 级才能写回 <strong>GRF</strong>，但是 <strong>I2</strong> 指令在 <strong>E</strong> 级就要使用 <strong>I1</strong> 提供的数据（<code>$2</code> 的数据）。如果不采用转发逻辑，则 <strong>I2</strong> 在 <strong>E</strong> 级进行计算时将会使用错误的数据进行计算。</p><p>这就是一种常见的数据冒险。解决数据冒险的办法是增加从 <strong>M</strong> 级到 <strong>E</strong> 级的数据通路，如下图所示（蓝线为新增数据通路）：</p><p><img src="/../picture/p5_cpu1.png"></p><p>在将数据传入 <strong>ALU</strong> 时判断是否产生数据冲突，若产生冲突则采用转发过来的数据。</p><p>除了上图所示的 <strong>M</strong> 级向 <strong>E</strong> 级转发，流水线中还应该包括 <strong>W</strong> 级向 <strong>E</strong> 级转发、<strong>W</strong> 级向 <strong>M</strong> 级转发、<strong>M</strong> 级向 <strong>D</strong> 级转发、<strong>W</strong> 级向 <strong>D</strong> 级转发以及寄存器堆的内部转发。</p><p>这里解释一下寄存器堆的内部转发：在同一时刻，我们可能对同一个寄存器既读又写。在这种情况，我们读出的数据应当是要写入的数据（写入的数据是更新的数据）。这就是寄存器堆的内部转发。</p><p>推荐将转发功能综合成一个模块。拿我的实现举例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> AD1E = A1useE == <span class="number">1&#x27;b0</span> ? RD1E  :</span><br><span class="line"> A1E == <span class="number">1&#x27;b0</span> ? <span class="number">32&#x27;b0</span> :</span><br><span class="line"> A1E == A3M  ? DataM :</span><br><span class="line"> A1E == A3W  ? DataW : RD1E;</span><br><span class="line"><span class="keyword">assign</span> AD2E = A2useE == <span class="number">1&#x27;b0</span> ? RD2E  :</span><br><span class="line"> A2E == <span class="number">1&#x27;b0</span> ? <span class="number">32&#x27;b0</span> :</span><br><span class="line"> A2E == A3M  ? DataM :</span><br><span class="line"> A2E == A3W  ? DataW : RD2E;</span><br></pre></td></tr></table></figure><p>解释一下各个 <strong>wire</strong> 的含义：</p><ul><li><strong>AD1E</strong> 与 <strong>AD2E</strong>：<strong>AD</strong> 是 <strong>Adventure_Data</strong> 的缩写，<strong>E</strong> 代表数据来自 <strong>E</strong> 级，<strong>1</strong> 和 <strong>2</strong> 分别是要传入 <strong>ALU</strong> 的两个操作数。</li><li><strong>A1useE</strong> 与 <strong>A2useE</strong>：<strong>A1</strong> 与 <strong>A2</strong> 分别是要使用到的两个寄存器编号，<strong>use</strong> 代表指令有没有用到寄存器。（如 <strong>addi</strong> 的 <strong>A1use</strong> 是 <strong>1</strong>， <strong>A2use</strong> 是 <strong>0</strong>，因为第二个操作数不来自寄存器堆）</li><li><strong>RD1E</strong> 与 <strong>RD2E</strong>：来自流水线寄存器的流水数据。</li><li><strong>A1E</strong> 与 <strong>A2E</strong>：要使用的寄存器编号。</li><li><strong>A3M</strong> 与 <strong>A3W</strong>：在 <strong>M</strong> 级和 <strong>W</strong> 级的指令各自的写入寄存器编号。</li><li><strong>DataM</strong> 与 <strong>DataW</strong>：分别来自 <strong>M</strong> 级和 <strong>W</strong> 级的数据。</li></ul><p>如此便实现了 <strong>M</strong> 级和 <strong>W</strong> 级向 <strong>E</strong> 级的转发逻辑。其余的转发逻辑类似。可以集成到一个模块里。</p><h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><p>有些时候，转发不能处理所有的数据冲突。</p><p>举例而言：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I1: lw $<span class="number">1</span> <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line">I2: add $<span class="number">2</span> $<span class="number">1</span> $<span class="number">0</span></span><br></pre></td></tr></table></figure><p>假如不增加阻塞逻辑的话，指令流水如下所示：</p><table><thead><tr><th>F级</th><th>D级</th><th>E级</th><th>M级</th><th>W级</th></tr></thead><tbody><tr><td>I1</td><td>nop</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>I2</td><td>I1</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>I1</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>I2</td><td>I1</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>nop</td><td>I2</td><td>I1</td></tr></tbody></table><p>乍看好像没有问题。但是要注意：<strong>lw</strong> 指令与其他通常的指令不同，要在 <strong>M</strong> 级才能产生新的数据。所以当 <strong>I1</strong> 处于 <strong>M</strong> 级时，<strong>E</strong> 级的 <strong>I2</strong> 是拿不到新数据的。 <strong>I1</strong> 必须要流水到 <strong>W</strong> 级才能够提供最新的数据。</p><p>于是转发处理不了这种数据冲突。所以我们添加<strong>阻塞</strong>逻辑。在解释阻塞之前，先看添加了阻塞逻辑之后的流水图：</p><table><thead><tr><th>F级</th><th>D级</th><th>E级</th><th>M级</th><th>W级</th></tr></thead><tbody><tr><td>I1</td><td>nop</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>I2</td><td>I1</td><td>nop</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>I1</td><td>nop</td><td>nop</td></tr><tr><td>nop</td><td>I2</td><td>nop</td><td>I1</td><td>nop</td></tr><tr><td>nop</td><td>nop</td><td>I2</td><td>nop</td><td>I1</td></tr></tbody></table><p>可以看到，我们在 <strong>I1</strong> 和 <strong>I2</strong> 之间插入了一条 <strong>nop</strong>，从而让 <strong>I2</strong> 阻塞在 <strong>D</strong> 级。这样当 <strong>I2</strong> 流水到 <strong>E</strong> 级时，就可以拿到 <strong>I1</strong> 提供的新数据了。</p><p>实现阻塞，具体而言，是在阻塞的时候冻结 <strong>F</strong> 级和 <strong>D</strong> 级，并且向 <strong>E</strong> 级传递 <strong>nop</strong> 指令（指令码全为 <strong>0</strong>）。</p><p>我们使用 <strong>AT</strong> 法判断是否需要阻塞。这部分教程讲的很详细。在实现的时候，可以在 <strong>D</strong> 级增加一个处理阻塞的模块，将各级指令产生数据的周期和需要使用数据的周期传入这个模块。模块内部使用寄存器记录处于 <strong>E</strong> 级和 <strong>W</strong> 级指令的 <strong>Tnew</strong>。在 <strong>D</strong> 级接收新的指令时，由这个模块判断新的指令与处于流水过程中的指令产生的数据冲突是否必须采用阻塞解决。若需要阻塞，则由这个模块产生阻塞信号（<strong>stall</strong>）。</p><p>关于 <strong>AT</strong> 法的更多细节可以参考教程。</p><h1 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h1><p>因为我们是在 <strong>D</strong> 级译码，所以跳转指令的判断最早只能在 <strong>D</strong> 级。于是我们就在 <strong>D</strong> 级进行跳转指令的判断。</p><p>要注意，<strong>beq</strong> 指令要使用寄存器的数据，因此也需要对其进行转发和阻塞的判断。并且由于 <strong>beq</strong> 的 <strong>Tuse</strong> 是 <strong>0</strong> （在 <strong>D</strong> 级马上就要使用数据），因此理论上 <strong>beq</strong> 经常需要阻塞的情况。</p><p>在实现跳转时，我们需要在 <strong>D</strong> 级增加一个模块 <strong>NPC</strong>，其向 <strong>F</strong> 级提供跳转使能信号和跳转的目的地址。</p><h1 id="延迟槽"><a href="#延迟槽" class="headerlink" title="延迟槽"></a>延迟槽</h1><p>当我们进行指令跳转时，由于是在 <strong>D</strong> 级做出的判断，按照单周期 <strong>CPU</strong> 的逻辑，处于 <strong>F</strong> 级中的指令（即跳转指令紧跟的下一条指令）理论上就需要作废。</p><p>所谓延迟槽，就是我们让这条<strong>按照单周期逻辑应该作废的指令不作废</strong>，从而提高指令的运行效率。</p><p>事实上，对于延迟槽我们不需要进行额外的操作。无为就可以了（乐）。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p><strong>P5</strong> 的上机难度暴增。许多同学都在 <strong>P5</strong> 献出了首挂。</p><p>上机前建议向流水线中增加额外的数据通路以供课上指令使用（在流水线寄存器中增加课上指令的通路）。</p><p>此外 <strong>P5</strong> 的课上数据点虽然也有课下的强测，但是分布不均，并且大多数测试点仍然是测试课上指令的，这一点与 <strong>P3</strong>、<strong>P4</strong> 不同。</p><p>在课上要认真读题，确保自己读懂了题目再开始写代码。在增加指令的时候一定要仔细地考虑，将每一条指令相关的信号都进行相应的判断。如涉及跳转指令除了要修改 <strong>Controller</strong> 外，还要修改 <strong>NPC</strong> 中的跳转使能信号和跳转地址。</p><p>在课上不要过于拘泥于流水线的结构。有些课上指令十分阴间。比如要在 <strong>M</strong> 级才能得知写入寄存器的编号此类。</p><p>此外就是在课上之前要好好休息，休养精神。笔者因为当天过于疲惫，在课上睡着以至于献出了首挂。大家不要学我啊呜呜呜。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P5</strong> 开始难度骤增。不过如果 <strong>P5</strong> 做的比较好，<strong>P6</strong> 就会简单很多。至于 <strong>P7</strong>，那就又是另一个故事了……</p><p>在这里特别感谢 <strong>yt</strong> 的帮助。没有 <strong>yt</strong>，就没有我的 <strong>p5</strong> （哭）。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P4 回顾</title>
      <link href="/2023/01/01/BUAA-CO-P4/"/>
      <url>/2023/01/01/BUAA-CO-P4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从 <strong>P4</strong> 开始，我们就告别 <strong>logisim</strong>，进入 <strong>verilog</strong> 的领域了。</p><p><strong>P4</strong> 要做的事情很简单，使用 <strong>verilog</strong> 实现单周期 <strong>CPU</strong>。<strong>P4</strong> 的任务实际上就是要把 <strong>P3</strong> 的 <strong>CPU</strong> 翻译到 <strong>verilog</strong> 语言。</p><p>根据不同的实现细节，在 <strong>P4</strong> 会需要数百行的码量。<strong>P4</strong> 的任务相对不难。在编写代码的时候要有良好的代码风格，遵循命名规范。</p><h1 id="CPU-设计"><a href="#CPU-设计" class="headerlink" title="CPU 设计"></a><strong>CPU</strong> 设计</h1><p>在设计上可以完全照搬 <strong>P3</strong> 中用 <strong>logisim</strong> 实现的 <strong>CPU</strong>。另外建议进行模块化设计。<strong>P3</strong> 的模块 <strong>P4</strong> 里最好都继承（或改编）过来，<strong>P3</strong> 中没有综合成模块的地方视情况也可以综合为模块。</p><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><p>在 <strong>verilog</strong> 中遵循一套自己的命名规范是很重要的。无论是驼峰法还是下划线法还是其他的规范，必须在整个代码中遵循同一套命名规范才能利于自己写代码。许多同学在大一的时候没有特意培养自己的代码风格。我的建议是可以在计组实验里开始初步培养代码风格，而不是等到下学期的 <strong>OO</strong>。</p><p>此外，能够让代码更美观的办法比如对齐等。举个例子：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> RegWrite = Add | Sub | And | Or  | Sll |</span><br><span class="line">                  Srl | Lw  | Lui | Ori | Jal |</span><br><span class="line">                  Andi| <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><p>如果将大量堆到一行里或者行之间不对齐都会导致代码的可读性降低。因此，培养良好的代码风格，从 <strong>P4</strong> 开始！</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>在有时序功能模块中记得将寄存器初始化。<strong>GRF</strong> 模块可以直接申请一个寄存器堆，在初始化的时候使用 <strong>for</strong> 循环初始化。要特别注意 <strong>GRF</strong> 中 <strong>0</strong> 号寄存器的值始终为1。</p><p>另外特殊的 <strong>IM</strong> 模块的初始化要使用 <code>$readmemh()</code>。</p><h1 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h1><p>关于 <strong>Controller</strong> 中信号的产生，可以使用宏定义的方式，或使用 <strong>wire</strong> 定义的方式。我个人采用了 <strong>wire</strong> 生成信号，距离如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Ori = op == <span class="number">6&#x27;b001101</span> ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> Lw  = op == <span class="number">6&#x27;b100011</span> ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> Sw  = op == <span class="number">6&#x27;b101011</span> ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><p>如此生成对应指令的信号。在使用的时候相当于直接将线接到对应的位置上。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p><strong>P4</strong> 的上机难度和 <strong>P3</strong> 相当，也不是很困难。</p><p>小提示：要提前留好给课上用的接口。这样会方便于通过课上。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>单周期 <strong>CPU</strong> 的绝大多数难点重点工作在 <strong>P3</strong> 中其实都已经设计完了。在 <strong>P4</strong> 中你所需要做的只有耐心的翻译代码。</p><p>话虽如此，<strong>P4</strong> 必须要认真搭建，<strong>P4</strong> 的单周期 <strong>CPU</strong> 是接下来几个 <strong>P</strong> 的起点，也是熟练 <strong>verilog</strong> 语法的机会。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> 单周期CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P3 回顾</title>
      <link href="/2022/12/31/BUAA-CO-P3/"/>
      <url>/2022/12/31/BUAA-CO-P3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从 <strong>P3</strong> 开始，工作量暴增。<strong>P3</strong> 的任务是我们使用 <strong>logisim</strong> 搭建一个单周期 <strong>CPU</strong>。想搭好这个 <strong>CPU</strong>，既要充分地掌握 <strong>logisim</strong> 的语法，又得学习单周期 <strong>CPU</strong> 的架构。</p><p>以下我将结合自身搭建的过程举例，讲解 <strong>CPU</strong> 的搭建过程。</p><h1 id="CPU-的顶层模块"><a href="#CPU-的顶层模块" class="headerlink" title="CPU 的顶层模块"></a><strong>CPU</strong> 的顶层模块</h1><p>在搭建前，要对 <strong>CPU</strong> 的整体架构有一个大致的把握。</p><p>单周期 <strong>CPU</strong> 的顶层包含的模块：<strong>PC</strong>，<strong>IM</strong>，<strong>Splitter</strong>，<strong>Controller</strong>，<strong>GRF</strong>，<strong>ALU</strong>，<strong>DM</strong>。</p><p>除此之外也可以增加一些自定义模块，起到增加 <strong>CPU</strong> 集成度，简化布线等作用。</p><p>我自己在 <strong>P3</strong> 增加了两个模块：<strong>GRFChooser</strong> 和 <strong>ALUChooser</strong>，分别选择 <strong>GRF</strong> 和 <strong>ALU</strong> 的输入信号。</p><p>我的 <strong>CPU</strong> 顶层模块一览：</p><p><img src="https://pic.imgdb.cn/item/63b048632bbf0e79945cbd1a.png"></p><p>通过编辑模块外观做到了简洁布线，视觉效果整体较为美观。</p><h1 id="PC"><a href="#PC" class="headerlink" title="PC"></a><strong>PC</strong></h1><p><strong>PC</strong> 模块的输出端口需要提供当前的指令地址。其输入端口需要包含跳转地址与跳转使能信号。</p><p><strong>PC</strong> 模块在功能上要做到以下两点：</p><ol><li>在经过一个周期后 <strong>PC</strong> 值能自增 <strong>4</strong>。</li><li>在收到跳转类指令时能修改 <strong>PC</strong> 的值到目标地址。</li></ol><h1 id="IM"><a href="#IM" class="headerlink" title="IM"></a><strong>IM</strong></h1><p><strong>IM</strong> 使用 <strong>ROM</strong> 模块实现即可。</p><p>我们需要做的只是初始化 <strong>RAM</strong> 内部数据。将当前指令地址连接到 <strong>RAM</strong> 的地址端，数据端就是对应的 <strong>指令值</strong>。</p><h1 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a><strong>Splitter</strong></h1><p><strong>Splitter</strong> 需要将读到的指令进行拆分，拆分成不同信号传递给不同的模块以供使用。</p><p>其内部直接使用分线器实现即可。</p><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a><strong>Controller</strong></h1><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>在 <strong>Controller</strong> 我们要进行指令的译码工作。根据指令的内容生成相应的控制信号。</p><p>一般而言需包含以下控制信号：</p><ul><li><strong>ALUControl</strong>：控制 <strong>ALU</strong> 模块行为，根据不同指令 <strong>ALU</strong> 对输入需要实现不同的运算。</li><li><strong>MemWrite</strong>：控制 <strong>DM</strong> 模块的写入使能信号。</li><li><strong>GRFWrite</strong>：控制 <strong>GRF</strong> 模块的写入使能信号。</li></ul><p>此外根据个人实现的不同还需要生成跳转信号（<strong>Jal</strong> 和 <strong>Beq</strong>）以及 <strong>GRF</strong>、<strong>ALU</strong>、<strong>DM</strong> 的相应选择信号。</p><p>拿我个人举例，我生成了 <strong>RegChoose</strong> 信号传递给 <strong>REGChooser</strong> 模块来选择读取 <strong>GRF</strong> 的寄存器；生成 <strong>ALUChoose</strong> 模块来选择 <strong>ALU</strong> 模块的操作数；生成 <strong>MemtoReg</strong> 信号来控制写入 <strong>GRF</strong> 的信号是来自 <strong>ALU</strong> 还是 <strong>DM</strong>。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p><strong>Controller</strong> 只需要对指令中的 <strong>op</strong> 字段和 <strong>func</strong> 字段进行译码。因此实际上只需要传入这两个信号就可以。在内部生成信号时，采用与逻辑判断指令，或逻辑生成信号。举例而言：</p><p>采用与逻辑判断指令：<br><img src="/../picture/Controller.png"></p><p>采用或逻辑生成控制信号：<br><img src="/../picture/Controller2.png"></p><p>我的 <strong>Controller</strong> 内的控制信号基本上都是按照这样的逻辑生成的，仅供参考。</p><h1 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a><strong>GRF</strong></h1><p><strong>GRF</strong> 这个东西大家应该在 <strong>P0</strong> 做过了，直接拿过来用就行。这个模块没有什么技术含量，硬着头皮连线就行。</p><h1 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a><strong>ALU</strong></h1><p>运算的操作数都使用 <strong>32</strong> 位数。一般而言需要完成基本的加减乘除还有移位操作。</p><p>所有运算操作都可以使用 <strong>logisim</strong> 内置的运算器实现。</p><h1 id="DM"><a href="#DM" class="headerlink" title="DM"></a><strong>DM</strong></h1><p><strong>DM</strong> 使用 <strong>RAM</strong> 部件即可。<strong>Data Interface</strong> 可设置成 <strong>Separate load and store ports</strong></p><p>下图是 <strong>DM</strong> 的具体连线：</p><p><img src="/../picture/DM.png"></p><p>其中 <strong>MemAddr</strong> 来自于 <strong>ALU</strong> 的运算结果，<strong>MemData</strong> 是写入 <strong>DM</strong> 的数据，来自于 <strong>GRF</strong>。</p><h1 id="ALU-和-GRF-的信号片选"><a href="#ALU-和-GRF-的信号片选" class="headerlink" title="ALU 和 GRF 的信号片选"></a><strong>ALU</strong> 和 <strong>GRF</strong> 的信号片选</h1><p>这部分可以按照自己的方式自行设计。</p><p>我在这部分的设计是这样的：</p><ol><li>传给 <strong>ALU</strong> 的第一个操作数默认来自 <strong>GRF</strong> 的 <strong>RD1</strong>，于是在 <strong>REGChooser</strong> 模块里要对传给 <strong>GRF</strong> 的第一个读数地址 <strong>A1</strong> 进行相应的选择。</li><li>传给 <strong>ALU</strong> 的第二个操作数从 <strong>GRF</strong> 的 <strong>RD2</strong>、指令的 <strong>shamt</strong> 字段（用于 <strong>sll</strong>  和 <strong>srl</strong> 指令的移位操作）、有符号扩展立即数和无符号扩展立即数（立即数来自于指令的立即数字段）。</li><li><strong>GRF</strong> 的写入数据来自于 <strong>DM</strong>、<strong>ALU</strong>、以及指令的 <strong>instr_index</strong> 字段（用于 <strong>Jal</strong> 指令）。</li><li>根据要实现的以上功能，依据不同的指令生成对应的控制信号。集成设计 <strong>Chooser</strong> 。</li></ol><p>关于我在这部分的连线可以参考上文的顶层模块图。</p><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><p>上机的时候会让你添加一些奇怪的指令。在课下建议扩展移位指令 <strong>sll</strong> 和 <strong>srl</strong> ，以及存取指令 <strong>sb</strong>、<strong>sh</strong>、<strong>lb</strong>、<strong>lh</strong>。此外对 <strong>logism</strong> 中一些基本但是不常用的运算器等也要好好掌握，比如 <strong>Bit Adder</strong>。</p><p>在课上扩展指令的时候要仔细判断控制信号的生成。建议在课下的 <strong>CPU</strong> 中预留接口。我在课上添加指令的时候基本都是采用对课上指令特判的方式。整体而言，<strong>P3</strong> 的课上是很简单的，只要课下做的足够认真，课上 <strong>AK</strong> 都不会有问题。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>P3</strong> 是我搭建的第一个 <strong>CPU</strong>。当时是照着计组的大黑书生闷硬造的。从整体架构到细节都由自己设计，看着搭建完的 <strong>CPU</strong> 心中是成就感满满。</p><p>这或许也是学习计组的乐趣所在吧。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> logisim </tag>
            
            <tag> 单周期CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成实验 P0 到 P2 回顾</title>
      <link href="/2022/12/31/BUAA-CO-P0-P2/"/>
      <url>/2022/12/31/BUAA-CO-P0-P2/</url>
      
        <content type="html"><![CDATA[<p>在写下这篇博客的时候，<strong>CO</strong> 课程已经结束了。在此回忆并记录一下计组实验过程中那些难忘的经历。</p><h1 id="P0"><a href="#P0" class="headerlink" title="P0"></a><strong>P0</strong></h1><p><strong>P0</strong> 要求我们掌握 <strong>logisim</strong> 的基本用法，并且要会在 <strong>logisim</strong> 中实现摩尔型状态机和米莉型状态机。</p><p>关于 <strong>logisim</strong> 的基本部件，我在学习的时候主要参考查阅了以下博客：</p><p><a href="https://blog.csdn.net/Hi_KER/article/details/120928866">Logisim元件用法详解一：Wiring 线</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121044637">Logisim元件用法详解二：Gates 门</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121049347">Logisim元件用法详解四：Arithmetic 运算器</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121046215">Logisim元件用法详解三：Plexers 复用器</a></p><p><a href="https://blog.csdn.net/Hi_KER/article/details/121059937">Logisim元件用法详解五：Memory 储存库</a></p><p>这几篇博客对基本部件的基本功能叙述基本齐全，在学习 <strong>logisim</strong> 的时候给了我很大帮助。</p><p>在此补充一下关于 <strong>ROM</strong> 和 <strong>RAM</strong> 部件的使用方法：</p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a><strong>ROM</strong></h2><p><strong>ROM</strong> 是只读存储器。在我们的课程中主要用于 <strong>P3</strong> 中指令存储器的设计。</p><p>侧边栏功能介绍：</p><p><img src="/../picture/RAM.png"></p><ul><li><strong>Address Bit Width</strong>：这是地址位数，决定 <strong>ROM</strong> 的容量。</li><li><strong>Data Bit Width</strong>：这是数据的位数。</li><li><strong>Contents</strong>：点击这里来编辑 <strong>ROM</strong> 中的内容。</li></ul><p>编辑 <strong>RAM</strong> 中的内容需要打开文本文件。点击 <strong>Contents</strong> 后页面如下所示：<br><img src="/../picture/RAMContents.png"><br>点击 <strong>Open</strong> 可以选择载入 <strong>txt</strong> 中的内容。点击 <strong>Save</strong> 可以将 <strong>ROM</strong> 中的内容保存在本地文件中。</p><p><strong>logisim</strong> 对于载入 <strong>ROM</strong> 的文本有格式要求：首行必须是 <code>v2.0 raw</code>，并且以十六进制格式导入数据。</p><p>比如我上面那个 <strong>Contents</strong> 示例就是将以下内容导入到 <strong>ROM</strong> 之后的结果。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v2.0 raw</span><br><span class="line">3c1fff10</span><br><span class="line">37ff00ff</span><br><span class="line">0c000c00</span><br></pre></td></tr></table></figure><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a><strong>RAM</strong></h2><p><strong>RAM</strong> 是随机存储存储器。其 <strong>Address Bit Width</strong> 和 <strong>Data Bit Width</strong> 的意义和 <strong>ROM</strong> 相同。<strong>Data Interface</strong> 可以改变 <strong>RAM</strong> 的存取端口设置。</p><p>在 <strong>P3</strong> 中，一般采用 <strong>Separate load and store ports</strong> 设置（分离的加载和存储端口）。</p><p>此外我们可以右键 <strong>RAM</strong> 模块，来编辑或清空 <strong>RAM</strong> 模块的内容。编辑 <strong>RAM</strong> 模块内容的方法和 <strong>ROM</strong> 相同。</p><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>要好好理解摩尔型状态机和米莉型状态机的区别，明确实现方法。</p><h3 id="摩尔型状态机"><a href="#摩尔型状态机" class="headerlink" title="摩尔型状态机"></a>摩尔型状态机</h3><p>一言以蔽之，输出只取决于当前状态，次态由当前状态和输入共同决定，在时钟上升沿来临时更改状态。</p><h3 id="米莉型状态机"><a href="#米莉型状态机" class="headerlink" title="米莉型状态机"></a>米莉型状态机</h3><p>与摩尔型状态机不同的地方在于<strong>输出由当前状态和输入共同决定</strong>。这意味着，当输入改变时，即使时钟上升沿没有到来，输出也应该随着输入的改变而做出相应的变化。</p><h3 id="同步复位与异步复位"><a href="#同步复位与异步复位" class="headerlink" title="同步复位与异步复位"></a>同步复位与异步复位</h3><p>异步复位的做法十分简单，直接将复位信号连接到 <strong>register</strong> 的 <strong>reset</strong> 端口即可。</p><p>同步复位则稍微复杂一些。给出一个往届的方法：</p><p><img src="/../picture/reset2.png"></p><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p>设计状态机的过程中最重要的一点是设计好状态转移的过程。 <strong>logisim</strong> 中可以根据真值表自动生成电路。这个方法在计组的教程中讲的已经十分详细了。在我们设计的状态机的状态位数和输入位数之和不太多的情况下，可以利用这一功能快速生成状态转移模块。</p><p>具体做法如下：</p><p><img src="/../picture/Moore.png"></p><p>因为按照真值表生成的电路的输入输出端口只能是一位的，故我们要将状态转移模块的输入拆分开，输出合并起来。上图中 <strong>register</strong> 中存储现态， <strong>now</strong> 代表现态输出，<strong>in</strong> 代表输入，<strong>next</strong> 代表次态。这个电路中的 <strong>MUX</strong> 起到了同步复位的作用。</p><p>其中状态转移模块内部就是由 <strong>logisim</strong> 根据真值表自动生成的电路。我们不需要关心内部具体是什么样子的，只需要保证我们的转移逻辑和拆分、合并信号时连线没有错误就可以。</p><h2 id="编辑模块外观"><a href="#编辑模块外观" class="headerlink" title="编辑模块外观"></a>编辑模块外观</h2><p><strong>logisim</strong> 默认的模块外观总是比较丑陋的…我们可以点击这个摁钮来编辑模块的外观：</p><p><img src="/../picture/logisim.png"></p><p>我们可以编辑模块的形状、端口位置、添加文字说明等等。通过编辑模块的外观我们可以大大美化电路，这在 <strong>P3</strong> 中尤为明显（或许不是十分的重要）。</p><h2 id="合理运用-Tunnel"><a href="#合理运用-Tunnel" class="headerlink" title="合理运用 Tunnel"></a>合理运用 <strong>Tunnel</strong></h2><p><strong>Tunnel</strong> 是尤为常用的一个部件。合理使用 <strong>Tunnel</strong> 能大大简化我们的布线，让模块整体更加美观。但是不建议滥用 <strong>Tunnel</strong>。滥用的缺点是让电路更难看懂（因为不能直观的看到连线情况）。</p><h2 id="一个-logisim-的-bug"><a href="#一个-logisim-的-bug" class="headerlink" title="一个 logisim 的 bug"></a>一个 <strong>logisim</strong> 的 <strong>bug</strong></h2><p>我在 <strong>P0</strong> 上机的时候遇到了一个 <strong>logisim</strong> 的 <strong>bug</strong>：所有的连线全部是蓝色 的。遇到这种情况首先要检查 <strong>Simulate</strong> 设置中的 <strong>Simulation Enable</strong> 选项，这个选项应该是打开的；然后在保存后直接重启 <strong>logisim</strong> 就可以恢复啦！</p><h1 id="P1"><a href="#P1" class="headerlink" title="P1"></a><strong>P1</strong></h1><p>在 <strong>P1</strong> 中我们要掌握 <strong>Verilog</strong> 的基本语法，学会组合逻辑和时序逻辑，并且要会在 <strong>Verilog</strong> 中写状态机。</p><h2 id="常数的写法"><a href="#常数的写法" class="headerlink" title="常数的写法"></a>常数的写法</h2><p><strong>verilog</strong> 中常数的写法是 <code>&lt;常数位数&gt;&#39;&lt;类型&gt;&lt;值&gt;</code>。教程里说的很详细，这里不再多说。</p><p>主要是想提醒大家在写代码的时候每一个数字都要遵循 <code>&lt;常数位数&gt;&#39;&lt;类型&gt;&lt;值&gt;</code> 的形式，不要没头没尾的写一个数字上去。一般而言，写 <strong>verilog</strong> 程序中我们接触二进制、十六进制数字的次数要比十进制数字的次数多得多。</p><h2 id="阻塞赋值与非阻塞赋值"><a href="#阻塞赋值与非阻塞赋值" class="headerlink" title="阻塞赋值与非阻塞赋值"></a>阻塞赋值与非阻塞赋值</h2><p>在初学 <strong>Verilog</strong> 时要区分阻塞赋值与非阻塞赋值。</p><h3 id="阻塞赋值"><a href="#阻塞赋值" class="headerlink" title="阻塞赋值"></a>阻塞赋值</h3><p>阻塞赋值使用 <code>=</code>。阻塞赋值可以理解为物理上的直接连线。当右边的值（驱动量）发生变化时，左侧值将立刻发生变化。建议只在组合逻辑中使用阻塞赋值。</p><p>阻塞赋值一般是赋值给 <strong>wire</strong> 型变量的。但是视情况也可以赋值给 <strong>reg</strong> 型变量和 <strong>integer</strong> 型变量。</p><h3 id="非阻塞赋值"><a href="#非阻塞赋值" class="headerlink" title="非阻塞赋值"></a>非阻塞赋值</h3><p>非阻塞赋值使用 <code>&lt;=</code>。非阻塞赋值会在一个块结束后统一赋值。比如下列代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">    b &lt;= a;</span><br><span class="line">    a &lt;= b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以上代码的结果是在每一个时钟上升沿到来时交换 <strong>a</strong> 和 <strong>b</strong> 的值。非阻塞赋值建议只在 <strong>always</strong> 块内给 <strong>reg</strong> 型变量赋值使用（时序逻辑）。</p><h2 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h2><p>组合逻辑有两种写法，一种是使用 <strong>wire</strong> 和阻塞赋值（下称连线），一种是使用 <strong>wire</strong> 和 <code>always@(*)</code> 块内使用非阻塞赋值。我个人比较喜欢使用第一种写法。在进行条件判断时，要嵌套三目运算符 <code>? :</code>。</p><p>使用第一种写法时注意 <strong>wire</strong> 型变量只能连线一次。此外可以在定义 <strong>wire</strong> 型变量时直接连线。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> judge = <span class="keyword">input</span> &amp; <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]ans = en == <span class="number">1&#x27;b0</span> ? <span class="number">2&#x27;b00</span> :</span><br><span class="line">                judge == <span class="number">1&#x27;b1</span> ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b10</span>;</span><br></pre></td></tr></table></figure><p>上述代码的功能：当使能信号 <strong>en</strong> 为 <strong>0</strong> 时，<strong>ans</strong> 保持为 <strong>0</strong>，当使能信号为 <strong>1</strong> 且输入为奇数时， <strong>ans</strong> 为 <strong>1</strong>，否则为 <strong>2</strong>。</p><h2 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h2><p>时序逻辑使用 <strong>always</strong> 块和非阻塞赋值。建议一个模块只使用一个 <strong>always</strong> 块，并且在一个 <strong>always</strong> 内要保证每个时钟上升沿来临时对使用到的每个 <strong>reg</strong> 变量都<strong>有且仅有</strong>一次赋值。</p><p>在时序逻辑中可以使用 <em>if-else</em> 语句和 <em>switch</em> 语句进行条件判断。不再多说。</p><h2 id="同步复位与异步复位-1"><a href="#同步复位与异步复位-1" class="headerlink" title="同步复位与异步复位"></a>同步复位与异步复位</h2><p>同步复位的写法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset == <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行复位操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行其他操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>异步复位的写法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset == <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行复位操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//进行其他操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这两种复位方法都要掌握，在上机时一般都会考到。</p><h2 id="状态机-1"><a href="#状态机-1" class="headerlink" title="状态机"></a>状态机</h2><p>在通过 <strong>P0</strong> 之后相信对两种状态机已经足够了解了。在 <strong>verilog</strong> 中实现两种状态机并不难。合理地将组合逻辑和时序逻辑组合使用便可以搭建两种状态机。在写状态机的时候最重要的还是设计状态和状态转移逻辑，编写代码只需要足够的细心即可。</p><p>在编写时序逻辑的时候要注意每一个 <strong>if</strong> 块都要有 <strong>else</strong> 作为结尾，在 <strong>else</strong> 内部编写 <strong>default</strong> 逻辑。</p><h1 id="P2"><a href="#P2" class="headerlink" title="P2"></a><strong>P2</strong></h1><p>在 <strong>P2</strong> 中，我们要掌握 <strong>Mars</strong> 的用法。<strong>Mars</strong> 的用法在教程里教的很详细，不再多说。这里主要是提几点建议和要注意的地方。</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>写 <strong>Mars</strong> 程序时要合理地使用宏（<code>.micro</code>）来简化代码。诸如读取数字、输出数字、数据的压栈、弹栈等都可以使用宏来编写。这里给两个压栈和弹栈的例子：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据压栈</span></span><br><span class="line"><span class="meta">.macro</span> stackPush(%num)</span><br><span class="line"><span class="keyword">sw </span>%num <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">sp</span> $<span class="built_in">sp</span> -<span class="number">4</span></span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据弹栈</span></span><br><span class="line"><span class="meta">.macro</span> stackPop(%num)</span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">sp</span> $<span class="built_in">sp</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">lw </span>%num <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>写递归的时候要注意数据的压栈和弹栈。在进入函数的时候压栈，在函数结束的时候弹栈。</p><p>一般使用 <strong>$a0-$a3</strong> 来进行函数的传参，使用 <strong>$v0-$v1</strong> 来接受函数的返回值。</p><h2 id="Mars-文档"><a href="#Mars-文档" class="headerlink" title="Mars 文档"></a><strong>Mars</strong> 文档</h2><p>在 <strong>Mars</strong> 中 <strong>F1</strong> 键可以调出 <strong>Mars</strong> 帮助文档。在写代码的时候可以提供莫大帮助。在上机前建议弄懂字符串的读写，我这届有许多同学因为不了解字符串的读写而在 <strong>P2</strong> 上机的时候翻车。</p><h2 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h2><p><strong>P2</strong> 上机写 <strong>Mars</strong> 代码个人感触最重要的还是细心。在 <strong>P2</strong> 中哪怕写错一个寄存器的名字也会寄。细心编写的代码能减少 $80$% 的 <strong>bug</strong>。我在上机时遇到的 <strong>bug</strong> 基本全都是因为粗心导致的。</p><p>在上机前可以提前在机房电脑上做一些准备，诸如调整机房里 <strong>Mars</strong> 的字体设置等；也可以背下来一些宏，提前敲进去。</p><p>一般而言 <strong>P2</strong> 的上机都是翻译 <strong>C</strong> 语言代码。如果他没有给出 <strong>C</strong> 代码，那就自己写一份 <strong>C</strong> 代码再翻译成 <strong>Mars</strong> 代码，能减少 <strong>bug</strong> 数量和 <strong>dbug</strong> 难度。在翻译代码的时候合理分配那几个寄存器的使用，个人翻译本身感觉难度不大。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大致回忆了一下 <strong>P0</strong> 到 <strong>P2</strong> 的知识点和坑点。这几个 <strong>P</strong> 都是在为后面搭 <strong>CPU</strong> 打基础，因此难度不是很大。</p><p>欢迎在评论区讨论交流。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> verilog </tag>
            
            <tag> logisim </tag>
            
            <tag> mips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客~</title>
      <link href="/2022/12/29/hello-world/"/>
      <url>/2022/12/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是 <strong>bluebean</strong> 的第一篇博客，记录一下搭建过程顺便测试测试各种功能~</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>搭建过程中真是参考了很多大佬的博客呀。</p><p>搭建过程中遇到了一些坑。本来想采用 <strong>Matery</strong> 主题的，但是实在是调不来配置了……接触 <strong>Butterfly</strong> 主题后我发现这个主题更加完善，<strong>bug</strong> 更少，风格也十分简洁，故最后选择了配置<strong>Butterfly</strong> 主题。</p><p>以下是对我帮助十分大的几篇博客：</p><p>从零开始，使用 <strong>butterfly</strong> 主题搭建博客：<a href="https://www.fomal.cn/posts/e593433d.html#8-%E5%88%9D%E5%A7%8B%E5%8C%96-Hexo-%E9%A1%B9%E7%9B%AE">Hexo博客搭建基础教程</a></p><p>另一篇从零开始的教程：<a href="https://www.cnblogs.com/huanhao/p/hexobase.html#%E5%9F%BA%E7%A1%80%E7%AF%87%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E4%B8%80">hexo博客搭建教程</a></p><p>这篇博客有对 <strong>butterfly</strong> 主题各项配置的详细说明：<a href="https://www.fomal.cn/posts/3451f874.html">Butterfly配置</a></p><p>这篇博客也作为参考：<a href="https://moonshuo.cn/posts/37568.html">Butterfly主题配置美化</a></p><h2 id="公式测试"><a href="#公式测试" class="headerlink" title="公式测试"></a>公式测试</h2><p>随便输点公式，测试一下对数学公式的支持。</p><p>整行公式：<br>$$<br>f(x)&#x3D;\begin{cases} \frac{\beta^\alpha}{\Gamma(\alpha)},\quad x&gt;0\ 0,\quad x\leq0\end{cases}<br>$$<br>行内公式：$\int_{-\infty}^{+\infty}e^{-x^2}dx&#x3D;\sqrt{\pi}$</p><h2 id="代码块测试"><a href="#代码块测试" class="headerlink" title="代码块测试"></a>代码块测试</h2><p>代码块测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内代码测试：<code>printf(&quot;hello world!\n&quot;);</code></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
